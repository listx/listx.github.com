<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Linus's Blog - Programming Puzzle: Game Button Sequence Recognizer</title>
		<link rel="stylesheet" href="../css/base.css">
		<link rel="stylesheet" href="../css/syntax.css">
		<link href="http://fonts.googleapis.com/css?family=Merriweather:300,300italic,700italic,700" rel="stylesheet" type="text/css">
		<link rel="shortcut icon" type="image/png" href="../favicon.png">
		<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	</head>
	<body>
		<div id="header">
			<a href="../">Home</a>
			&bull;
			<a href="../about.html">About</a>
			&bull;
			<a href="../art.html">Art</a>
			&bull;
			<a href="../code.html">Code</a>
			&bull;
			<a href="../papers.html">Papers</a>
			&bull;
			<a href="../archive.html">Archive</a>
		</div>

		<div id="content">
			<h1 class="center">Programming Puzzle: Game Button Sequence Recognizer</h1>

			<div class="info center">
	<code class="date">2015-02-24</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-24-puzzle-game-button-recognizer.md" title="History">*</a>
	<br>
	<a href="../tag/programming.html">programming</a>, <a href="../tag/haskell.html">haskell</a>, <a href="../tag/ruby.html">ruby</a>
</div>

<p>So just yesterday, I did a live coding interview. Looking back, the problem I was presented with was very simple, but true to my usual nervous self, I over-analzyed the problem — completely missing the point and needlessly complicating things. In an effort to redeem myself, I thought about the problem again and even went out as to write tests for it, in both Ruby and Haskell. If you want to have a crack at the problem yourself, be conservative about scrolling down the page! Without further ado, I present the problem to you.</p>
<h2 id="the-problem">The Problem</h2>
<p>You are a game engine API writer. You need to implement a mechanism that allows your developers to store and retrieve game moves based on the input to the game engine. The two functions for this mechanism should be named <code>register()</code> and <code>on_button()</code>.</p>
<p><code>register()</code> should take a named button sequence, and store it into the database of all named sequences. A single named sequence might look like this: <code>([&quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;], &quot;hadoken&quot;)</code>.</p>
<p><code>on_button()</code> should take a single key, and then return all named sequences that match the ones in the database. E.g., <code>on_button(&quot;punch&quot;)</code> should return <code>&quot;hadoken&quot;</code> if the previous two inputs were <code>&quot;down&quot;</code> and <code>&quot;forward&quot;</code>.</p>
<h3 id="some-constraints">Some Constraints</h3>
<h4 id="multiple-sequences">Multiple Sequences</h4>
<p>Because our API is flexible, we allow <em>multiple</em> named sequences with the <em>same sequence</em>. Thus, you can expect something like this:</p>
<pre><code>register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut&quot;)
register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut_2&quot;)
on_button(&quot;up&quot;)        # no result
on_button(&quot;punch&quot;)     # [&quot;uppercut&quot;, &quot;uppercut_2&quot;]</code></pre>
<p>. You don’t have to worry about multiple named sequences with the same sequence and also the same name — we will worry about this “exact duplicate” situation in a later version of our API.</p>
<h4 id="input-history">Input History</h4>
<p>You might have noticed that <code>on_button()</code> depends on the input history of whatever buttons were <em>previously</em> entered into the game. Because of this, you can alternatively write an <code>on_buttons()</code> function (plural with an “s”) that takes the history of buttons as input; this way you don’t have to silently depend on the global state of input history.</p>
<h2 id="my-nervous-wreck-solution">My Nervous-Wreck Solution</h2>
<p>I decided to use pure Haskell code in the actual interview. The code I wrote had the general idea, but it was a big failure because it performed a naive, custom search without any thought given to data structures. I actually went back and revised the code to make it compile and work <em>after</em> the interview was over; here it is in all its glory:</p>
<div class="code-and-raw">
<table class="sourceCode numberLines haskell" input="code/toy/game-button-seq/interview_ver.hs"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="fu">=</span> [(<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>)]
<span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="fu">=</span> [<span class="dt">String</span>]
<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="co">-- Default DB of button sequences.</span>
<span class="ot">buttonSeqDB ::</span> <span class="dt">ButtonSeqDB</span>
buttonSeqDB <span class="fu">=</span>
	[ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;hadoken&quot;</span>)
	, ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;charger&quot;</span>)
	, ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut&quot;</span>)
	]

<span class="ot">register ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span>
register sequence name db
	<span class="fu">|</span> null sequence <span class="fu">=</span> db
	<span class="fu">|</span> alreadyExists <span class="fu">=</span> db
	<span class="fu">|</span> otherwise <span class="fu">=</span> (sequence, name) <span class="fu">:</span> db
	<span class="kw">where</span>
	alreadyExists <span class="fu">=</span> elem (sequence, name) db

<span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons buttonHist db <span class="fu">=</span> map snd
	<span class="fu">.</span> fst
	<span class="fu">.</span> foldl step ([], db)
	<span class="fu">$</span> reverse buttonHist
	<span class="kw">where</span>
	step acc<span class="fu">@</span>(foundSoFar, dbRem) button
		<span class="fu">|</span> null remaining <span class="fu">=</span> acc
		<span class="fu">|</span> otherwise <span class="fu">=</span>
			( foundSoFar <span class="fu">++</span> entriesComplete
			, dbRem'
			)
		<span class="kw">where</span>
		remaining <span class="fu">=</span> filter ((<span class="fu">==</span>button) <span class="fu">.</span> last <span class="fu">.</span> fst)
			<span class="fu">$</span> filter (not <span class="fu">.</span> null <span class="fu">.</span> fst) dbRem
		dbRem' <span class="fu">=</span> map (\(a, b) <span class="ot">-&gt;</span> (init a, b)) remaining
		entriesComplete <span class="fu">=</span> filter (null <span class="fu">.</span> fst) dbRem'</code></pre></td></tr></table>
<div class="raw-link">
<a class="raw" href="../code/toy/game-button-seq/interview_ver.hs" mimetype="text/plain"> interview_ver.hs </a>
</div>
</div>
<p>. I have to admit, the <code>step</code> function in <code>onButtons</code> is essentially unreadable. But it does work:</p>
<pre><code>$ ghci game-button-seq-interview.hs
GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( code/toy/game-button-seq-interview.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; onButtons [&quot;down&quot;, &quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;] buttonSeqDB
[&quot;charger&quot;,&quot;hadoken&quot;]</code></pre>
<p>.</p>
<p>Anyway, I will explain the behavior of the code. The first thing to notice is that we feed into <code>step</code> the <em>reversed</em> list of <code>buttonHist</code>, so that we examine the button press history, from newest to oldest. So we look at the just-pressed-button, then the one before that, and the one before, etc, backwards up the history.</p>
<p>As we look at each <code>button</code>, we use it to filter out all known sequences. This filtering is done in <code>remaining</code>, where we check the last button of every known sequence, and see if that matches the current button. That’s what the line <code>filter ((==button) . last . fst)</code> does; the sister line <code>filter (not . null . fst) dbRem</code> is just there to prevent calling <code>last</code> on an empty list.</p>
<p>After we’re done checking, we modify the entire sequence database <code>db</code>, such that we only care about the first <span class="math">\(N - 1\)</span> buttons in the sequence. This way, on the next iteration, we can rest assured that checking against the “last” button in a sequence is not always the same button. In subsequent runs of <code>step</code>, we have <code>dbRem</code>’s sequences slowly get reduced down to nothing as we keep chopping off all sequences’s last button. Keep in mind that we feed the filtered, matching entries of <code>db</code> back into subsequent runs of <code>step</code>, so that effectively we’re only working with matching sequences. Once we reach down to no buttons, we label these named sequences as <code>entriesComplete</code>, and append it into <code>foundSoFar</code>.</p>
<h3 id="analysis">Analysis</h3>
<p>Obviously, this code has many problems. First, it is virtually unreadable. Readability is important, and the code feels very counter-intuitive — it is marvelously complex when the problem statement sounds so simple.</p>
<p>Second, the fact that we have to bring in and mutate <code>dbRem</code>, which is a copy of the original given <code>ButtonSeqDB</code> type, seems wasteful. We’re wasting a lot of CPU cycles here.</p>
<h2 id="ruby-solution-using-hashes">Ruby Solution Using Hashes</h2>
<p>So on the day after (that is, <em>today</em> as of the time of this writing), I thought about the problem again and realized we can use hashes. It is a very simple approach, with far less lines of code. I even wrote a small test for it. Here is the implementation below.</p>
<div class="code-and-raw">
<table class="sourceCode numberLines ruby" input="code/toy/game-button-seq/hash_ver.rb"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">GameButtonSeq</span>
  <span class="co"># button_seq = [&quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;]</span>
  <span class="co"># name = &quot;hadoken&quot;</span>
  <span class="co"># button_seq_db = a hash of {sequence =&gt; name}, but a sequence can have</span>
  <span class="co"># multiple names if that sequence already exists.</span>
  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.register(button_seq, name, button_seq_db)
    <span class="co"># If the sequence already exists, simply add the new name to the old name,</span>
    <span class="co"># and store it as a list of names.</span>
    <span class="kw">if</span> button_seq_db.key?(button_seq)
      button_seq_db[button_seq] = [name] + button_seq_db[button_seq]
    <span class="kw">else</span>
      button_seq_db[button_seq] = [name]
    <span class="kw">end</span>

    button_seq_db
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.on_buttons(button_seq, button_seq_db)
    found = []
    <span class="co"># We search the entire button_seq_db hash for the full length of N buttons</span>
    <span class="co"># first, then N - 1 buttons, then N - 2 buttons, until the search input</span>
    <span class="co"># becomes 0. Meanwhile, we collect any and all matches that come our way.</span>
    <span class="co"># The point is to search based on the *last* input button, as this is the</span>
    <span class="co"># &quot;current&quot; button that should &quot;finish&quot; whatever combination/move we were</span>
    <span class="co"># trying to do.</span>
    <span class="kw">while</span> button_seq.size &gt; <span class="dv">0</span>
      <span class="kw">if</span> button_seq_db.key?(button_seq)
        found &lt;&lt; button_seq_db[button_seq]
      <span class="kw">end</span>
      <span class="co"># Discard oldest button press, and search again. Even if we have a match,</span>
      <span class="co"># it's important to search for other matches, too.</span>
      button_seq.shift
    <span class="kw">end</span>

    <span class="co"># Clean up, so that we get [&quot;foo&quot;, &quot;bar&quot;] instead of [[&quot;foo&quot;], [&quot;bar&quot;]].</span>
    found.flatten
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.add_hist(button_hist, button_name)
    button_hist + [button_name]
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table>
<div class="raw-link">
<a class="raw" href="../code/toy/game-button-seq/hash_ver.rb" mimetype="text/plain"> hash_ver.rb </a>
</div>
</div>
<p>And here is the test case for it. You can run it with <code>ruby test_hash_ver.rb</code>.</p>
<div class="code-and-raw">
<table class="sourceCode numberLines ruby" input="code/toy/game-button-seq/test_hash_ver.rb"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby">require <span class="st">'minitest/autorun'</span>
require_relative <span class="st">'./hash_ver.rb'</span>

<span class="kw">class</span> <span class="dt">TestPuz</span> &lt; <span class="dt">Minitest</span>::<span class="dt">Test</span>

  <span class="kw">def</span> setup
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;hadoken&quot;</span>, {})
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;charger&quot;</span>, <span class="ot">@db</span>)
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut&quot;</span>, <span class="ot">@db</span>)

    <span class="co"># Aside: We can easily limit the size of button_hist[] by forcefully always</span>
    <span class="co"># saving only the last N key presses, with N determined by the longest</span>
    <span class="co"># button sequence.</span>
    <span class="ot">@button_hist</span> = []

    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;forward&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;punch&quot;</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_multiple_names_entered
    db2 = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut_2&quot;</span>, <span class="ot">@db</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(button_hist2, <span class="st">&quot;punch&quot;</span>)
    assert_equal [<span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, db2)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_no_sequence_found
    <span class="co"># Add an unrecognized button.</span>
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;back&quot;</span>)
    assert_equal [],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, <span class="ot">@db</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_one_sequence_found
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(button_hist2, <span class="st">&quot;punch&quot;</span>)
    assert_equal [<span class="st">&quot;uppercut&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, <span class="ot">@db</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_multiple_sequences_found
    assert_equal [<span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(<span class="ot">@button_hist</span>, <span class="ot">@db</span>)
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table>
<div class="raw-link">
<a class="raw" href="../code/toy/game-button-seq/test_hash_ver.rb" mimetype="text/plain"> test_hash_ver.rb </a>
</div>
</div>
<h3 id="analysis-1">Analysis</h3>
<p>The key insight was when I realized that you could indeed use a hash even though we have the requirement that multiple, identical button sequences can have different names. The trick is to simply store the value as not a single name, but an array of possible names. This is reflected in the <code>GameButtonSeq.register</code> method.</p>
<p>The heart of <code>on_buttons()</code> is a single <code>while</code> loop that checks the given button history against the database; we reduce the button sequence by 1 button on each iteration to check against shorter matches as well. That’s what the <code>button_seq.shift</code> is for.</p>
<h2 id="haskell-solution-using-hashes">Haskell Solution Using Hashes</h2>
<p>Inspired by the Ruby solution, I rewrote a Haskell version — with tests to boot! Here is the implementation.</p>
<div class="code-and-raw">
<table class="sourceCode numberLines haskell" input="code/toy/game-button-seq/GameButtonSeq.hs"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">GameButtonSeq</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="co">-- The database stores a list of Name values, because multiple sequences can</span>
<span class="co">-- have the same name, in which case we store just one instance of the sequence,</span>
<span class="co">-- but a list of multiple Name values.</span>
<span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]
<span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="fu">=</span> [<span class="dt">String</span>]
<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="co">-- If a button sequence is already given some set of names, add the current</span>
<span class="co">-- given name into that list of names..</span>
<span class="ot">register ::</span> (<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>) <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span>
register (buttonSeq, name) db <span class="fu">=</span> <span class="kw">case</span> M.lookup buttonSeq db <span class="kw">of</span>
	<span class="dt">Just</span> names <span class="ot">-&gt;</span> M.insert buttonSeq (name<span class="fu">:</span>names) db
	<span class="dt">Nothing</span> <span class="ot">-&gt;</span> M.insert buttonSeq [name] db

<span class="co">-- Input `buttonSeq` is a list of buttons pressed, from oldest to newest, so</span>
<span class="co">-- that the head of the list contains the oldest button.</span>
<span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons buttonHist db <span class="fu">=</span> concatMap extractNames buttonHists
	<span class="kw">where</span>
	buttonHists <span class="fu">=</span> take (length buttonHist) <span class="fu">$</span> iterate tail buttonHist
	extractNames bHist <span class="fu">=</span> <span class="kw">case</span> M.lookup bHist db <span class="kw">of</span>
		<span class="dt">Just</span> names <span class="ot">-&gt;</span> names
		<span class="dt">Nothing</span> <span class="ot">-&gt;</span> []

<span class="ot">onButtons2 ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons2 buttonHist db <span class="fu">=</span> concat <span class="fu">$</span> mapMaybe (flip M.lookup db) buttonHists
	<span class="kw">where</span>
	buttonHists <span class="fu">=</span> take (length buttonHist) <span class="fu">$</span> iterate tail buttonHist</code></pre></td></tr></table>
<div class="raw-link">
<a class="raw" href="../code/toy/game-button-seq/GameButtonSeq.hs" mimetype="text/plain"> GameButtonSeq.hs </a>
</div>
</div>
<p>The file is named <code>GameButtonSeq</code> because of Haskell naming conventions for files containing module code. And here is the test for it.</p>
<div class="code-and-raw">
<table class="sourceCode numberLines haskell" input="code/toy/game-button-seq/test_hash_ver.hs"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span>

<span class="kw">import </span><span class="dt">GameButtonSeq</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain tests

<span class="ot">tests ::</span> <span class="dt">TestTree</span>
tests <span class="fu">=</span> testGroup <span class="st">&quot;Tests&quot;</span> [qcProps, unitTests]

<span class="ot">qcProps ::</span> <span class="dt">TestTree</span>
qcProps <span class="fu">=</span> testGroup <span class="st">&quot;(checked by QuickCheck)&quot;</span>
	[ QC.testProperty <span class="st">&quot;GameButtonSeq (empty DB cannot produce matches)&quot;</span> <span class="fu">$</span>
		\buttonHist <span class="ot">-&gt;</span> onButtons (<span class="ot">buttonHist ::</span> <span class="dt">ButtonSeq</span>) M.empty <span class="fu">==</span> []
	]

<span class="ot">unitTests ::</span> <span class="dt">TestTree</span>
unitTests <span class="fu">=</span> testGroup <span class="st">&quot;Unit tests&quot;</span>
	[ testCase <span class="st">&quot;GameButtonSeq (entry of multiple sequences with same name)&quot;</span> <span class="fu">$</span>
		(onButtons [<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]
		<span class="fu">$</span> register ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut_2&quot;</span>) buttonSeqDB)
			<span class="fu">@?=</span>
			[<span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span>]
	, testCase <span class="st">&quot;GameButtonSeq (no sequence found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>, <span class="st">&quot;down&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[]
	, testCase <span class="st">&quot;GameButtonSeq (one sequences found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[<span class="st">&quot;uppercut&quot;</span>]
	, testCase <span class="st">&quot;GameButtonSeq (multiple sequences found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[<span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span>]
	]
	<span class="kw">where</span>
	<span class="co">-- Default DB of button sequences.</span>
<span class="ot">	buttonSeqDB ::</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]
	buttonSeqDB <span class="fu">=</span> M.fromList
		[ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;hadoken&quot;</span>])
		, ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;charger&quot;</span>])
		, ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;uppercut&quot;</span>])
		]</code></pre></td></tr></table>
<div class="raw-link">
<a class="raw" href="../code/toy/game-button-seq/test_hash_ver.hs" mimetype="text/plain"> test_hash_ver.hs </a>
</div>
</div>
<h3 id="analysis-2">Analysis</h3>
<p>This Haskell version uses the standard <code>Data.Map</code> module, which provides an efficient, basic hash data structure. What we first do is expand <code>buttonHist</code> to all of the cases we are interested in — namely, all of the subsequences of concern. E.g., given a list like <code>[&quot;up&quot;, &quot;down&quot;, &quot;right&quot;, &quot;left&quot;]</code>, <code>buttonHists</code> becomes:</p>
<pre><code>[ [&quot;up&quot;, &quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,       [&quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,               [&quot;right&quot;, &quot;left&quot;]
,                        [&quot;left&quot;]
]</code></pre>
<p>(spaces added for readability). What we do is reduce the initial input list into all of the “sublist” combinations of <span class="math">\(N\)</span> buttons, <span class="math">\(N - 1\)</span> buttons, <span class="math">\(N - 2\)</span> buttons, etc.</p>
<p>The next step is to simply look at each sublist with <code>concatMap</code>, calling <code>extractNames</code>; we treat each sublist as a key, and look for it in our <code>db</code> hash. We then simply concatenate the results.</p>
<p>The <code>onButtons2</code> is an alternate version which uses <code>mapMaybe</code> to reduce it down to just two lines of code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I cringe as I look back at the half-baked code I wrote during the interview. Even the working, compilable version that I wrote after the interview remains ugly and hard to reason about. I can picture my interviewer being grossed out by my ugly, hacky version wondering if I even know what hashes are…</p>
<p>The moral of the story is to think carefully about the most obvious data structure to use, before embarking on writing a solution — no matter how trivial it seems. For myself, I was nervous and did not realize how simple the problem actually was until the day after when I rewrote the solution in Ruby. It was so simple and straightforward that I even wrote some test cases for it<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>I hope you had some fun writing out your own solutions. Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You can test the Haskell hash version in this blog post if you clone this blog’s repo and then build it with Cabal (I’ve listed the program as an executable with all the constraints in the <code>blog.cabal</code> file in the repo root folder). For the Ruby version, simply do <code>ruby path/to/test_hash_ver.rb</code> and Ruby will run the tests inside.<a href="#fnref1">↩</a></p></li>
</ol>
</div>

		</div>
		<div id="footer">
			<p>Copyright (C) 2013-2014 Linus Arver. All rights reserved.</p>
			<a href="https://github.com/listx/listx_blog">Site</a>
			<a href="https://github.com/listx/listx.github.io">generated</a>
			with
			<a href="http://jaspervdj.be/hakyll">Hakyll</a>
			and
			<a href="http://sebastiaanvisser.github.com/clay">Clay</a>.
			<br>
			<a href="../atom.xml">Atom feed</a>
		</div>
	</body>
</html>
