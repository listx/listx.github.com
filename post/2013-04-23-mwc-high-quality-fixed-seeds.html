<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Linus's Blog - Haskell: System.Random.MWC: High Quality Fixed Seeds</title>
		<link rel="stylesheet" href="../css/base.css">
		<link rel="stylesheet" href="../css/syntax.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Serif+Pro">
		<link rel="shortcut icon" type="image/png" href="../favicon.png">
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="../misc.js"></script>
		<!-- https://github.com/mreid/markreidname-hakyll/blob/master/_templates/mathjax.html -->
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		extensions: ["tex2jax.js"],
		jax: ["input/TeX", "output/HTML-CSS"],
		tex2jax: {
			inlineMath: [ ["\\(","\\)"] ],
			displayMath: [ ["\\[","\\]"] ],
			processEscapes: true
		},
		TeX: { equationNumbers: { autoNumber: "AMS" } },
		"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>

	</head>
	<body>
		<div id="header">
			<a href="../">Blog</a>
			&bull;
			<a href="../about.html">About</a>
			&bull;
			<a href="../etc.html">Etc</a>
		</div>

		<div id="content">
			<h1 class="center" id="page-title">Haskell: System.Random.MWC: High Quality Fixed Seeds</h1>

			<div class="info center">
	<code class="date">2013-04-23</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2013-04-23-mwc-high-quality-fixed-seeds.org" title="History">*</a>
	<br>
	<a href="../tag/haskell.html">haskell</a>, <a href="../tag/rng.html">rng</a>
</div>

<p>I use Bryan O’Sullivan’s <a href="http://hackage.haskell.org/package/mwc-random"><code>mwc-random</code></a> package for my PRNG (pseudorandom number generator) needs in my Haskell projects. <code>mwc-random</code> is very fast and generates high quality random numbers. It has a pretty simple API, and gives you several options of initializing the RNG state. One way is to use the <code>initialize</code> function, which simply takes a list of <code>Word32</code> elements and takes the first 256 of them to seed the generator (if less than 256, it fills the rest from a hard-coded list). I’ve discovered that using a simple list of 3 small numbers representing the year, month, and day (e.g., <code>[2013, 4, 11]</code>) is not very good as an argument to <code>initialize</code>, as the generator behaves somewhat similarly to, say, one with slightly different date (e.g., <code>[2013, 4, 12]</code>).</p>
<h1 id="the-problem">The Problem</h1>
<p>I have a program that needs to be seeded on a day-by-day basis, and it must use the current date (year, month, and day only) as the seed; however, I need the seed to be random enough to make the MWC state spit out substantially different random numbers on different, yet similar days. In essence, I need to change</p>
<div class="sourceCode" id="cb1" data-startFrom><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">import</span> <span class="dt">System.Random.MWC</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb1-5" title="5">    gen <span class="ot">&lt;-</span> initialize <span class="fu">$</span> V.fromList [year, month, day]</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="fu">...</span></a></code></pre></div>
<p>to something that has a much higher quality in terms of randomness.</p>
<h1 id="enter-the-sha-1-hash-function">Enter the SHA-1 Hash Function</h1>
<p>Ah, the venerable <a href="http://en.wikipedia.org/wiki/Sha1">SHA-1</a> function. It’s a real gem because you can use it to generate an extremely high-quality 160-bit (20-byte) random number from a given set of bytes; and, even if you change the input by a single byte, it will generate a <strong>totally different</strong> number. <em>You can think of the SHA-1 hash function as a function that takes a seed and generates a random number — where the seed can be 0 bytes or 123 bytes or whatever size.</em> Thankfully, there is a SHA-1 <a href="http://hackage.haskell.org/package/SHA">package</a> available, so I don’t need to write my own correct implementation of SHA-1 (not to mention that only a handful of programmers can even write such code).</p>
<h1 id="the-solution">The Solution</h1>
<p>To solve my problem, I just take the current date, then feed it to the SHA-1 function to get <code>sha1Hash</code>; I then then repeatedly call SHA-1 against <code>sha1Hash</code> recursively. Meanwhile, each time I get a SHA-1 hash of 20 bytes, I append it to an empty string of bytes, <code>acc</code>. When <code>acc</code> is large enough to be split up into 256 <code>Word32</code> elements, I feed it to <code>initialize</code>. The result is that I get much better seed-vs-similar-seed randomness with MWC.</p>
<p>Here is the code:</p>
<div class="code-and-raw lineCntMax100">
<div class="raw-link sourceCode">
<table class="sourceCode numberLines noPaddingBottom"><tbody><tr class="sourceCode"><td class="lineNumbers"><pre>&nbsp;■</pre></td><td class="sourceCode"><pre><code><a class="raw" href="../code/rng/mwc-seed.hs" mimetype="text/plain">mwc-seed.hs</a></code></pre></td></tr></tbody></table>
</div>
<div class="sourceCode" id="cb2" data-input="code/rng/mwc-seed.hs"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Data.Bits</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">import</span> <span class="dt">Data.Digest.Pure.SHA</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">import</span> <span class="dt">Data.List</span> (foldl')</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">import</span> <span class="dt">Data.Word</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="kw">import</span> <span class="dt">System.Random.MWC</span></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">--  ...</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">--  gen &lt;- initialize' $ year' + month' + day'</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">--  ...</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co">-- | Given a Word32 'num' generate a growing ByteString 'x' by repeatedly</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">-- generating a SHA1 digest, as a ByteString 'y', and appending it back to</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="co">-- 'x'. When 'x' is sufficiently large (at least 256 * 4 elements, as each</span></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co">-- element is Word8 and we need 4 of these to get 1 Word32, and ultimately we</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="co">-- need 256 Word32s), convert it back down to [Word32] and call</span></a>
<a class="sourceLine" id="cb2-18" title="18"><span class="co">-- System.Random.MWC's 'initialize' function on it.</span></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="ot">initialize' ::</span> <span class="dt">PrimMonad</span> m <span class="ot">=&gt;</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> m (<span class="dt">Gen</span> (<span class="dt">PrimState</span> m))</a>
<a class="sourceLine" id="cb2-20" title="20">initialize' num <span class="fu">=</span> initialize <span class="fu">.</span> V.fromList <span class="fu">.</span> loop B.empty <span class="fu">.</span> B.pack <span class="fu">$</span> octetsLE num</a>
<a class="sourceLine" id="cb2-21" title="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-22" title="22"><span class="ot">  loop ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">Word32</span>]</a>
<a class="sourceLine" id="cb2-23" title="23">  loop acc bs</a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="fu">|</span> B.length acc <span class="fu">&gt;=</span> (<span class="dv">256</span> <span class="fu">*</span> <span class="dv">4</span>) <span class="fu">=</span> <span class="fu">take</span> <span class="dv">256</span> <span class="fu">$</span> toW32s acc</a>
<a class="sourceLine" id="cb2-25" title="25">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> loop (B.append acc <span class="fu">$</span> sha1Bytes bs) (sha1Bytes bs)</a>
<a class="sourceLine" id="cb2-26" title="26"><span class="ot">  sha1Bytes ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span></a>
<a class="sourceLine" id="cb2-27" title="27">  sha1Bytes <span class="fu">=</span> bytestringDigest <span class="fu">.</span> sha1</a>
<a class="sourceLine" id="cb2-28" title="28"><span class="ot">  toW32s ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">Word32</span>]</a>
<a class="sourceLine" id="cb2-29" title="29">  toW32s <span class="fu">=</span> <span class="fu">map</span> fromOctetsLE <span class="fu">.</span> chop <span class="dv">4</span> <span class="fu">.</span> B.unpack</a>
<a class="sourceLine" id="cb2-30" title="30"><span class="ot">  chop ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-31" title="31">  chop _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-32" title="32">  chop n xs <span class="fu">=</span> <span class="fu">take</span> n xs <span class="fu">:</span> chop n (<span class="fu">drop</span> n xs)</a>
<a class="sourceLine" id="cb2-33" title="33"></a>
<a class="sourceLine" id="cb2-34" title="34"><span class="co">-- For little-endian conversion.</span></a>
<a class="sourceLine" id="cb2-35" title="35"><span class="ot">octetsLE ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>]</a>
<a class="sourceLine" id="cb2-36" title="36">octetsLE w <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-37" title="37">  [ <span class="fu">fromIntegral</span> w</a>
<a class="sourceLine" id="cb2-38" title="38">  , <span class="fu">fromIntegral</span> (w <span class="ot">`shiftR`</span> <span class="dv">8</span>)</a>
<a class="sourceLine" id="cb2-39" title="39">  , <span class="fu">fromIntegral</span> (w <span class="ot">`shiftR`</span> <span class="dv">16</span>)</a>
<a class="sourceLine" id="cb2-40" title="40">  , <span class="fu">fromIntegral</span> (w <span class="ot">`shiftR`</span> <span class="dv">24</span>)</a>
<a class="sourceLine" id="cb2-41" title="41">  ]</a>
<a class="sourceLine" id="cb2-42" title="42"></a>
<a class="sourceLine" id="cb2-43" title="43"><span class="co">-- For big-endian conversion.</span></a>
<a class="sourceLine" id="cb2-44" title="44"><span class="ot">octetsBE ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>]</a>
<a class="sourceLine" id="cb2-45" title="45">octetsBE <span class="fu">=</span> <span class="fu">reverse</span> <span class="fu">.</span> octetsLE</a>
<a class="sourceLine" id="cb2-46" title="46"></a>
<a class="sourceLine" id="cb2-47" title="47"><span class="ot">fromOctetsBE ::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">Word32</span></a>
<a class="sourceLine" id="cb2-48" title="48">fromOctetsBE <span class="fu">=</span> foldl' accum <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-49" title="49">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-50" title="50">  accum a o <span class="fu">=</span> (a <span class="ot">`shiftL`</span> <span class="dv">8</span>) <span class="fu">.|.</span> <span class="fu">fromIntegral</span> o</a>
<a class="sourceLine" id="cb2-51" title="51"></a>
<a class="sourceLine" id="cb2-52" title="52"><span class="ot">fromOctetsLE ::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">Word32</span></a>
<a class="sourceLine" id="cb2-53" title="53">fromOctetsLE <span class="fu">=</span> fromOctetsBE <span class="fu">.</span> <span class="fu">reverse</span></a></code></pre></div>
</div>
<p>The neat <code>chop</code> function is by <a href="http://stackoverflow.com/a/5188922/437583">Dan Burton</a>. The octet conversion functions between <code>Word8</code> and <code>Word32</code> types are from <a href="http://www.haskell.org/pipermail/beginners/2010-October/005571.html">this message</a>.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The distinction between big-endianness and little-endianness does not matter at all for purposes of my solution, but I still distinguished them anyway as a reference.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

		</div>
		<div id="footer">
			<p id="fleuron">❦</p>
			<p>Copyright (C) 2013-2021 Linus Arver. All rights reserved.</p>
			<a href="https://github.com/listx/listx_blog">Site</a>
			<a href="https://github.com/listx/listx.github.io">generated</a>
			with
			<a href="https://jaspervdj.be/hakyll">Hakyll</a>
			and
			<a href="http://sebastiaanvisser.github.com/clay">Clay</a>.
			<br>
			<a href="../atom.xml">Atom feed</a>
		</div>
	</body>
</html>
