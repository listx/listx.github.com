<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Linus's Blog - Haskell: System.Random.MWC: High Quality Fixed Seeds</title>
		<link rel="stylesheet" href="../css/base.css">
		<link rel="stylesheet" href="../css/syntax.css">
		<link href="http://fonts.googleapis.com/css?family=Merriweather:400,400italic,700italic,700" rel="stylesheet" type="text/css">
		<link rel="shortcut icon" type="image/png" href="../favicon.png">
		
	</head>
	<body>
		<div id="header">
			<a href="../">Home</a>
			&bull;
			<a href="../about.html">About</a>
			&bull;
			<a href="../art.html">Art</a>
			&bull;
			<a href="../code.html">Code</a>
			&bull;
			<a href="../archive.html">Archive</a>
		</div>

		<div id="content">
			<h1 class="center">Haskell: System.Random.MWC: High Quality Fixed Seeds</h1>

			<div class="info center">
	<code class="date">2013-04-23</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2013-04-23-mwc-high-quality-fixed-seeds.md" title="History">*</a>
	<br>
	<a href="../tag/haskell.html">haskell</a>, <a href="../tag/rng.html">rng</a>
</div>

<p>I use Bryan O’Sullivan’s <a href="http://hackage.haskell.org/package/mwc-random"><code>mwc-random</code></a> package for my PRNG (pseudorandom number generator) needs in my Haskell projects. <code>mwc-random</code> is very fast and generates high quality random numbers. It has a pretty simple API, and gives you several options of initializing the RNG state. One way is to use the <code>initialize</code> function, which simply takes a list of <code>Word32</code> elements and takes the first 256 of them to seed the generator (if less than 256, it fills the rest from a hard-coded list). I’ve discovered that using a simple list of 3 small numbers representing the year, month, and day (e.g., <code>[2013, 4, 11]</code>) is not very good as an argument to <code>initialize</code>, as the generator behaves somewhat similarly to, say, one with slightly different date (e.g., <code>[2013, 4, 12]</code>).</p>
<h3 id="the-problem">The Problem</h3>
<p>I have a program that needs to be seeded on a day-by-day basis, and it must use the current date (year, month, and day only) as the seed; however, I need the seed to be random enough to make the MWC state spit out substantially different random numbers on different, yet similar days. In essence, I need to change</p>
<table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import </span><span class="dt">System.Random.MWC</span>

	<span class="fu">...</span>
	gen <span class="ot">&lt;-</span> initialize <span class="fu">$</span> V.fromList [year, month, day]
	<span class="fu">...</span></code></pre></td></tr></table>
<p>to something that has a much higher quality in terms of randomness.</p>
<h2 id="enter-the-sha-1-hash-function">Enter the SHA-1 Hash Function</h2>
<p>Ah, the venerable <a href="http://en.wikipedia.org/wiki/Sha1">SHA-1</a> function. It’s a real gem because you can use it to generate an extremely high-quality 160-bit (20-byte) random number from a given set of bytes; and, even if you change the input by a single byte, it will generate a <strong>totally different</strong> number. <em>You can think of the SHA-1 hash function as a function that takes a seed and generates a random number — where the seed can be 0 bytes or 123 bytes or whatever size.</em> Thankfully, there is a SHA-1 <a href="http://hackage.haskell.org/package/SHA">package</a> available, so I don’t need to write my own correct implementation of SHA-1 (not to mention that only a handful of programmers can even write such code).</p>
<h3 id="the-solution">The Solution</h3>
<p>To solve my problem, I just take the current date, then feed it to the SHA-1 function to get <code>sha1Hash</code>; I then then repeatedly call SHA-1 against <code>sha1Hash</code> recursively. Meanwhile, each time I get a SHA-1 hash of 20 bytes, I append it to an empty string of bytes, <code>acc</code>. When <code>acc</code> is large enough to be split up into 256 <code>Word32</code> elements, I feed it to <code>initialize</code>. The result is that I get much better seed-vs-similar-seed randomness with MWC.</p>
<p>Here is the code:</p>
<div class="code-and-raw">
<table class="sourceCode numberLines haskell" input="code/rng/mwc-seed.hs"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Bits</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import </span><span class="dt">Data.Digest.Pure.SHA</span>
<span class="kw">import </span><span class="dt">Data.List</span> (foldl')
<span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">System.Random.MWC</span>

<span class="co">--	...</span>
<span class="co">--	gen &lt;- initialize' $ year' + month' + day'</span>
<span class="co">--	...</span>

<span class="co">-- | Given a Word32 'num' generate a growing ByteString 'x' by repeatedly</span>
<span class="co">-- generating a SHA1 digest, as a ByteString 'y', and appending it back to</span>
<span class="co">-- 'x'. When 'x' is sufficiently large (at least 256 * 4 elements, as each</span>
<span class="co">-- element is Word8 and we need 4 of these to get 1 Word32, and ultimately we</span>
<span class="co">-- need 256 Word32s), convert it back down to [Word32] and call</span>
<span class="co">-- System.Random.MWC's 'initialize' function on it.</span>
<span class="ot">initialize' ::</span> <span class="dt">PrimMonad</span> m <span class="ot">=&gt;</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> m (<span class="dt">Gen</span> (<span class="dt">PrimState</span> m))
initialize' num <span class="fu">=</span> initialize <span class="fu">.</span> V.fromList <span class="fu">.</span> loop B.empty <span class="fu">.</span> B.pack <span class="fu">$</span> octetsLE num
	<span class="kw">where</span>
<span class="ot">	loop ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">Word32</span>]
	loop acc bs
		<span class="fu">|</span> B.length acc <span class="fu">&gt;=</span> (<span class="dv">256</span> <span class="fu">*</span> <span class="dv">4</span>) <span class="fu">=</span> take <span class="dv">256</span> <span class="fu">$</span> toW32s acc
		<span class="fu">|</span> otherwise <span class="fu">=</span> loop (B.append acc <span class="fu">$</span> sha1Bytes bs) (sha1Bytes bs)
<span class="ot">	sha1Bytes ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span>
	sha1Bytes <span class="fu">=</span> bytestringDigest <span class="fu">.</span> sha1
<span class="ot">	toW32s ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">Word32</span>]
	toW32s <span class="fu">=</span> map fromOctetsLE <span class="fu">.</span> chop <span class="dv">4</span> <span class="fu">.</span> B.unpack
<span class="ot">	chop ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
	chop _ [] <span class="fu">=</span> []
	chop n xs <span class="fu">=</span> take n xs <span class="fu">:</span> chop n (drop n xs)

<span class="co">-- For little-endian conversion.</span>
<span class="ot">octetsLE ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>]
octetsLE w <span class="fu">=</span>
	[ fromIntegral w
	, fromIntegral (w <span class="ot">`shiftR`</span> <span class="dv">8</span>)
	, fromIntegral (w <span class="ot">`shiftR`</span> <span class="dv">16</span>)
	, fromIntegral (w <span class="ot">`shiftR`</span> <span class="dv">24</span>)
	]

<span class="co">-- For big-endian conversion.</span>
<span class="ot">octetsBE ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>]
octetsBE <span class="fu">=</span> reverse <span class="fu">.</span> octetsLE

<span class="ot">fromOctetsBE ::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">Word32</span>
fromOctetsBE <span class="fu">=</span> foldl' accum <span class="dv">0</span>
	<span class="kw">where</span>
	accum a o <span class="fu">=</span> (a <span class="ot">`shiftL`</span> <span class="dv">8</span>) <span class="fu">.|.</span> fromIntegral o

<span class="ot">fromOctetsLE ::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">Word32</span>
fromOctetsLE <span class="fu">=</span> fromOctetsBE <span class="fu">.</span> reverse</code></pre></td></tr></table>
<div class="raw-link">
<a class="raw" href="../code/rng/mwc-seed.hs" mimetype="text/plain"> mwc-seed.hs </a>
</div>
</div>
<p>The neat <code>chop</code> function is by <a href="http://stackoverflow.com/a/5188922/437583">Dan Burton</a>. The octet conversion functions between <code>Word8</code> and <code>Word32</code> types are from <a href="http://www.haskell.org/pipermail/beginners/2010-October/005571.html">this message</a>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The distinction between big-endianness and little-endianness does not matter at all for purposes of my solution, but I still distinguished them anyway as a reference.<a href="#fnref1">↩</a></p></li>
</ol>
</div>

		</div>
		<div id="footer">
			<a href="https://github.com/listx/listx_blog">Site</a>
			<a href="https://github.com/listx/listx.github.io">generated</a>
			with
			<a href="http://jaspervdj.be/hakyll">Hakyll</a>
			and
			<a href="http://sebastiaanvisser.github.com/clay">Clay</a>.
			<br>
			<a href="../atom.xml">Atom feed</a>
		</div>
	</body>
</html>
