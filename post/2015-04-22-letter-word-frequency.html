<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Linus's Blog - Programming Puzzles: Letter and Word Frequency</title>
		<link rel="stylesheet" href="../css/base.css">
		<link rel="stylesheet" href="../css/syntax.css">
		<link href="https://fonts.googleapis.com/css?family=Merriweather:300,300italic,700italic,700" rel="stylesheet" type="text/css">
		<link rel="shortcut icon" type="image/png" href="../favicon.png">
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="../misc.js"></script>
		<!-- https://github.com/mreid/markreidname-hakyll/blob/master/_templates/mathjax.html -->
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		extensions: ["tex2jax.js"],
		jax: ["input/TeX", "output/HTML-CSS"],
		tex2jax: {
			inlineMath: [ ["\\(","\\)"] ],
			displayMath: [ ["\\[","\\]"] ],
			processEscapes: true
		},
		TeX: { equationNumbers: { autoNumber: "AMS" } },
		"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>

	</head>
	<body>
		<div id="header">
			<a href="../">Blog</a>
			&bull;
			<a href="../about.html">About</a>
			&bull;
			<a href="../code.html">Code</a>
			&bull;
			<a href="../papers.html">Papers</a>
		</div>

		<div id="content">
			<h1 class="center" id="page-title">Programming Puzzles: Letter and Word Frequency</h1>

			<div class="info center">
	<code class="date">2015-04-22</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-04-22-letter-word-frequency.md" title="History">*</a>
	<br>
	<a href="../tag/programming.html">programming</a>, <a href="../tag/haskell.html">haskell</a>, <a href="../tag/ruby.html">ruby</a>
</div>

<h2 id="motivation">Motivation</h2>
<p>I recently purchased an ErgoDox keyboard<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, and I’ve been thinking about creating my own keyboard layout in the spirit of the Dvorak Simplified Keyboard layout (DSK). One of the guiding principles of DSK was putting an emphasis on reducing finger travel by identifying the most commonly occurring letters of the English language, and placing them on the home row of the keyboard. Now, the Dvorak layout was patented in 1936 according to Wikipedia, with subsequent adjustments culminating in the present form of DSK.</p>
<p>I want to find out for myself what letters are the most common. Sure, I could blindly trust an online source like Wikipedia, but it just feels like an easy problem to solve. Also, I am not sure if Dvorak considered <em>word</em> frequency as well as <em>letter</em> frequency. Ideally, one should use the data of both word and letter frequency to determine what is the most commonly typed “letter” on a US ASCII keyboard for English writers.</p>
<h2 id="the-problems">The Problems</h2>
<h3 id="letter-frequency">Letter Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each letter occurs in the file. You must treat <code>A</code> as the same letter as <code>a</code>. You may limit yourself to the plain US ASCII 26-letter alphabet, discarding all letters with diacritics. Sort the letters by their frequence; for each letter, display the letter itself, its relative frequency percentage to the file as a whole, and the number of times this letter appears (raw count). E.g., the letter <code>a</code> counted by this program might look like this: <code>a = 2.00% (200 occurrences)</code>.</p>
<h3 id="word-frequency">Word Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each <em>word</em> occurs in the file. The precise definition of a “word” is up to you, but you must exclude arabic numerals and also standalone punctuation characters (e.g., “* is not a word”). Display the 100 most common words in similar fashion to the Letter Frequency problem.</p>
<p>Both the letter and word frequency problems will use the Project Gutenberg plaintext file of <a href="http://www.gutenberg.org/cache/epub/2701/pg2701.txt"><em>Moby Dick</em></a>.</p>
<p>Now, before you go on to read my solutions, I encourage you to write a solution on your own using your favorite programming language.</p>
<h2 id="ruby-version">Ruby Version</h2>
<div class="code-and-raw lineCntMax100">
<div class="raw-link sourceCode">
<table class="sourceCode numberLines noPaddingBottom"><tbody><tr class="sourceCode"><td class="lineNumbers"><pre>&nbsp;■</pre></td><td class="sourceCode"><pre><code><a class="raw" href="../code/toy/text-freq/text_freq.rb" mimetype="text/plain">text_freq.rb</a></code></pre></td></tr></tbody></table>
</div>
<div class="sourceCode" id="cb1" data-input="code/toy/text-freq/text_freq.rb"><pre class="sourceCode numberSource numberLines ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> <span class="dt">TextFreq</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="co"># Given a string, count every occurrence of letters a-z (case insensitively).</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_l(src)</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="co"># Construct the array to hold the running totals (occurrences) of each</span></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="co"># letter. There are 26 letters in the alphabet, so we can just have an array</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="co"># of 26 integers.</span></a>
<a class="sourceLine" id="cb1-7" title="7">    occs = <span class="dt">Array</span>.new(<span class="dv">26</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="co"># Count occurrences of each letter.</span></a>
<a class="sourceLine" id="cb1-10" title="10">    src.each_char <span class="kw">do</span> |c|</a>
<a class="sourceLine" id="cb1-11" title="11">      <span class="kw">if</span> !char_to_idx(c.downcase).nil?</a>
<a class="sourceLine" id="cb1-12" title="12">        occs[char_to_idx(c.downcase)] += <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-13" title="13">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16">    occs</a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19">  <span class="co"># Simply check if the given character belongs to the range of lowercase ASCII</span></a>
<a class="sourceLine" id="cb1-20" title="20">  <span class="co"># characters that make up the alphabet. &quot;a&quot; is 97, and &quot;z&quot; is 122; the numbers</span></a>
<a class="sourceLine" id="cb1-21" title="21">  <span class="co"># for bounds-checking &quot;c&quot; come from these two (offset by 1 to account for the</span></a>
<a class="sourceLine" id="cb1-22" title="22">  <span class="co"># exclusive comparison).</span></a>
<a class="sourceLine" id="cb1-23" title="23">  <span class="kw">def</span> <span class="dt">TextFreq</span>.char_to_idx(c)</a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="dv">96</span> &lt; c.ord &amp;&amp; c.ord &lt; <span class="dv">123</span> ? c.ord - <span class="dv">97</span> : <span class="dv">nil</span></a>
<a class="sourceLine" id="cb1-25" title="25">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27">  <span class="co"># Given a string, count every occurrence of a particular word. We define a</span></a>
<a class="sourceLine" id="cb1-28" title="28">  <span class="co"># &quot;word&quot; as a sequence of charactes that</span></a>
<a class="sourceLine" id="cb1-29" title="29">  <span class="co">#   - does not have any punctuation characters at the beginning or end, and</span></a>
<a class="sourceLine" id="cb1-30" title="30">  <span class="co">#   - does not have any numbers in it</span></a>
<a class="sourceLine" id="cb1-31" title="31">  <span class="co"># . We take into account that text files from Project Gutenberg use a double</span></a>
<a class="sourceLine" id="cb1-32" title="32">  <span class="co"># dash for an em dash to separate two words.</span></a>
<a class="sourceLine" id="cb1-33" title="33">  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_w(src)</a>
<a class="sourceLine" id="cb1-34" title="34">    occs = {}</a>
<a class="sourceLine" id="cb1-35" title="35">    words = src.split(<span class="ot">/\W*\s\W*/</span>).map <span class="kw">do</span> |w|</a>
<a class="sourceLine" id="cb1-36" title="36">        w.empty? ? <span class="dv">nil</span> : w.downcase</a>
<a class="sourceLine" id="cb1-37" title="37">      <span class="kw">end</span>.compact</a>
<a class="sourceLine" id="cb1-38" title="38">    words.each <span class="kw">do</span> |w|</a>
<a class="sourceLine" id="cb1-39" title="39">      <span class="co"># Guard against cases like &quot;*&quot; for bullet points and such.</span></a>
<a class="sourceLine" id="cb1-40" title="40">      <span class="kw">if</span> w =~ <span class="ot">/\w/</span></a>
<a class="sourceLine" id="cb1-41" title="41">        <span class="kw">if</span> w =~ <span class="ot">/--/</span></a>
<a class="sourceLine" id="cb1-42" title="42">          w.split(<span class="st">&quot;--&quot;</span>).each <span class="kw">do</span> |y|</a>
<a class="sourceLine" id="cb1-43" title="43">            count_word(occs, lstrip_punc(y))</a>
<a class="sourceLine" id="cb1-44" title="44">          <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-45" title="45">        <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-46" title="46">          count_word(occs, lstrip_punc(w))</a>
<a class="sourceLine" id="cb1-47" title="47">        <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-48" title="48">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-49" title="49">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-50" title="50"></a>
<a class="sourceLine" id="cb1-51" title="51">    occs</a>
<a class="sourceLine" id="cb1-52" title="52">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-53" title="53"></a>
<a class="sourceLine" id="cb1-54" title="54">  <span class="co"># Add 1 to the hash for an existing key (word); otherwise, store a new</span></a>
<a class="sourceLine" id="cb1-55" title="55">  <span class="co"># instance of that word.</span></a>
<a class="sourceLine" id="cb1-56" title="56">  <span class="kw">def</span> <span class="dt">TextFreq</span>.count_word(hash, w)</a>
<a class="sourceLine" id="cb1-57" title="57">    hash.key?(w) ? hash[w] += <span class="dv">1</span> : hash.store(w, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-58" title="58">    hash</a>
<a class="sourceLine" id="cb1-59" title="59">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-60" title="60"></a>
<a class="sourceLine" id="cb1-61" title="61">  <span class="co"># Remove leading punctuation.</span></a>
<a class="sourceLine" id="cb1-62" title="62">  <span class="kw">def</span> <span class="dt">TextFreq</span>.lstrip_punc(w)</a>
<a class="sourceLine" id="cb1-63" title="63">    w.match(<span class="ot">/\w.*/</span>)[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb1-64" title="64">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-65" title="65"></a>
<a class="sourceLine" id="cb1-66" title="66">  <span class="co"># Display the frequencies of letters and or words. For letters, we are only</span></a>
<a class="sourceLine" id="cb1-67" title="67">  <span class="co"># concerned about 26 different values, so we print all of them out. However</span></a>
<a class="sourceLine" id="cb1-68" title="68">  <span class="co"># for words, depending on the corpus there might be thousands, or even</span></a>
<a class="sourceLine" id="cb1-69" title="69">  <span class="co"># millions, of different words; thus, we only display the top 100 most common</span></a>
<a class="sourceLine" id="cb1-70" title="70">  <span class="co"># words.</span></a>
<a class="sourceLine" id="cb1-71" title="71">  <span class="kw">def</span> <span class="dt">TextFreq</span>.disp_freq(occs)</a>
<a class="sourceLine" id="cb1-72" title="72">    <span class="kw">if</span> occs.is_a?(<span class="dt">Array</span>)</a>
<a class="sourceLine" id="cb1-73" title="73">      sum = occs.inject(<span class="dv">0</span>, :+)</a>
<a class="sourceLine" id="cb1-74" title="74">      occs.zip((<span class="st">&quot;a&quot;</span>..<span class="st">&quot;z&quot;</span>).to_a).sort.reverse.each <span class="kw">do</span> |cnt, c|</a>
<a class="sourceLine" id="cb1-75" title="75">        puts <span class="st">&quot;</span><span class="ot">#{</span>c<span class="ot">}</span><span class="st"> = &quot;</span>\</a>
<a class="sourceLine" id="cb1-76" title="76">          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\</a>
<a class="sourceLine" id="cb1-77" title="77">          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span></a>
<a class="sourceLine" id="cb1-78" title="78">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-79" title="79">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-80" title="80">      sum = occs.values.inject(<span class="dv">0</span>, :+)</a>
<a class="sourceLine" id="cb1-81" title="81">      occs.sort_by {|w, cnt| cnt}.reverse.take(<span class="dv">100</span>).each <span class="kw">do</span> |w, cnt|</a>
<a class="sourceLine" id="cb1-82" title="82">        puts <span class="st">&quot;</span><span class="ot">#{</span>w<span class="ot">}</span><span class="st"> = &quot;</span>\</a>
<a class="sourceLine" id="cb1-83" title="83">          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\</a>
<a class="sourceLine" id="cb1-84" title="84">          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span></a>
<a class="sourceLine" id="cb1-85" title="85">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-86" title="86">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-87" title="87">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="kw">end</span></a></code></pre></div>
</div>
<div class="code-and-raw lineCntMax100">
<div class="raw-link sourceCode">
<table class="sourceCode numberLines noPaddingBottom"><tbody><tr class="sourceCode"><td class="lineNumbers"><pre>&nbsp;■</pre></td><td class="sourceCode"><pre><code><a class="raw" href="../code/toy/text-freq/analyze.rb" mimetype="text/plain">analyze.rb</a></code></pre></td></tr></tbody></table>
</div>
<div class="sourceCode" id="cb2" data-input="code/toy/text-freq/analyze.rb"><pre class="sourceCode numberSource numberLines ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">#!/usr/bin/env ruby</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">require_relative <span class="st">'./text_freq'</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">fname = <span class="dt">ARGV</span>[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb2-6" title="6">file = <span class="dt">File</span>.open(fname, <span class="st">'r:utf-8'</span>)</a>
<a class="sourceLine" id="cb2-7" title="7">corpus = file.read</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9">occs_l = <span class="dt">TextFreq</span>.freq_l(corpus)</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="dt">TextFreq</span>.disp_freq(occs_l)</a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12">puts <span class="st">&quot;-&quot;</span> * <span class="dv">80</span></a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14">occs_w = <span class="dt">TextFreq</span>.freq_w(corpus)</a>
<a class="sourceLine" id="cb2-15" title="15"><span class="dt">TextFreq</span>.disp_freq(occs_w)</a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17">file.close</a></code></pre></div>
</div>
<p>And here is the output (<code>pg2701.txt</code> is <em>Moby Dick</em>):</p>
<pre><code>$ ./analyze.rb ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.74% (14616 occurrences)
of = 3.10% (6708 occurrences)
and = 2.99% (6488 occurrences)
a = 2.20% (4760 occurrences)
to = 2.16% (4677 occurrences)
in = 1.95% (4223 occurrences)
that = 1.38% (2999 occurrences)
his = 1.17% (2530 occurrences)
it = 1.12% (2419 occurrences)
i = 0.92% (1988 occurrences)
but = 0.84% (1823 occurrences)
he = 0.82% (1777 occurrences)
with = 0.82% (1770 occurrences)
as = 0.81% (1751 occurrences)
is = 0.81% (1747 occurrences)
for = 0.76% (1645 occurrences)
was = 0.76% (1645 occurrences)
all = 0.70% (1523 occurrences)
this = 0.66% (1440 occurrences)
at = 0.62% (1334 occurrences)
by = 0.56% (1223 occurrences)
not = 0.54% (1169 occurrences)
from = 0.51% (1105 occurrences)
on = 0.49% (1069 occurrences)
him = 0.49% (1062 occurrences)
so = 0.49% (1061 occurrences)
be = 0.49% (1060 occurrences)
whale = 0.45% (972 occurrences)
you = 0.44% (944 occurrences)
one = 0.42% (906 occurrences)
or = 0.37% (797 occurrences)
there = 0.37% (792 occurrences)
now = 0.36% (779 occurrences)
had = 0.36% (779 occurrences)
have = 0.36% (772 occurrences)
were = 0.32% (683 occurrences)
they = 0.31% (664 occurrences)
which = 0.30% (655 occurrences)
then = 0.29% (628 occurrences)
me = 0.29% (621 occurrences)
their = 0.29% (620 occurrences)
are = 0.29% (619 occurrences)
some = 0.29% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.28% (600 occurrences)
no = 0.27% (594 occurrences)
my = 0.27% (589 occurrences)
like = 0.27% (581 occurrences)
upon = 0.26% (567 occurrences)
what = 0.26% (566 occurrences)
out = 0.24% (528 occurrences)
into = 0.24% (523 occurrences)
up = 0.24% (516 occurrences)
more = 0.23% (506 occurrences)
if = 0.23% (500 occurrences)
them = 0.22% (471 occurrences)
we = 0.21% (455 occurrences)
man = 0.21% (445 occurrences)
old = 0.20% (444 occurrences)
ahab = 0.20% (432 occurrences)
ye = 0.20% (428 occurrences)
would = 0.20% (428 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
these = 0.19% (405 occurrences)
over = 0.19% (403 occurrences)
will = 0.18% (396 occurrences)
ship = 0.18% (391 occurrences)
though = 0.18% (383 occurrences)
sea = 0.18% (382 occurrences)
its = 0.18% (382 occurrences)
only = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
down = 0.17% (367 occurrences)
any = 0.17% (363 occurrences)
who = 0.16% (345 occurrences)
yet = 0.16% (344 occurrences)
her = 0.15% (329 occurrences)
time = 0.15% (326 occurrences)
very = 0.15% (323 occurrences)
do = 0.15% (321 occurrences)
long = 0.15% (319 occurrences)
about = 0.15% (318 occurrences)
than = 0.14% (311 occurrences)
still = 0.14% (311 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (303 occurrences)
said = 0.14% (301 occurrences)
captain = 0.14% (300 occurrences)
before = 0.14% (300 occurrences)
here = 0.14% (299 occurrences)
has = 0.14% (294 occurrences)
must = 0.13% (292 occurrences)
two = 0.13% (288 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
last = 0.13% (276 occurrences)
head = 0.13% (275 occurrences)
see = 0.12% (268 occurrences)
thou = 0.12% (267 occurrences)</code></pre>
<p>. The file of course contains remarks and legalese from Project Gutenberg, so if you want more accuracy you would have to redact those parts before running this script.</p>
<h3 id="letter-frequency-1">Letter Frequency</h3>
<p>The <code>freq_l</code> method views letters in the limited US ASCII range and uses crude, C-like letter-to-integer equivalence via <code>char_to_idx</code>. We use a simple array of 26 integers, each one corresponding to a letter. But thanks to its stupidity, <code>freq_l</code> runs quite fast — chugging through Moby Dick in a few seconds on my Core i7-4770K 4GHz machine.</p>
<h3 id="word-frequency-1">Word Frequency</h3>
<p>The <code>freq_w</code> method relies almost entirely on a single regex, <code>/\W*\s\W*/</code>, to split the input into words. These words are further processed; we perform a basic sanity check with the <code>/\w/</code> regex to make sure we are not dealing with just numbers or punctuation, and we also take into account the em dash <code>--</code>. We use a basic hash structure to store the words as keys, and their counts as values.</p>
<h2 id="haskell-version">Haskell Version</h2>
<div class="code-and-raw lineCntMax1000">
<div class="raw-link sourceCode">
<table class="sourceCode numberLines noPaddingBottom"><tbody><tr class="sourceCode"><td class="lineNumbers"><pre>&nbsp;&nbsp;■</pre></td><td class="sourceCode"><pre><code><a class="raw" href="../code/toy/text-freq/TextFreq.hs" mimetype="text/plain">TextFreq.hs</a></code></pre></td></tr></tbody></table>
</div>
<div class="sourceCode" id="cb4" data-input="code/toy/text-freq/TextFreq.hs"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">module</span> <span class="dt">TextFreq</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">import</span> <span class="dt">Data.Ord</span> (comparing)</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">import</span> <span class="dt">Data.Word</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Printf</span> <span class="kw">as</span> <span class="dt">TP</span></a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="kw">type</span> <span class="dt">LHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Char</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="kw">type</span> <span class="dt">WProto</span> <span class="fu">=</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="kw">type</span> <span class="dt">WHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">WProto</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="kw">data</span> <span class="dt">WFSM</span></a>
<a class="sourceLine" id="cb4-16" title="16">  <span class="fu">=</span> <span class="dt">WordIn</span></a>
<a class="sourceLine" id="cb4-17" title="17">  <span class="fu">|</span> <span class="dt">WordOutMaybe</span></a>
<a class="sourceLine" id="cb4-18" title="18">  <span class="fu">|</span> <span class="dt">WordOut</span></a>
<a class="sourceLine" id="cb4-19" title="19">  <span class="kw">deriving</span> (<span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb4-20" title="20"><span class="kw">data</span> <span class="dt">WBuild</span> <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WFSM</span> <span class="dt">WProto</span> <span class="dt">WHash</span></a>
<a class="sourceLine" id="cb4-21" title="21"></a>
<a class="sourceLine" id="cb4-22" title="22"><span class="ot">freqL ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">LHash</span></a>
<a class="sourceLine" id="cb4-23" title="23">freqL <span class="fu">=</span> T.foldl step occs</a>
<a class="sourceLine" id="cb4-24" title="24">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-25" title="25">  occs <span class="fu">=</span> M.empty</a>
<a class="sourceLine" id="cb4-26" title="26">  step lhash c</a>
<a class="sourceLine" id="cb4-27" title="27">    <span class="co">-- | isAlpha c = M.insertWith (+) (toLower c) 1 lhash -- this picks up non-ASCII 'word' letters, even korean/japanese!</span></a>
<a class="sourceLine" id="cb4-28" title="28">    <span class="fu">|</span> <span class="fu">elem</span> c ([<span class="ch">'a'</span><span class="fu">..</span><span class="ch">'z'</span>] <span class="fu">++</span> [<span class="ch">'A'</span><span class="fu">..</span><span class="ch">'Z'</span>]) <span class="fu">=</span> M.insertWith (<span class="fu">+</span>) (<span class="fu">toLower</span> c) <span class="dv">1</span> lhash</a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="fu">|</span> <span class="fu">elem</span> c (<span class="fu">concat</span> puncKeys) <span class="fu">=</span> <span class="kw">case</span> <span class="fu">lookup</span> c puncTuples <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-30" title="30">      <span class="dt">Just</span> pkey <span class="ot">-&gt;</span> M.insertWith (<span class="fu">+</span>) pkey <span class="dv">1</span> lhash</a>
<a class="sourceLine" id="cb4-31" title="31">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> lhash</a>
<a class="sourceLine" id="cb4-32" title="32">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> lhash</a>
<a class="sourceLine" id="cb4-33" title="33">  puncKeys <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-34" title="34">    [ <span class="st">&quot;`~&quot;</span></a>
<a class="sourceLine" id="cb4-35" title="35">    , <span class="st">&quot;-_&quot;</span></a>
<a class="sourceLine" id="cb4-36" title="36">    , <span class="st">&quot;=+&quot;</span></a>
<a class="sourceLine" id="cb4-37" title="37">    , <span class="st">&quot;[{&quot;</span></a>
<a class="sourceLine" id="cb4-38" title="38">    , <span class="st">&quot;}]&quot;</span></a>
<a class="sourceLine" id="cb4-39" title="39">    , <span class="st">&quot;\\|&quot;</span></a>
<a class="sourceLine" id="cb4-40" title="40">    , <span class="st">&quot;;:&quot;</span></a>
<a class="sourceLine" id="cb4-41" title="41">    , <span class="st">&quot;'\&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-42" title="42">    , <span class="st">&quot;,&lt;&quot;</span></a>
<a class="sourceLine" id="cb4-43" title="43">    , <span class="st">&quot;.&gt;&quot;</span></a>
<a class="sourceLine" id="cb4-44" title="44">    , <span class="st">&quot;/?&quot;</span></a>
<a class="sourceLine" id="cb4-45" title="45">    ]</a>
<a class="sourceLine" id="cb4-46" title="46">  puncTuples <span class="fu">=</span> <span class="fu">concatMap</span> (\keyPair <span class="ot">-&gt;</span> [(<span class="fu">head</span> keyPair, <span class="fu">head</span> keyPair), (<span class="fu">last</span> keyPair, <span class="fu">head</span> keyPair)]) puncKeys</a>
<a class="sourceLine" id="cb4-47" title="47"></a>
<a class="sourceLine" id="cb4-48" title="48"><span class="ot">freqW ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">WHash</span></a>
<a class="sourceLine" id="cb4-49" title="49">freqW <span class="fu">=</span> (\(<span class="dt">WBuild</span> _ _ whash) <span class="ot">-&gt;</span> whash) <span class="fu">.</span> T.foldl step occs</a>
<a class="sourceLine" id="cb4-50" title="50">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-51" title="51">  <span class="co">-- Use WordOut as the initial state for WFSM, because we're starting from</span></a>
<a class="sourceLine" id="cb4-52" title="52">  <span class="co">-- nothing!</span></a>
<a class="sourceLine" id="cb4-53" title="53"><span class="ot">  occs ::</span> <span class="dt">WBuild</span></a>
<a class="sourceLine" id="cb4-54" title="54">  occs <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty M.empty</a>
<a class="sourceLine" id="cb4-55" title="55">  step wb<span class="fu">@</span>(<span class="dt">WBuild</span> wfsm wproto whash) c</a>
<a class="sourceLine" id="cb4-56" title="56">    <span class="co">-- Letter.</span></a>
<a class="sourceLine" id="cb4-57" title="57">    <span class="fu">|</span> <span class="fu">isAlpha</span> c <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-58" title="58">      <span class="co">-- This is when we first encounter a letter.</span></a>
<a class="sourceLine" id="cb4-59" title="59">      <span class="dt">WordOut</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.singleton c') whash</a>
<a class="sourceLine" id="cb4-60" title="60">      _ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.snoc wproto c') whash</a>
<a class="sourceLine" id="cb4-61" title="61">    <span class="co">-- Apostrophe. We ignore all leading apostrophes and only store</span></a>
<a class="sourceLine" id="cb4-62" title="62">    <span class="co">-- apostrophes at the end of a word, such as &quot;goin'&quot;.</span></a>
<a class="sourceLine" id="cb4-63" title="63">    <span class="fu">|</span> c <span class="fu">==</span> <span class="ch">'\''</span> <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-64" title="64">      <span class="co">-- This is when we encounter an apostrophe either at the middle or</span></a>
<a class="sourceLine" id="cb4-65" title="65">      <span class="co">-- end of a word.</span></a>
<a class="sourceLine" id="cb4-66" title="66">      <span class="dt">WordIn</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOutMaybe</span> (T.snoc wproto c') whash</a>
<a class="sourceLine" id="cb4-67" title="67">      <span class="co">-- E.g., &quot;goin''&quot; (a contracted &quot;goin''&quot; ending with a nested inner</span></a>
<a class="sourceLine" id="cb4-68" title="68">      <span class="co">-- quote). We store it as &quot;goin'&quot;.</span></a>
<a class="sourceLine" id="cb4-69" title="69">      <span class="dt">WordOutMaybe</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty</a>
<a class="sourceLine" id="cb4-70" title="70">        <span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash</a>
<a class="sourceLine" id="cb4-71" title="71">      <span class="co">-- Already out of a word area, such as a space character. We do</span></a>
<a class="sourceLine" id="cb4-72" title="72">      <span class="co">-- nothing.</span></a>
<a class="sourceLine" id="cb4-73" title="73">      <span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb</a>
<a class="sourceLine" id="cb4-74" title="74">    <span class="co">-- If we're looking at neither a letter nor an apostrophe.</span></a>
<a class="sourceLine" id="cb4-75" title="75">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-76" title="76">      <span class="co">-- A series of nonsense chars; ignore.</span></a>
<a class="sourceLine" id="cb4-77" title="77">      <span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb</a>
<a class="sourceLine" id="cb4-78" title="78">      <span class="co">-- End of a word.</span></a>
<a class="sourceLine" id="cb4-79" title="79">      _ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty</a>
<a class="sourceLine" id="cb4-80" title="80">        <span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash</a>
<a class="sourceLine" id="cb4-81" title="81">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-82" title="82">    c' <span class="fu">=</span> <span class="fu">toLower</span> c</a>
<a class="sourceLine" id="cb4-83" title="83"></a>
<a class="sourceLine" id="cb4-84" title="84"><span class="ot">dispFreqL ::</span> <span class="dt">LHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-85" title="85">dispFreqL lhash <span class="fu">=</span> <span class="fu">mapM_</span> f <span class="fu">.</span> <span class="fu">reverse</span> <span class="fu">.</span> sortBy (comparing <span class="fu">snd</span>) <span class="fu">$</span> M.toList lhash</a>
<a class="sourceLine" id="cb4-86" title="86">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-87" title="87"><span class="ot">  total ::</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb4-88" title="88">  total <span class="fu">=</span> <span class="fu">sum</span> <span class="fu">$</span> M.elems lhash</a>
<a class="sourceLine" id="cb4-89" title="89"><span class="ot">  f ::</span> (<span class="dt">Char</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-90" title="90">  f (c, n) <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3</a>
<a class="sourceLine" id="cb4-91" title="91">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-92" title="92"><span class="ot">    perc ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb4-93" title="93">    perc</a>
<a class="sourceLine" id="cb4-94" title="94">      <span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-95" title="95">      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> (<span class="fu">fromIntegral</span> n) <span class="fu">/</span> (<span class="fu">fromIntegral</span> total) <span class="fu">*</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-96" title="96">    msg1 <span class="fu">=</span> [c] <span class="fu">++</span> <span class="st">&quot; = &quot;</span></a>
<a class="sourceLine" id="cb4-97" title="97">    msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc</a>
<a class="sourceLine" id="cb4-98" title="98">    msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> <span class="fu">show</span> n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span></a>
<a class="sourceLine" id="cb4-99" title="99"></a>
<a class="sourceLine" id="cb4-100" title="100"><span class="ot">dispFreqW ::</span> <span class="dt">WHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-101" title="101">dispFreqW whash <span class="fu">=</span> <span class="fu">mapM_</span> f <span class="fu">.</span> <span class="fu">take</span> <span class="dv">100</span> <span class="fu">.</span> <span class="fu">reverse</span> <span class="fu">.</span> sortBy (comparing <span class="fu">snd</span>) <span class="fu">$</span> M.toList whash</a>
<a class="sourceLine" id="cb4-102" title="102">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-103" title="103"><span class="ot">  total ::</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb4-104" title="104">  total <span class="fu">=</span> <span class="fu">sum</span> <span class="fu">$</span> M.elems whash</a>
<a class="sourceLine" id="cb4-105" title="105"><span class="ot">  f ::</span> (<span class="dt">WProto</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-106" title="106">  f (w, n) <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3</a>
<a class="sourceLine" id="cb4-107" title="107">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-108" title="108"><span class="ot">    perc ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb4-109" title="109">    perc</a>
<a class="sourceLine" id="cb4-110" title="110">      <span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-111" title="111">      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> (<span class="fu">fromIntegral</span> n) <span class="fu">/</span> (<span class="fu">fromIntegral</span> total) <span class="fu">*</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-112" title="112">    msg1 <span class="fu">=</span> T.unpack w <span class="fu">++</span> <span class="st">&quot; = &quot;</span></a>
<a class="sourceLine" id="cb4-113" title="113">    msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc</a>
<a class="sourceLine" id="cb4-114" title="114">    msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> <span class="fu">show</span> n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span></a></code></pre></div>
</div>
<div class="code-and-raw lineCntMax100">
<div class="raw-link sourceCode">
<table class="sourceCode numberLines noPaddingBottom"><tbody><tr class="sourceCode"><td class="lineNumbers"><pre>&nbsp;■</pre></td><td class="sourceCode"><pre><code><a class="raw" href="../code/toy/text-freq/analyze.hs" mimetype="text/plain">analyze.hs</a></code></pre></td></tr></tbody></table>
</div>
<div class="sourceCode" id="cb5" data-input="code/toy/text-freq/analyze.hs"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">import</span> <span class="dt">TextFreq</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-10" title="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-11" title="11">  fileList <span class="ot">&lt;-</span> T.getContents</a>
<a class="sourceLine" id="cb5-12" title="12">  src <span class="ot">&lt;-</span> liftM T.concat <span class="fu">.</span> <span class="fu">mapM</span> (T.readFile <span class="fu">.</span> T.unpack) <span class="fu">$</span> T.lines fileList</a>
<a class="sourceLine" id="cb5-13" title="13">  dispFreqL <span class="fu">$</span> freqL src</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">replicate</span> <span class="dv">80</span> <span class="ch">'-'</span></a>
<a class="sourceLine" id="cb5-15" title="15">  dispFreqW <span class="fu">$</span> freqW src</a></code></pre></div>
</div>
<p>Here is the same run against our copy of <em>Moby Dick</em>:</p>
<pre><code>$ ./analyze ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.67% (14620 occurrences)
of = 3.07% (6732 occurrences)
and = 2.97% (6502 occurrences)
a = 2.18% (4788 occurrences)
to = 2.15% (4706 occurrences)
in = 1.93% (4231 occurrences)
that = 1.37% (3005 occurrences)
his = 1.15% (2530 occurrences)
it = 1.11% (2434 occurrences)
i = 0.91% (1993 occurrences)
but = 0.83% (1823 occurrences)
he = 0.81% (1780 occurrences)
with = 0.81% (1770 occurrences)
as = 0.80% (1752 occurrences)
is = 0.80% (1748 occurrences)
was = 0.75% (1646 occurrences)
for = 0.75% (1646 occurrences)
all = 0.70% (1543 occurrences)
this = 0.66% (1443 occurrences)
at = 0.61% (1335 occurrences)
by = 0.56% (1226 occurrences)
not = 0.53% (1171 occurrences)
whale = 0.51% (1108 occurrences)
from = 0.50% (1105 occurrences)
on = 0.49% (1073 occurrences)
him = 0.49% (1067 occurrences)
so = 0.49% (1066 occurrences)
be = 0.49% (1064 occurrences)
you = 0.43% (946 occurrences)
one = 0.42% (914 occurrences)
there = 0.37% (805 occurrences)
or = 0.36% (797 occurrences)
now = 0.36% (783 occurrences)
had = 0.36% (779 occurrences)
have = 0.35% (773 occurrences)
were = 0.31% (683 occurrences)
they = 0.30% (664 occurrences)
which = 0.30% (655 occurrences)
like = 0.30% (647 occurrences)
me = 0.29% (632 occurrences)
then = 0.29% (630 occurrences)
their = 0.28% (620 occurrences)
some = 0.28% (619 occurrences)
are = 0.28% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.27% (600 occurrences)
no = 0.27% (596 occurrences)
my = 0.27% (589 occurrences)
upon = 0.26% (568 occurrences)
what = 0.26% (566 occurrences)
out = 0.25% (539 occurrences)
up = 0.24% (524 occurrences)
into = 0.24% (523 occurrences)
more = 0.23% (508 occurrences)
if = 0.23% (501 occurrences)
man = 0.22% (476 occurrences)
them = 0.22% (474 occurrences)
we = 0.21% (455 occurrences)
sea = 0.21% (454 occurrences)
old = 0.21% (452 occurrences)
ship = 0.20% (438 occurrences)
ahab = 0.20% (436 occurrences)
ye = 0.20% (431 occurrences)
would = 0.20% (430 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
over = 0.19% (409 occurrences)
these = 0.19% (406 occurrences)
will = 0.18% (398 occurrences)
though = 0.18% (384 occurrences)
its = 0.17% (382 occurrences)
only = 0.17% (378 occurrences)
down = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
any = 0.17% (364 occurrences)
who = 0.16% (347 occurrences)
yet = 0.16% (345 occurrences)
head = 0.16% (344 occurrences)
time = 0.15% (334 occurrences)
long = 0.15% (334 occurrences)
her = 0.15% (332 occurrences)
do = 0.15% (324 occurrences)
very = 0.15% (323 occurrences)
about = 0.15% (318 occurrences)
still = 0.14% (312 occurrences)
than = 0.14% (311 occurrences)
captain = 0.14% (308 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (306 occurrences)
said = 0.14% (305 occurrences)
here = 0.14% (302 occurrences)
before = 0.14% (301 occurrences)
two = 0.14% (298 occurrences)
boat = 0.14% (297 occurrences)
has = 0.13% (294 occurrences)
must = 0.13% (293 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
white = 0.13% (281 occurrences)
last = 0.13% (278 occurrences)</code></pre>
<p>.</p>
<h3 id="letter-frequency-2">Letter Frequency</h3>
<p><code>freqL</code> handles letter frequency, and it is a simple <code>foldl</code> operation over the input, while using the <code>Map</code> data structure from the <code>Data.Map</code> library (which acts as a simple hash structure with keys and values). The de facto Haskell compiler GHC comes with the <code>base</code> library which includes the <code>Data.Char</code> module; unlike Ruby, we can simply ask whether a character is a letter with <code>isAlpha</code>, and then use <code>toLower</code> on it to convert it to lowercase. <code>freqL</code> owes its brevity to these standard library functions.</p>
<p>Thanks to these standard library functions, we can easily keep track of more than just the basic 26 alphabetical letters (although in the case of <em>Moby Dick</em>, there does not seem to be any such characters).</p>
<h3 id="word-frequency-2">Word Frequency</h3>
<p>This is probably a convoluted way to keep track of words. I did not opt for using regular expressions, because I wanted to try out a different approach instead of just translating the Ruby solution. I could have used the excellent Parsec library, but I just felt like rolling my own solution.</p>
<p><code>freqW</code> works by looking at just one character at a time, just like <code>freqL</code>. It also keeps track of the evaluation of the previously-looked-at character, with the <code>wfsm</code> variable (for <em>Word Finite State Machine</em>, a fancy but still pertinent name). <code>wfsm</code> can either say that the last character made us go <em>in</em> a word (<code>WordIn</code>), <em>out</em> of a word for sure (<code>WordOut</code>), or possibly out of a word (<code>WordOutMaybe</code>). Depending on the status of <code>wfsm</code> and the current character, <code>freqW</code> makes various choices.</p>
<p>Now, this mechanism isn’t without its warts. But still, I consider it somewhat elegant in its description of all possible states.</p>
<h2 id="a-diff">A Diff</h2>
<p>For fun, let’s look at the diff of the outputs of the Ruby and Haskell versions. Interestingly, the letter frequency outputs were identical. The word frequency outputs did have some significant changes, such as the word <em>whale</em> occurring 972 and 1108 times in the Ruby and Haskell versions, respectively. I’ve sorted the output by lines for saner diffing.</p>
<pre><code>$ diff -u routW houtW
--- routW	2015-04-22 22:01:59.061404962 -0700
+++ houtW	2015-04-22 22:02:57.679828155 -0700
@@ -1,100 +1,100 @@
-a = 2.20% (4760 occurrences)
+a = 2.18% (4788 occurrences)
 about = 0.15% (318 occurrences)
-ahab = 0.20% (432 occurrences)
-all = 0.70% (1523 occurrences)
-an = 0.28% (600 occurrences)
-and = 2.99% (6488 occurrences)
-any = 0.17% (363 occurrences)
-are = 0.29% (619 occurrences)
-as = 0.81% (1751 occurrences)
-at = 0.62% (1334 occurrences)
-be = 0.49% (1060 occurrences)
+ahab = 0.20% (436 occurrences)
+all = 0.70% (1543 occurrences)
+an = 0.27% (600 occurrences)
+and = 2.97% (6502 occurrences)
+any = 0.17% (364 occurrences)
+are = 0.28% (619 occurrences)
+as = 0.80% (1752 occurrences)
+at = 0.61% (1335 occurrences)
+be = 0.49% (1064 occurrences)
 been = 0.19% (415 occurrences)
-before = 0.14% (300 occurrences)
-but = 0.84% (1823 occurrences)
-by = 0.56% (1223 occurrences)
-captain = 0.14% (300 occurrences)
-do = 0.15% (321 occurrences)
-down = 0.17% (367 occurrences)
-for = 0.76% (1645 occurrences)
-from = 0.51% (1105 occurrences)
-great = 0.14% (303 occurrences)
+before = 0.14% (301 occurrences)
+boat = 0.14% (297 occurrences)
+but = 0.83% (1823 occurrences)
+by = 0.56% (1226 occurrences)
+captain = 0.14% (308 occurrences)
+do = 0.15% (324 occurrences)
+down = 0.17% (378 occurrences)
+for = 0.75% (1646 occurrences)
+from = 0.50% (1105 occurrences)
+great = 0.14% (306 occurrences)
 had = 0.36% (779 occurrences)
-has = 0.14% (294 occurrences)
-have = 0.36% (772 occurrences)
-he = 0.82% (1777 occurrences)
-head = 0.13% (275 occurrences)
-her = 0.15% (329 occurrences)
-here = 0.14% (299 occurrences)
-him = 0.49% (1062 occurrences)
-his = 1.17% (2530 occurrences)
-i = 0.92% (1988 occurrences)
-if = 0.23% (500 occurrences)
-in = 1.95% (4223 occurrences)
+has = 0.13% (294 occurrences)
+have = 0.35% (773 occurrences)
+he = 0.81% (1780 occurrences)
+head = 0.16% (344 occurrences)
+her = 0.15% (332 occurrences)
+here = 0.14% (302 occurrences)
+him = 0.49% (1067 occurrences)
+his = 1.15% (2530 occurrences)
+i = 0.91% (1993 occurrences)
+if = 0.23% (501 occurrences)
+in = 1.93% (4231 occurrences)
 into = 0.24% (523 occurrences)
-is = 0.81% (1747 occurrences)
-it = 1.12% (2419 occurrences)
-its = 0.18% (382 occurrences)
-last = 0.13% (276 occurrences)
-like = 0.27% (581 occurrences)
-long = 0.15% (319 occurrences)
-man = 0.21% (445 occurrences)
-me = 0.29% (621 occurrences)
-more = 0.23% (506 occurrences)
+is = 0.80% (1748 occurrences)
+it = 1.11% (2434 occurrences)
+its = 0.17% (382 occurrences)
+last = 0.13% (278 occurrences)
+like = 0.30% (647 occurrences)
+long = 0.15% (334 occurrences)
+man = 0.22% (476 occurrences)
+me = 0.29% (632 occurrences)
+more = 0.23% (508 occurrences)
 most = 0.13% (284 occurrences)
-must = 0.13% (292 occurrences)
+must = 0.13% (293 occurrences)
 my = 0.27% (589 occurrences)
-no = 0.27% (594 occurrences)
-not = 0.54% (1169 occurrences)
-now = 0.36% (779 occurrences)
-of = 3.10% (6708 occurrences)
-old = 0.20% (444 occurrences)
-on = 0.49% (1069 occurrences)
-one = 0.42% (906 occurrences)
+no = 0.27% (596 occurrences)
+not = 0.53% (1171 occurrences)
+now = 0.36% (783 occurrences)
+of = 3.07% (6732 occurrences)
+old = 0.21% (452 occurrences)
+on = 0.49% (1073 occurrences)
+one = 0.42% (914 occurrences)
 only = 0.17% (378 occurrences)
-or = 0.37% (797 occurrences)
+or = 0.36% (797 occurrences)
 other = 0.19% (416 occurrences)
-out = 0.24% (528 occurrences)
-over = 0.19% (403 occurrences)
-said = 0.14% (301 occurrences)
-sea = 0.18% (382 occurrences)
-see = 0.12% (268 occurrences)
+out = 0.25% (539 occurrences)
+over = 0.19% (409 occurrences)
+said = 0.14% (305 occurrences)
+sea = 0.21% (454 occurrences)
 seemed = 0.13% (283 occurrences)
-ship = 0.18% (391 occurrences)
-so = 0.49% (1061 occurrences)
-some = 0.29% (619 occurrences)
-still = 0.14% (311 occurrences)
+ship = 0.20% (438 occurrences)
+so = 0.49% (1066 occurrences)
+some = 0.28% (619 occurrences)
+still = 0.14% (312 occurrences)
 such = 0.17% (376 occurrences)
 than = 0.14% (311 occurrences)
-that = 1.38% (2999 occurrences)
-the = 6.74% (14616 occurrences)
-their = 0.29% (620 occurrences)
-them = 0.22% (471 occurrences)
-then = 0.29% (628 occurrences)
-there = 0.37% (792 occurrences)
-these = 0.19% (405 occurrences)
-they = 0.31% (664 occurrences)
-this = 0.66% (1440 occurrences)
+that = 1.37% (3005 occurrences)
+the = 6.67% (14620 occurrences)
+their = 0.28% (620 occurrences)
+them = 0.22% (474 occurrences)
+then = 0.29% (630 occurrences)
+there = 0.37% (805 occurrences)
+these = 0.19% (406 occurrences)
+they = 0.30% (664 occurrences)
+this = 0.66% (1443 occurrences)
 those = 0.14% (307 occurrences)
-thou = 0.12% (267 occurrences)
-though = 0.18% (383 occurrences)
-time = 0.15% (326 occurrences)
-to = 2.16% (4677 occurrences)
-two = 0.13% (288 occurrences)
-up = 0.24% (516 occurrences)
-upon = 0.26% (567 occurrences)
+though = 0.18% (384 occurrences)
+time = 0.15% (334 occurrences)
+to = 2.15% (4706 occurrences)
+two = 0.14% (298 occurrences)
+up = 0.24% (524 occurrences)
+upon = 0.26% (568 occurrences)
 very = 0.15% (323 occurrences)
-was = 0.76% (1645 occurrences)
+was = 0.75% (1646 occurrences)
 we = 0.21% (455 occurrences)
-were = 0.32% (683 occurrences)
-whale = 0.45% (972 occurrences)
+were = 0.31% (683 occurrences)
+whale = 0.51% (1108 occurrences)
 what = 0.26% (566 occurrences)
 when = 0.28% (607 occurrences)
 which = 0.30% (655 occurrences)
-who = 0.16% (345 occurrences)
-will = 0.18% (396 occurrences)
-with = 0.82% (1770 occurrences)
-would = 0.20% (428 occurrences)
-ye = 0.20% (428 occurrences)
-yet = 0.16% (344 occurrences)
-you = 0.44% (944 occurrences)
+white = 0.13% (281 occurrences)
+who = 0.16% (347 occurrences)
+will = 0.18% (398 occurrences)
+with = 0.81% (1770 occurrences)
+would = 0.20% (430 occurrences)
+ye = 0.20% (431 occurrences)
+yet = 0.16% (345 occurrences)
+you = 0.43% (946 occurrences)</code></pre>
<h2 id="french">French?</h2>
<p>Here is the Haskell version’s output on the first volume of <a href="http://www.gutenberg.org/cache/epub/17489/pg17489.txt"><em>Les Misérables</em></a> in the original French:</p>
<pre><code>e = 14.68% (77528 occurrences)
a = 8.12% (42892 occurrences)
i = 7.65% (40424 occurrences)
t = 7.62% (40270 occurrences)
s = 7.27% (38395 occurrences)
n = 6.76% (35704 occurrences)
r = 6.25% (32985 occurrences)
u = 6.16% (32553 occurrences)
l = 5.81% (30686 occurrences)
o = 5.17% (27315 occurrences)
d = 3.46% (18262 occurrences)
c = 3.06% (16150 occurrences)
m = 2.99% (15800 occurrences)
p = 2.61% (13784 occurrences)
v = 1.95% (10285 occurrences)
é = 1.87% (9852 occurrences)
q = 1.26% (6637 occurrences)
f = 1.18% (6245 occurrences)
h = 1.06% (5623 occurrences)
b = 0.99% (5244 occurrences)
g = 0.93% (4910 occurrences)
j = 0.56% (2973 occurrences)
à = 0.53% (2795 occurrences)
x = 0.40% (2102 occurrences)
y = 0.39% (2051 occurrences)
è = 0.32% (1702 occurrences)
ê = 0.30% (1584 occurrences)
z = 0.18% (964 occurrences)
â = 0.08% (410 occurrences)
ç = 0.07% (355 occurrences)
û = 0.06% (335 occurrences)
ô = 0.05% (290 occurrences)
ù = 0.05% (285 occurrences)
w = 0.05% (284 occurrences)
î = 0.05% (276 occurrences)
k = 0.03% (151 occurrences)
ï = 0.01% (47 occurrences)
ë = 0.00% (5 occurrences)
ü = 0.00% (2 occurrences)
ñ = 0.00% (2 occurrences)
--------------------------------------------------------------------------------
de = 3.89% (4472 occurrences)
la = 2.64% (3040 occurrences)
et = 2.57% (2949 occurrences)
il = 2.25% (2582 occurrences)
le = 2.22% (2548 occurrences)
à = 1.94% (2236 occurrences)
les = 1.34% (1538 occurrences)
un = 1.27% (1459 occurrences)
que = 1.17% (1350 occurrences)
qui = 1.11% (1278 occurrences)
dans = 0.99% (1134 occurrences)
une = 0.92% (1062 occurrences)
ce = 0.92% (1062 occurrences)
en = 0.90% (1036 occurrences)
des = 0.82% (948 occurrences)
pas = 0.76% (879 occurrences)
se = 0.75% (859 occurrences)
ne = 0.73% (843 occurrences)
était = 0.69% (792 occurrences)
vous = 0.68% (783 occurrences)
je = 0.67% (770 occurrences)
avait = 0.66% (760 occurrences)
lui = 0.63% (721 occurrences)
du = 0.62% (714 occurrences)
elle = 0.57% (660 occurrences)
sur = 0.56% (640 occurrences)
sa = 0.55% (635 occurrences)
pour = 0.54% (620 occurrences)
son = 0.53% (611 occurrences)
au = 0.50% (579 occurrences)
cette = 0.48% (556 occurrences)
on = 0.47% (537 occurrences)
est = 0.46% (533 occurrences)
qu'il = 0.46% (528 occurrences)
a = 0.46% (524 occurrences)
tout = 0.45% (514 occurrences)
plus = 0.44% (508 occurrences)
comme = 0.44% (503 occurrences)
dit = 0.39% (446 occurrences)
avec = 0.38% (432 occurrences)
c'est = 0.36% (416 occurrences)
y = 0.35% (404 occurrences)
par = 0.34% (392 occurrences)
mais = 0.30% (350 occurrences)
nous = 0.30% (340 occurrences)
ses = 0.28% (321 occurrences)
là = 0.27% (308 occurrences)
bien = 0.27% (305 occurrences)
deux = 0.26% (303 occurrences)
monsieur = 0.26% (296 occurrences)
même = 0.26% (295 occurrences)
cela = 0.26% (295 occurrences)
ces = 0.26% (294 occurrences)
si = 0.24% (273 occurrences)
où = 0.23% (269 occurrences)
m = 0.23% (266 occurrences)
me = 0.21% (238 occurrences)
l'évêque = 0.21% (236 occurrences)
homme = 0.20% (234 occurrences)
sans = 0.20% (233 occurrences)
aux = 0.20% (232 occurrences)
fait = 0.20% (230 occurrences)
madeleine = 0.19% (214 occurrences)
qu'on = 0.18% (210 occurrences)
jean = 0.18% (210 occurrences)
d'un = 0.18% (208 occurrences)
c'était = 0.17% (199 occurrences)
valjean = 0.17% (197 occurrences)
être = 0.17% (196 occurrences)
fantine = 0.17% (192 occurrences)
d'une = 0.17% (190 occurrences)
javert = 0.15% (177 occurrences)
the = 0.15% (176 occurrences)
peu = 0.15% (173 occurrences)
cet = 0.15% (173 occurrences)
faire = 0.15% (172 occurrences)
puis = 0.15% (169 occurrences)
moi = 0.15% (168 occurrences)
j'ai = 0.14% (164 occurrences)
chose = 0.14% (164 occurrences)
été = 0.14% (163 occurrences)
maire = 0.14% (162 occurrences)
dire = 0.14% (159 occurrences)
rien = 0.14% (158 occurrences)
quand = 0.14% (157 occurrences)
sont = 0.13% (153 occurrences)
quelque = 0.13% (153 occurrences)
tous = 0.13% (152 occurrences)
porte = 0.13% (150 occurrences)
ou = 0.13% (148 occurrences)
toute = 0.13% (147 occurrences)
chapitre = 0.13% (144 occurrences)
sous = 0.12% (142 occurrences)
peut = 0.12% (140 occurrences)
mon = 0.12% (138 occurrences)
moment = 0.12% (138 occurrences)
dieu = 0.12% (137 occurrences)
encore = 0.12% (134 occurrences)
l'homme = 0.11% (130 occurrences)
eût = 0.11% (130 occurrences)</code></pre>
<p>. The most common French word in this book is <em>de</em>, meaning <em>of</em> in English. This is because the word for <em>the</em> is split into many different words, most notably <em>la</em> and <em>le</em>, not to mention <em>l’</em> as in <em>l’homme</em> (as you can see near the end of the list), due to the French language’s gender and vowel contraction rules (unlike English, contractions like <em>l’homme</em> in French are mandatory regardless of tone).</p>
<p>And, as a bit of trivia, it is interesting to note that <em>dieu</em> (God) edges out <em>l’homme</em> (man) by 7 occurrences in this text.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope you’ve had some fun working on these letter and word frequency problems. The word frequency problem, if you really want to do it correctly, should be handled by a parser using a robust library. By writing these programs, I learned that the <em>input</em> of a program (Unicode? ASCII only?) is just as important as its output.</p>
<p>Happy hacking!</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>After I receive, assemble, and acclimate myself to it, I will post a review.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

		</div>
		<div id="footer">
			<p>Copyright (C) 2013-2019 Linus Arver. All rights reserved.</p>
			<a href="https://github.com/listx/listx_blog">Site</a>
			<a href="https://github.com/listx/listx.github.io">generated</a>
			with
			<a href="https://jaspervdj.be/hakyll">Hakyll</a>
			and
			<a href="http://sebastiaanvisser.github.com/clay">Clay</a>.
			<br>
			<a href="../atom.xml">Atom feed</a>
		</div>
	</body>
</html>
