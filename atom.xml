<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Linus's Blog</title>
    <link href="http://listx.github.io/atom.xml" rel="self" />
    <link href="http://listx.github.io" />
    <id>http://listx.github.io/atom.xml</id>
    <author>
        <name>Linus Arver</name>
        <email></email>
    </author>
    <updated>2015-09-12T00:00:00Z</updated>
    <entry>
    <title>Tig Tips</title>
    <link href="http://listx.github.io/post/2015-09-12-tig-tips.html" />
    <id>http://listx.github.io/post/2015-09-12-tig-tips.html</id>
    <published>2015-09-12T00:00:00Z</published>
    <updated>2015-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-09-12</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-09-12-tig-tips.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/linux.html">linux</a>, <a href="/tag/git.html">git</a>
</div>

<p>I love <a href="https://github.com/jonas/tig">tig</a>. Still, I think the defaults aren’t the best for most developers. Here are two easy customizations to make the default view better.</p>
<p>First, put</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">alias</span> tig=<span class="st">&#39;tig -n 1000&#39;</span></code></pre></div>
<p>in your <code>~/.bashrc</code> to reduce tig’s startup time (especially on large repositories). There’s rarely a need to go back more than 1000 commits from your current HEAD position in an interactive, GUI-driven manner. And if you really need to see everything, do</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ \<span class="kw">tig</span></code></pre></div>
<p>on the terminal to bypass the shell alias.</p>
<p>Second, put the following in your <code>~/.tigrc</code> file:</p>
<pre><code>set main-view = date author id:width=10 commit-title:yes,graph,refs
</code></pre>
<p>. This makes the default view show git commit hashes (where <code>width</code> is the number of hex digits to show), so that you don’t have to press ENTER on a particular commit to see its hash.</p>
<p>Happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>Why I Use NixOS</title>
    <link href="http://listx.github.io/post/2015-08-01-why-i-use-nixos.html" />
    <id>http://listx.github.io/post/2015-08-01-why-i-use-nixos.html</id>
    <published>2015-08-01T00:00:00Z</published>
    <updated>2015-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-08-01</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-08-01-why-i-use-nixos.org" title="History">*</a>
	<br>
	<a href="/tag/linux.html">linux</a>, <a href="/tag/arch.html">arch</a>, <a href="/tag/nix.html">nix</a>, <a href="/tag/nixos.html">nixos</a>
</div>

<p>Since March 2015, I’ve been using NixOS on my main desktop machine at home. I was on Arch Linux for 6~7 years before that. So, why did I switch?</p>
<h1>Arch Linux</h1>
<p>Let’s review the reasons I switched to Arch Linux in the first place. I switched to Arch Linux from Xubuntu because I did not want to do big distribution upgrades from one major version to the next. Arch Linux is based on a rolling release schedule — packages are updated on a daily basis. What people often say is that Arch is “bleeding edge”. While that is true, they don’t realize that at the same time, you can choose to do weekly or monthly upgrades (in an incremental fashion) rather than waiting six months or a year for a big fat distribution upgrade.</p>
<h2>System age</h2>
<p>The problem though, is that with age the system becomes increasingly confusing because of unused files/directories. You install packages, then delete them, but then your system still has traces of them left. I still have an old laptop with Arch on it dating from an earlier install probably about five years back (or more) — and the <code>$HOME</code> directory on there has a lot of dotfiles and other folders — some of which I have no clue about. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> It’s not very different from the same feeling I got as a teenager looking at Windows XP’s <code>regedit.exe</code> and wondering what some of the registry keys did, or if they were used at all.</p>
<h2>Power user mindset</h2>
<p>Another problem is that Arch expects the user to understand their entire system from the bottom up! The culture is very much “RTFM”, but not only that, you are expected to sign up to the Arch mailing lists and also read the distro homepage on a regular basis. Dare I say it — the only reason the Arch Wiki is so well-regarded is because of this culture of “you must know everything”.</p>
<p>This is fine, but ultimately I believe that it is too much responsibility. For example, every once in a while, <code>pacman</code> generates copies of existing system files whenever they would get overwritten by newer ones. One example is the <code>/etc/group</code> file. Call me lazy but I never bothered learning about the ins-and-outs of this file and what the syntax means. But every Arch Linux user out there has to do a <code>vimdiff</code> against the old/new versions of this file and perform the correct changes (basically merge them), usually with the helper CLI tool called <code>yaourt</code> with its <code>-C</code> flag.</p>
<h2>Package confusion</h2>
<p>As you use Arch Linux, you invariably end up installing one package after another. Right now, there is no way to introduce some hierarchical system of organizing packages. For example, let’s say you install the <code>firefox</code> package because you want to use, well, Firefox! In <code>pacman</code>’s point of view, there is no difference between <code>firefox</code> and <code>libfoo</code>. I.e., high-visibility, userland packages like <code>firefox</code> are treated the same in all respects as <code>libfoo</code>. You can do clever things like have meta-packages, which are defined in terms of other packages (e.g., LibreOffice), but this kind of organizational structure is hard-coded at the <code>PKGBUILD</code> level. <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>I’m sure there are <code>pacman</code> helper scripts/programs out there to give you a better, organized understanding of all of your installed packages. But do you really want to know that you have <code>libvdpau</code> installed, or that it needs to get updated? As you press <code>pacman -Syu&lt;ENTER&gt;</code>, do you really care about the exact names of the 50 low-level system packages that your userland programs (like Firefox) depend on?</p>
<h1>NixOS</h1>
<p>So what makes NixOS better?</p>
<h2>Pros</h2>
<p>First off, system age has no real bearing on NixOS. Because everything is done in a functional way with the Nix package manager, your <strong>entire system</strong> becomes “recreated” each time you decide to upgrade. By default, you cannot directly write to places like <code>/usr/share</code> or <code>/usr/local</code>. Essentially, anything outside of <code>$HOME</code> can only be manipulated via the Nix package manager. And Nix does an excellent job of keeping all system directories clean and stateless!</p>
<p>Second, you don’t have to hand-tune system files like <code>/etc/group</code>. The NixOS configuration file is where you define system-wide things like users and groups, and after you set it once, it’s done for good.</p>
<p>Third, you can either hard-code what packages get installed system-wide in your config file (<code>/etc/nixos/configuration.nix</code>), or you can define your own set of packages on top of the ones defined by the official NixOS Nix expression. I used to do the former, but now I do the latter; and all I do now to see what packages I have installed explicitly is invoke <code>nix-env -q</code>, and I get this:</p>
<pre><code>fontforge-20141230
ghc-7.10.1
l-set-av
l-set-base
l-set-dev
l-set-games
l-set-misc
l-set-office
l-set-vm
l-set-web
pavucontrol-3.0
source-code-pro-2.010
</code></pre>
<p>. Those <code>l-set-</code> packages are ones where I have defined a hierarchy — i.e., I’ve coded up Arch Linux’s version of meta-packages. What’s great is that it’s all done in a programmatic way using the Nix expression language. <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> The rest are official packages I chose to install. But basically this sure beats doing something like <code>pacman -Q</code>, which grabs all installed packages on the entire system.</p>
<p>Fourth, I really like how I can do a <strong>system</strong> upgrade without touching my explicitly-installed packages in my user’s Nix environment (<code>nix-env</code>). I can update my version of <code>firefox</code> as much as I like without touching low-level packages like Xorg or the kernel, or vice-versa. It gives me the flexibility of a “rolling release” distro without the stability issues.</p>
<p>Fifth, the heart of NixOS — the Nix package manager — works by looking at a single “master” Nix expression. So if you have any custom Nix expressions, they better play well with the other ones officially provided upstream by the NixOS team! In Nix, no package is an island; in a sense, it’s a lot like how FreeBSD keeps all of their packages in a single code repository to guarantee stability.</p>
<h2>Cons</h2>
<p>Granted, there are problems with NixOS. The biggest problem is the lack of adoption. It still has not hit critical mass, and most of the core contributors are overloaded with far too much work.</p>
<p>The second problem is that there is no way to do things like <code>make install</code> after you download the source code to some program <code>foo</code>. This is because NixOS does not have directories like <code>/usr/share</code> — the whole Linux Filesystem Hierarchy Standard is thrown out the window in favor of symlinks to the “compiled” Nix expressions. So, you have to Nxifiy it first, and then install it via its Nix expression (<code>foo.nix</code>). In this respect it shares the same pain point with <a href="http://www.gobolinux.org/">GoboLinux</a>. Personally this is not a huge problem for me, but it’s still a problem.</p>
<h1>Conclusion</h1>
<p>I hope this post gave you some motivation to try out NixOS. It has a steep learning curve but after you get most things working, it’s really great. Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Granted, <code>$HOME</code> directories are supposed to be “dirty” as they are by their nature stateful things. On the other hand, system directories like <code>/usr/share</code> and <code>/usr/bin</code> should be kept clean by the distribution’s package management system, but rarely is it automatic and maintenance-free. Arch Linux is no exception.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><code>PKGBUILD</code> files are like Makefiles, but for creating Arch Linux packages.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The Nix package manager only deals with *.nix files, which are exclusively written in the Nix expression language.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Emacs: Setting Up mmm-mode for Literate Haskell</title>
    <link href="http://listx.github.io/post/2015-07-28-literate-haskell-mmm-mode.html" />
    <id>http://listx.github.io/post/2015-07-28-literate-haskell-mmm-mode.html</id>
    <published>2015-07-28T00:00:00Z</published>
    <updated>2015-07-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-07-28</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-07-28-literate-haskell-mmm-mode.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/emacs.html">emacs</a>, <a href="/tag/haskell.html">haskell</a>
</div>

<p>I use <a href="https://wiki.haskell.org/Literate_programming">Literate Haskell</a> for some of my personal Haskell projects and for a long time I used the auto-loaded <code>literate-haskell-mode</code> that comes with <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>. This past weekend, I finally buckled down and made use of <a href="https://github.com/purcell/mmm-mode">mmm-mode</a> to make the literate programming experience better. The biggest advantage of using <code>mmm-mode</code> is that you can define subregions of your file which are handled by a different major mode. In other words, you can get proper syntax highlighting for 2, 3, or more different languages in the same file!</p>
<h1>Setup</h1>
<p>You’ll need to install <a href="https://github.com/purcell/mmm-mode">mmm-mode</a> along with <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>. I personally use <a href="http://melpa.org/">MELPA</a> for all of my Emacs packages because once you set it up it’s really painless.</p>
<p>In your <a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html">emacs configuration file</a> add these lines:</p>
<pre><code>; Remove the hard-coded &#39;literate-haskell-mode&#39; activation for `.lhs&#39; files that
; haskell-mode comes with. In exchange, enable LaTeX mode whenever we open up a
; `.lhs&#39; file. Using mmm-mode, we will activate `haskell-mode&#39; in the code
; sections.
(setq auto-mode-alist
  (remove
    (rassoc &#39;literate-haskell-mode auto-mode-alist) auto-mode-alist))
(add-to-list &#39;auto-mode-alist &#39;(&quot;\\.lhs$&quot; . latex-mode))

; Literate Haskell - mmm-mode. Adopted from
; https://wiki.haskell.org/Literate_programming#Multi-mode_support_in_Emacs
(require &#39;mmm-auto)

(mmm-add-classes
  &#39;((literate-haskell-latex
    :submode haskell-mode
    :front &quot;^\\\\begin{code}\n&quot;
    :back &quot;^\\\\end{code}&quot;
  )))
</code></pre>
<p>. Now it’s a matter of running the following commands whenever you open up a <code>.lhs</code> file:</p>
<pre><code>(setq mmm-global-mode &#39;t)
(setq mmm-submode-decoration-level 1)
(mmm-ify-by-class &#39;literate-haskell-latex)
</code></pre>
<p>. Personally I use <a href="https://github.com/listx/kakapo-mode">kakapo-mode</a> so I have a file called <code>kakapo-project-settings</code> that has this snippet in it:</p>
<pre><code>(defun my-kakapo-indents ()

  ...

  ; Literate Haskell
  ((string-match &quot;\\.lhs$&quot; b)
    (progn
      (h &#39;latex-mode-hook t 4)
      (setq mmm-global-mode &#39;t)
      (setq mmm-submode-decoration-level 1)
      (mmm-ify-by-class &#39;literate-haskell-latex)
    )
  )

  ...

)
</code></pre>
<p>. Emacs will now automatically pick up <code>.lhs</code> files and apply <code>latex-mode</code> and <code>haskell-mode</code> with <code>mmm-mode</code>. Happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>Useful rxvt-unicode (URxvt) Plugins</title>
    <link href="http://listx.github.io/post/2015-06-25-urxvt-plugins.html" />
    <id>http://listx.github.io/post/2015-06-25-urxvt-plugins.html</id>
    <published>2015-06-25T00:00:00Z</published>
    <updated>2015-06-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-06-25</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-06-25-urxvt-plugins.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/linux.html">linux</a>
</div>

<h1>Introduction</h1>
<p>I’ve been using <a href="http://software.schmorp.de/pkg/rxvt-unicode.html">rxvt-unicode</a> (<code>urxvt</code>) for years. But, I never really bothered to customize it beyond adding in some simple font changing hotkeys. I discovered that <code>urxvt</code> can be customized with Perl plugins. This post shows some of the plugins I’ve started using.</p>
<p>For this post, I will use the terms <strong>terminal</strong> and <code>urxvt</code> interchangeably. The plugins are configured in your <code>~/.Xdefaults</code> file, and to have this file take effect, run</p>
<pre><code>xrdb -merge ~/.Xdefaults
</code></pre>
<p>. The hotkeys are defined with key names from <a href="http://cgit.freedesktop.org/xorg/proto/x11proto/plain/keysymdef.h">keysymdef.h</a> as part of X11.</p>
<h1>keyboard-select</h1>
<p><a href="https://github.com/muennich/urxvt-perls">Homepage</a> (part of <code>urxvt-perls</code>)</p>
<p>This is by far the most useful plugin. If you ever need surgical precision to select a particular chunk of text in your terminal, you can use this plugin. It gives you Vim-like <em>normal mode</em> navigation in your terminal — and then you can use hotkeys like <code>v</code> or <code>V</code> to select chunks of text, and use <code>y</code> to copy it to your X primary buffer.</p>
<p>I use the snippet below in my <code>~/.Xdefaults</code>:</p>
<pre><code>! keyboard-select
URxvt.keysym.M-s: perl:keyboard-select:activate
URxvt.keysym.M-r: perl:keyboard-select:search
</code></pre>
<p>. Now, <code>M-s</code> (<code>Alt-s</code> for you folks not familiar with Emacs-style shortcut-naming) in the terminal gives you Vim-like normal mode like I mentioned above. The other shortcut, <code>M-r</code>, gives your reverse search against your terminal’s buffer.</p>
<p>Let <code>M-r</code> sink in. This means that your terminal is basically running a virtual <code>less</code> pager. Any time you want to go search against some text in your terminal, just use <code>M-r</code> and search; use <code>n</code> and <code>N</code> just like <code>less</code>.</p>
<p>Actually, <code>M-r</code> is basically doing <code>M-s</code> followed by <code>?</code>. So, if you like searching forwards (not backwards), just do <code>M-s</code> and then <code>/</code>. But considering how terminal buffers are always <strong>above</strong> the cursor, it makes sense to search backwards by default with <code>M-r</code>. For me this runs against my habit of using <code>less</code> and <code>/</code>, but there you have it.</p>
<h1>clipboard</h1>
<p><a href="https://github.com/muennich/urxvt-perls">Homepage</a> (part of <code>urxvt-perls</code>)</p>
<p><code>~/.Xdefaults</code> snippet:</p>
<pre><code>! clipboard
! update clipboard whenever primary gets updated
URxvt.clipboard.autocopy: true
URxvt.keysym.M-c: perl:clipboard:copy
URxvt.keysym.M-v: perl:clipboard:paste
URxvt.keysym.M-C-v: perl:clipboard:paste_escaped
</code></pre>
<p>. To be honest I think the <code>autocopy</code> feature is a bit flaky (at least when using these shortcuts inside a NixOS VirtualBox VM from a Mac) — but that’s not that important.</p>
<p><code>M-c</code> copies the X11 primary buffer (aka X selection) to the clipboard buffer.</p>
<p>What’s really nice is the <code>M-v</code> shortcut — it pastes the <strong>clipboard</strong> buffer, not the X11 primary buffer (there is <code>S-&lt;insert&gt;</code> (Shift-Insert) for that). Now you don’t have to type <code>$(xsel -b)</code> for the same thing.</p>
<p><code>M-C-v</code> (<code>Alt-Control-v</code>) does the same thing, but escapes any special characters. This is very handy — a simple use case might be using <code>M-s</code> (search shortcut discussed above) to find a particular file with a long name (think MP3 files) from the output of <code>ls</code> — you can then just use <code>v</code> to copy that filename to the X11 buffer, then use <code>M-c</code> to copy it to clipboard buffer (if <code>autocopy</code> is working this step is unnecessary), then use <code>M-C-v</code> to paste it in, escaping things like space characters so that you can use other tools like <code>cp</code> or <code>mv</code> on them more easily.</p>
<h1>url-select</h1>
<p><a href="https://github.com/muennich/urxvt-perls">Homepage</a> (part of <code>urxvt-perls</code>)</p>
<p><code>~/.Xdefaults</code> snippet:</p>
<pre><code>! url-select. We can middle-click on any url and this will launch the browser
! defined by `URxvt.url-select.launcher`.
URxvt.keysym.M-u: perl:url-select:select_next
URxvt.url-select.underline: true
URxvt.url-select.launcher: firefox
</code></pre>
<p>. Now you can use <code>M-u</code> to jump between any URL that was printed to the terminal buffer. Use <code>j</code> and <code>k</code> to jump to the next/previous URL, and <code>y</code> to copy it to your X primary buffer (and <code>M-c</code> to make sure it’s also in the clipboard) for easy URL handling. Or, simply press <code>ENTER</code> to open that link in your browser. Next time you grab your mouse to carefully highlight a URL in the terminal, think again!</p>
<h1>font-size</h1>
<p><a href="https://github.com/majutsushi/urxvt-font-size">Homepage</a></p>
<p>This plugin allows you to scale fonts up or down.</p>
<p><code>~/.Xdefaults</code> snippet:</p>
<pre><code>! `font-size` plugin
URxvt.keysym.C-minus: perl:font-size:decrease
URxvt.keysym.C-equal: perl:font-size:increase
! The default font increase step size is 1. This is for portability across all
! fonts (some fonts do not support particular font sizes). Because changing font
! size only really makes sense for anti-aliased fonts (Terminus is bitmapped),
! and because anti-aliased fonts support any size, it makes sense to just use a
! size step of 4 for faster transitions between font size changes.
URxvt.font-size.step: 4
</code></pre>
<p>. This is pretty self-explanatory. Use <code>C-minus</code> or <code>C-equal</code> to change your font size as needed — perfect for screencasts or demos!</p>
<h1>Conclusion</h1>
<p>Now that I use these plugins, there’s even less interruption to use the mouse. I hope you find them as useful as I have.</p>
<p>Happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>SRM 485: AfraidOfEven</title>
    <link href="http://listx.github.io/post/2015-05-04-puzzle-srm-485-afraid-of-even.html" />
    <id>http://listx.github.io/post/2015-05-04-puzzle-srm-485-afraid-of-even.html</id>
    <published>2015-05-04T00:00:00Z</published>
    <updated>2015-05-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-05-04</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-05-04-puzzle-srm-485-afraid-of-even.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/math.html">math</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/ruby.html">ruby</a>
</div>

<h1>Introduction</h1>
<p>The heart of this problem comes from TopCoder’s <a href="http://community.topcoder.com/stat?c%3Dproblem_statement&amp;pm%3D11146&amp;rd%3D14238">SRM 485 “AfraidOfEven”</a>. There is quite a lot of discussion behind the somewhat elementary math principles, so you might want to skip down to the code directly after reading the problem statement.</p>
<h1>The Problem</h1>
<p>An <a href="http://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic progression</a> <span class="math inline">\(AP\)</span> has been changed by the mutation function <span class="math inline">\(M()\)</span> in the following way: any even number <span class="math inline">\(w\)</span> in the sequence has been replaced by <span class="math inline">\(\frac{w}{2}\)</span>, repeatedly, until it has become odd. For example, if <span class="math inline">\(AP = \{2, 4, 6, 8\}\)</span>, then <span class="math inline">\(M(AP) = \{1, 1, 3, 1\}\)</span> (because <span class="math inline">\(\frac{6}{2} = 3\)</span> and <span class="math inline">\(3\)</span> is an odd number, it stopped mutating). Given a mutated sequence <span class="math inline">\(M(AP) = MP\)</span>, design an “unmutate” function <span class="math inline">\(U()\)</span> such that <span class="math inline">\(U(MP) \approx AP\)</span>. If more than one possible sequence <span class="math inline">\(AP\)</span> exists, find the one with the lowest lexicographical order.</p>
<h2>Constraints</h2>
<p><span class="math inline">\(MP\)</span> is limited to 4 to 50 terms. Each term in <span class="math inline">\(MP\)</span> is from <span class="math inline">\(1\)</span> to <span class="math inline">\(1000\)</span>, inclusive (for now; later on we will consider numbers less than <span class="math inline">\(1\)</span>). The difference (let’s call it <span class="math inline">\(m\)</span>) between each term can be <span class="math inline">\(0\)</span>, so the following is still a valid arithmetic progression: <span class="math inline">\(\{-17, -17, -17, -17, -17\}\)</span>.</p>
<h3>Lexicographic Order</h3>
<p>Given the input</p>
<p><span class="math display">\[
MP = \{1, 1, 3, 1, 5\}
\]</span></p>
<p>, we get the output</p>
<p><span class="math display">\[
U(AP) = \{1, 2, 3, 4, 5\}
\]</span></p>
<p>. It is possible that <span class="math inline">\(AP\)</span> was actually <span class="math inline">\(\{2, 4, 6, 8, 10\}\)</span> (or even <span class="math inline">\(\{4, 8, 12, 16, 20\}\)</span>), but because <span class="math inline">\(\{1, 2, 3, 4, 5\}\)</span> has the smaller lexicographic representation, it is the correct answer.</p>
<h1>Interlude</h1>
<p>I will include both Haskell and Ruby solutions in this post below. If you’d like to solve the problem on your own, please read the rest of this post at a later time.</p>
<h1>The Math</h1>
<p>Let us consider the universe of possible arithmetic progressions, and then derive a general algorithm. Because the mutation involves even numbers, it makes sense to look at arithmetic progressions in terms of even and odd numbers (aka <em>parity</em>).</p>
<p>The two most important parts of an arithmetic progression are the rate of change, <span class="math inline">\(m\)</span>, and the first term <span class="math inline">\(A_0\)</span>. This is because any arithmetic progression can be recreated by knowing only these two values.</p>
<p>Now, <span class="math inline">\(m\)</span> can be either even (<span class="math inline">\(E\)</span>), odd (<span class="math inline">\(O\)</span>), or zero. The first term <span class="math inline">\(A_0\)</span> can be either even or odd. Let’s plug these possible variations into a table, and see if there are any patterns we can exploit. To determine <span class="math inline">\(AP\)</span> based on <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, we only need to know three laws of parity:</p>
<ol>
<li><span class="math inline">\(\mathrm{O + O = E}\)</span></li>
<li><span class="math inline">\(\mathrm{E + E = E}\)</span></li>
<li><span class="math inline">\(\mathrm{O + E = O}\)</span></li>
</ol>
<p>. Using these laws, we can construct the entire sequence <span class="math inline">\(AP\)</span> by adding <span class="math inline">\(m\)</span> into <span class="math inline">\(A_0\)</span> repeatedly.</p>
<p>The only time that adding two numbers together results in an odd number is when one term is odd and the other term is even. This rule is true regardless of whether we are adding or subtracting (adding a negative term), or whether either term is positive or negative. Another interesting point is that adding by an even number does not change the parity of the original term, while adding by an odd number always flips the parity of the original. We now know how to construct <span class="math inline">\(AP\)</span> from <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, so let’s examine the possible outcomes below:</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center"><span class="math inline">\(m\)</span></th>
<th align="center"><span class="math inline">\(A_0\)</span></th>
<th align="center"><span class="math inline">\(AP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">5</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">6</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. Let’s now look at each of the 6 possible cases, and see if we can simplify things more. We will look at each case from the perspective of <span class="math inline">\(m\)</span>.</p>
<h2>Mutation When <span class="math inline">\(m\)</span> is Zero</h2>
<p>If <span class="math inline">\(m\)</span> is zero, then <span class="math display">\[AP = {A_0, A_0, A_0\cdots{}A_0}\]</span>. That is, subsequent terms after <span class="math inline">\(A_0\)</span> do not change, so it is a constant sequence of the first term, <span class="math inline">\(A_0\)</span>.</p>
<p>If <span class="math inline">\(m\)</span> is zero and <span class="math inline">\(A_0\)</span> is <strong>odd</strong>, then all terms remain the same after the mutation; so, <span class="math inline">\(M(AP) = AP\)</span> (no change). E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{3, 3, 3, 3, \cdots{}, 3}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{3, 3, 3, 3, \cdots{}, 3}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. If <span class="math inline">\(m\)</span> is zero and <span class="math inline">\(A_0\)</span> is <strong>even</strong>, then all terms are likewise even, and all terms will become odd by application of <span class="math inline">\(M()\)</span>. What’s more, every term in <span class="math inline">\(M_0\)</span> will be the same odd number, essentially becoming “reduced” to the case where <span class="math inline">\(A_0\)</span> was originally odd. E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{10, 10, 10, 10, \cdots{}, 10}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{5, 5, 5, 5, \cdots{}, 5}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h2>Mutation When <span class="math inline">\(m\)</span> is Even</h2>
<p>If <span class="math inline">\(m\)</span> is even, then all terms in <span class="math inline">\(AP\)</span> are either even or odd, based on the first term <span class="math inline">\(A_0\)</span>. Essentially, <span class="math inline">\(AP\)</span> behaves in an identical manner to the case where <span class="math inline">\(m = 0\)</span> as far as parity is concerned — the only difference here is that the subsequent terms change in value by <span class="math inline">\(m\)</span>.</p>
<p>However, there is a slight twist when we apply mutation. If <span class="math inline">\(A_0 = \mathrm{O}\)</span>, then there are no numbers to mutate, and we get <span class="math inline">\(MP\)</span> where all terms are odd and they change by <span class="math inline">\(m\)</span>. But if <span class="math inline">\(A_0 = \mathrm{E}\)</span>, then we get <em>changing</em> even numbers for <span class="math inline">\(MP\)</span>. So unlike in the case of <span class="math inline">\(m = 0\)</span> where all even numbers reduced down to the same odd number after applying the mutation, we get <em>different</em> odd numbers. E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{40, 48, 56, 64, 72}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{5, 3, 7, 1, 9}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. Notice how even though <span class="math inline">\(AP\)</span> has a sequence of <em>increasing</em> terms, <span class="math inline">\(MP\)</span>’s terms are not increasing in the same manner. We will revisit this case below when simplifying the categories of behavior for <span class="math inline">\(MP\)</span>.</p>
<h2>Mutation When <span class="math inline">\(m\)</span> is Odd</h2>
<p>This is where things get interesting. If <span class="math inline">\(m\)</span> is odd, then <span class="math inline">\(AP\)</span> becomes a <em>series of alternating even and odd numbers</em>. Whether <span class="math inline">\(AP\)</span> begins with an even or odd number depends, naturally, on the parity of <span class="math inline">\(A_0\)</span>. The more general observation we can make is that, given the fact that we have alternating even and odd numbers in <span class="math inline">\(AP\)</span>, <span class="math inline">\(MP\)</span> will be populated with “originally odd” and “fake odd” (mutated) terms. Let’s call these mutated terms <span class="math inline">\(O_F\)</span>. So if <span class="math inline">\(m\)</span> is odd, then we get either</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{O, E, O, E}\}, MP = \{\mathrm{O, O_F, O, O_F}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">or</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{E, O, E, O}\}, MP = \{\mathrm{O_F, O, O_F, O}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h1>A Summary of the Behavior of the Mutation Function <span class="math inline">\(M()\)</span></h1>
<p>We’ve exhausted the universe of all possible arithmetic sequences, and how they would mutate after applying <span class="math inline">\(M()\)</span>. We know exactly how <span class="math inline">\(M()\)</span> behaves in all edge cases! Let us now simplify the various cases to two general cases.</p>
<h2>There is nothing to “unmutate” as <span class="math inline">\(MP\)</span> is already the same as the answer <span class="math inline">\(AP\)</span></h2>
<p>This can happen in two ways. The easiest way is if <span class="math inline">\(m = 0\)</span>, where all terms in <span class="math inline">\(MP\)</span> are the same and there is nothing to calculate (<span class="math inline">\(M()\)</span> will ensure that this case always results in the same repeating odd number). The other way is if <span class="math inline">\(m\)</span> is even, and <span class="math inline">\(A_0\)</span> is odd — resulting in an “unmutatable” sequence such that <span class="math inline">\(M(AP) = AP\)</span>. E.g. (where <span class="math inline">\(m = 10\)</span> and <span class="math inline">\(A_0 = 11\)</span>),</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{11, 21, 31, 41, 51}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{11, 21, 31, 41, 51}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h2>The terms in <span class="math inline">\(AP\)</span> alternate between even and odd</h2>
<p>This covers the case when <span class="math inline">\(m\)</span> is odd. If <span class="math inline">\(m\)</span> is odd, then regardless of the parity of <span class="math inline">\(A_0\)</span>, we get an alternating sequence of even and odd numbers. The import thing to keep in mind here is that the even numbers will mutate after <span class="math inline">\(\mathrm{M()}\)</span> is applied, while the odd numbers will stay as-is as “originals”.</p>
<h1>How to Design <span class="math inline">\(U()\)</span></h1>
<p>Let’s think back to what our mutation function <span class="math inline">\(M()\)</span> does: it simply mutates an even number to an odd number by repeatedly dividing it by 2. If the number if odd to begin with, then there is nothing to mutate; essentially, <em>original</em> odd numbers act as immutable beacons of truth — they do not have to change form when returning to their <span class="math inline">\(AP\)</span> form! Our task in designing an “unmutate” function <span class="math inline">\(U()\)</span> is to preserve the “honest” odd numbers while converting the mutated, “fake” odd numbers back to their evenness, to get back the original progression <span class="math inline">\(AP\)</span> (or at least something close to it if there are multiple such <span class="math inline">\(AP\)</span>s out there.</p>
<p>You can now see where our extensive parity breakdown of the possible <span class="math inline">\(MP\)</span> can come in handy — we know in what patterns the honest odd numbers show themselves in <em>any</em> <span class="math inline">\(MP\)</span>. Let’s rewrite the table of all possibilities, with this analogy of “honest” and “fake” (<span class="math inline">\(O_F\)</span>) odd numbers after the mutation.</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center"><span class="math inline">\(m\)</span></th>
<th align="center"><span class="math inline">\(A_0\)</span></th>
<th align="center"><span class="math inline">\(AP\)</span></th>
<th align="center"><span class="math inline">\(MP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(?\)</span></td>
</tr>
<tr class="odd">
<td align="center">5</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">6</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>As you can see, the two dominating patterns are either the all-odd (and honest!) numbers (first 3 rows) or the alternating honest or fake odd numbers. But what about the case where <span class="math inline">\(m\)</span> is a nonzero even value and <span class="math inline">\(A_0\)</span> is even as well (row 4)? In the universe of all possible even numbers of <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, how can we know for a fact that the mutation to <span class="math inline">\(MP\)</span> will fall into a neat pattern?</p>
<h1>When both <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span> are even</h1>
<p>The short answer is, we can prove that all such sequences will mutate to the familiar <span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span>, <span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span>, or <span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span> pattern shown in the table above. The long answer is that it helps to think of linear equations, and to see the possible ways in which we can <em>grow</em> the <span class="math inline">\(AP\)</span> progression from <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>.</p>
<p>If you paid attention in high school algebra class, you will probably remember the formula <span class="math inline">\(y = mx + b\)</span> to describe a straight line (except the vertical line!) in the cartesian coordinate system (in the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> axes). We can use the <strong>same</strong> equation to describe the growth behavior of an arithmetic sequence! And for that, we use the following translation:</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(y = mx + b\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = mn + A_0\)</span></td>
</tr>
</tbody>
</table>
<p>, where <span class="math inline">\(A_n\)</span> is the n-th term to be calculated in <span class="math inline">\(AP\)</span>. Luckily, we’ve used the same letter <span class="math inline">\(m\)</span> in both contexts — it describes the rate of change in one, and the distance between each term in the other. Let’s simplify the equation with a concern to parity only.</p>
<p>First, let’s rewrite the equation as follows:</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E\cdot{}}n + \mathrm{E}\)</span></td>
</tr>
<tr class="even">
<td align="center">or</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E_m}\cdot{}n + \mathrm{E_{A0}}\)</span></td>
</tr>
</tbody>
</table>
<p>. The <span class="math inline">\(\mathrm{E}\)</span> here represents that this number is an even number, with the subscript denoting whether it is <span class="math inline">\(m\)</span> (<span class="math inline">\(\mathrm{E_m}\)</span>) or the first term in the sequence (<span class="math inline">\(\mathrm{E_{A0}}\)</span>). If we use this equation to map out the first 4 elements of <span class="math inline">\(AP\)</span>, we get the following:</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_0 = \mathrm{E_m\cdot{}0 + E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">\(A_1 = \mathrm{E_m\cdot{}1 + E_{A0}}\)</span></td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_2 = \mathrm{E_m\cdot{}2 + E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">\(A_3 = \mathrm{E_m\cdot{}3 + E_{A0}}\)</span></td>
</tr>
</tbody>
</table>
<p>. It should be noted that both <span class="math inline">\(\mathrm{E_m}\)</span> and <span class="math inline">\(\mathrm{E_{A0}}\)</span> remain the <strong>same</strong> throughout the entire sequence <span class="math inline">\(AP\)</span>. The only thing that changes is <span class="math inline">\(n\)</span>, which always increments by <span class="math inline">\(1\)</span>, starting from <span class="math inline">\(0\)</span>.</p>
<p>And now we’re faced with a problem. Ideally, we’d like to get rid of all those even terms in our formula — they don’t help us out at all! This is where we use the concept of <em>scaling</em>. There are two scaling rules: (1) if you multiply all terms of an arithmetic progression by some nonzero integer <span class="math inline">\(k\)</span>, <em>the new progression remains arithmetic</em>; (2) the same is true if you divide all terms by <span class="math inline">\(k\)</span>.</p>
<p>The first scaling rule works because</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n\cdot{}k = (\mathrm{E_m\cdot{}}n + \mathrm{E_{A0}})\cdot{}k\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n\cdot{}k = (\mathrm{E_m}\cdot{}{k})\cdot{}n + \mathrm{E_{A0}}\cdot{}k\)</span></td>
</tr>
</tbody>
</table>
<p>, where the terms <span class="math inline">\(\mathrm{E_{A0}}\cdot{}k\)</span> and <span class="math inline">\(\mathrm{E_m}\cdot{}k\)</span> both remain as constants — we are still dealing with a <a href="http://en.wikipedia.org/wiki/Degree_of_a_polynomial">degree 1 polynomial</a> (linear expression). Apart from increasing the first term <span class="math inline">\(\mathrm{A_0}\)</span> by <span class="math inline">\(k\)</span>, all we did was increase the gap between each term by a factor of <span class="math inline">\(k\)</span>. Likewise, if you <em>divide</em> all terms of an arithmetic progression by some nonzero integer <span class="math inline">\(k\)</span>, the new progression still remains arithmetic, because what you are doing is</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(\frac{A_n}{k} = \frac{\mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}}{k}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(\frac{A_n}{k} = \frac{\mathrm{E_m}}{k}\cdot{}n + \frac{\mathrm{E_{A0}}}{k}\)</span></td>
</tr>
</tbody>
</table>
<p>. Division is simply multiplication by the inverse, so the same reasoning as for the first scaling rule applies here as well. By the way, we don’t have to worry about what <span class="math inline">\(A_n\cdot{}k\)</span> or <span class="math inline">\(\frac{A_n}{k}\)</span> would look like — we are merely concerned with how <em>parity</em> behaves, and for that we rely on the right hand side of the equation.</p>
<p>Going back to our problem, recall that we want to ultimately output some arithmetic progression that <em>could</em> have resulted in the given mutated list <span class="math inline">\(MP\)</span>. This is what scaling gives us — it gives us the leeway that we need to stay within our original problem domain while changing around the parity of <span class="math inline">\(A_n\)</span> with <span class="math inline">\(k\)</span>.</p>
<p>Let us scale the entire progression by <span class="math inline">\(k = \frac{1}{2}\)</span>. That is, let us repeatedly divide <span class="math inline">\(\mathrm{E_m}\)</span> and <span class="math inline">\(\mathrm{E_{A0}}\)</span> by 2, until one or both of them become odd. When either one becomes odd, we stop scaling and reuse the parity laws we discussed above to draw deeper conclusions. Which variable, <span class="math inline">\(\mathrm{E_m}\)</span> or <span class="math inline">\(\mathrm{E_{A0}}\)</span>, has more 2’s in it (as prime factors)? Which term is more <em>even</em> than the other?</p>
<p>There are three possible scenarios when we scale (let’s call it <span class="math inline">\(\mathrm{S()}\)</span>) by <span class="math inline">\(\frac{1}{2}\)</span> <strong>repeatedly</strong> as described above: (1) <span class="math inline">\(\mathrm{E_{A0}}\)</span> becomes odd first, (2) <span class="math inline">\(\mathrm{E_m}\)</span> becomes odd first, or (3) both become equally odd. If we write these three scenarios into a table, we get the following:</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center">Scaled by <span class="math inline">\(\frac{1}{2}\)</span> repeatedly</th>
<th align="center">Parity of Scaled <span class="math inline">\(AP\)</span></th>
<th align="center">Parity of Scaled <span class="math inline">\(MP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{E\cdot{}}n + \mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{O\cdot{}}n + \mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{O\cdot{}}n + \mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. The parity of each scaled <span class="math inline">\(AP\)</span> is calculated by simply replacing <span class="math inline">\(n\)</span> with 0, 1, 2, etc. and relying on our three parity laws from the beginning of this post. If you want to lessen your load of mental arithmetic, we can simplify the parity expressions further. If we reword the additive parity laws with multiplication in mind (which is simply addition repeated many times over), we can derive two more parity laws:</p>
<ol>
<li><span class="math inline">\(\mathrm{E\cdot{}}n = \mathrm{E}\)</span>, regardless of <span class="math inline">\(n\)</span>, and</li>
<li><span class="math inline">\(\mathrm{O\cdot{}}n = \mathrm{P}_n\)</span> — i.e., the parity of <span class="math inline">\(\mathrm{O\cdot{}}n\)</span> is the same as the parity of <span class="math inline">\(n\)</span> itself</li>
</ol>
<p>. Going back to our table above, we can simplify the scaled expressions further:</p>
<ol>
<li><span class="math inline">\(\mathrm{E + O} = \mathrm{O}\)</span>, because adding by an even number preserves the parity of <span class="math inline">\(\mathrm{O}\)</span>.</li>
<li><span class="math inline">\(\mathrm{P}_n + \mathrm{E} = \mathrm{P}_n\)</span>, because adding by an even number preserves the parity of <span class="math inline">\(\mathrm{P}_n\)</span>.</li>
<li><span class="math inline">\(\mathrm{P}_n + \mathrm{O} = \neg{}\mathrm{P}_n\)</span>, because adding by an odd number flips the parity of <span class="math inline">\(\mathrm{P}_n\)</span></li>
</ol>
<p>.</p>
<p>And now we can finally say that when both <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span> are even, the parity of terms in in <span class="math inline">\(AP\)</span> can be either all odd or alternating between even and odd! I.e., if both <span class="math inline">\(m = \mathrm{E}\)</span> and <span class="math inline">\(A_0 = \mathrm{E}\)</span>, then <span class="math inline">\(M(AP) = \{\mathrm{O, O, O, O, \cdots{}}\}\)</span>, <span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span>, or <span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span>!</p>
<h1>Back to Designing <span class="math inline">\(U()\)</span></h1>
<p>Through our discussion up to this point, we’ve established that the universe of all possible <span class="math inline">\(MP\)</span>’s fall under three parity patterns: all honest odd (<span class="math inline">\(\mathrm{O}\)</span>) terms, or alternating between “honest” odd (<span class="math inline">\(\mathrm{O}\)</span>) and “fake” odd (<span class="math inline">\(\mathrm{O_F}\)</span>) terms. There are actually four patterns because the all-honest-odd-terms pattern can be broken down into two cases: (1) all terms are the same odd number (<span class="math inline">\(m = 0\)</span>), or (2) the terms are the same as those in <span class="math inline">\(AP\)</span> (i.e., <span class="math inline">\(AP\)</span> was all odd terms to begin with, so there was no actual mutation involved by applying <span class="math inline">\(M()\)</span>).</p>
<p>So, we can finally start sketching out the design for our “unmutate” function <span class="math inline">\(U()\)</span>.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/pseudocode.txt"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="sourceCode"><pre><code class="sourceCode"># Convert MP into a possible AP.
def unmutate(MP)
	if length(MP) &lt; 4
		return NULL (we need at least 4 values to calculate an AP)
	elsif every term in MP are the same
		return MP (no change)
	elsif MP is already an arithmetic sequence (MP = AP)
		return MP (no change)
	else
		1) Assume every 0th, 2nd, 4th, etc. term is &quot;honest&quot; and that the rest are
		&quot;fake&quot;; construct a tentative AP (call it BP) with the honest terms by
		taking the difference between these honest terms to find the rate of change
		*m*, and see if mutate(BP) = MP --- if so, then return BP.

		2) Otherwise, every 1st, 3rd, 5th, etc. term is &quot;honest&quot; --- so
		reconstruct BP, and check if mutate(AP) = MP (i.e., check that the
		dishonest terms from mutate(BP) are the same as those in the given MP).
		If the check fails, then we know that the input was not a true MP ---
		the original AP was not an arithmetic progression to begin with!
	end
end

# Convert AP into MP
def mutate(AP)
	MP = []
	for every term &#39;a&#39; in AP:
		MP.insert(make_odd(a))
	end
end

# Divide an integer n by 2 until it becomes odd. The edge case is when n is 0,
# because dividing by 2 repeatedly does not change its parity.
def make_odd(n)
	if n is odd or n is 0
		return n
	else
		return (make_odd(n/2))
	end
end</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/pseudocode.txt"  mimetype=text/plain > pseudocode.txt </a>
</div>
</div>
<p>The interesting point is in line 18; thanks to our math work, we can even declare that a given mutated sequence was somehow either tampered with, or that the original sequence was not an arithmetic progression! We can make these assertions because we’ve exhausted all possible cases of arithmetic sequences and their mutations — and if things don’t fit the way we expect them to, then the only conclusion is that the given sequence <span class="math inline">\(MP\)</span> was not a byproduct of mutating an <em>arithmetic sequence</em>, but some other kind of sequence. Behold the power of math!</p>
<p>The other thing is that in line 34 we allow <span class="math inline">\(0\)</span> as a possible value in <span class="math inline">\(AP\)</span>. This means that after a mutation, we might still have an even number (<span class="math inline">\(0\)</span>) in <span class="math inline">\(MP\)</span>! Although this sounds like it would break all of the mathematic discussion we’ve had so far, it does not — the proof is in the Haskell code below. The short answer is that a <span class="math inline">\(0\)</span> is harmless because it shares the same quality — immutability — with all other originally odd terms in <span class="math inline">\(AP\)</span>; thus, treating it as an “odd” number does not change our logic.</p>
<h1>Haskell version</h1>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/Unmutate.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Unmutate</span> <span class="kw">where</span>

<span class="co">-- Convert mutated numbers back into an arithmetic progression (if possible).</span>
<span class="ot">unmutate ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]
unmutate ts
	<span class="co">-- The input must be at least 4 terms!</span>
	<span class="fu">|</span> length ts <span class="fu">&lt;</span> <span class="dv">4</span> <span class="fu">=</span> <span class="dt">Nothing</span>
	<span class="fu">|</span> all (<span class="fu">==</span>t) ts <span class="fu">=</span> <span class="dt">Just</span> ts
	<span class="fu">|</span> isArithmetic ts <span class="fu">=</span> <span class="dt">Just</span> ts
	<span class="fu">|</span> mutate bp1 <span class="fu">==</span> ts <span class="fu">=</span> <span class="dt">Just</span> bp1
	<span class="fu">|</span> mutate bp2 <span class="fu">==</span> ts <span class="fu">=</span> <span class="dt">Just</span> bp2
	<span class="co">-- Could optionally raise an error saying ts was not derived from an</span>
	<span class="co">-- arithmetic progression in the first place!</span>
	<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>
	<span class="kw">where</span>
	t <span class="fu">=</span> head ts
	<span class="co">-- O_F, O, O_F, O...</span>
	bp1Terms <span class="fu">=</span> everyNth0 <span class="dv">2</span> ts
	bp1 <span class="fu">=</span> makeBP (length ts) <span class="dt">False</span> bp1Terms
	<span class="co">-- O, O_F, O, O_F...</span>
	bp2Terms <span class="fu">=</span> everyNth <span class="dv">2</span> ts
	bp2 <span class="fu">=</span> makeBP (length ts) <span class="dt">True</span> bp2Terms

<span class="co">-- Create a tentative arithmetic progression &quot;BP&quot; from the given arguments. The</span>
<span class="co">-- `makeFirstTerm` boolean determines whether we are dealing with a &quot;O_F, O,</span>
<span class="co">-- O_F, O...&quot; or a &quot;O, O_F, O, O_F&quot; pattern.</span>
<span class="ot">makeBP ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
makeBP len makeFirstTerm originals
	<span class="fu">|</span> length originals <span class="fu">&lt;</span> <span class="dv">2</span> <span class="fu">=</span> []
	<span class="fu">|</span> makeFirstTerm <span class="fu">=</span> (o0 <span class="fu">-</span> m) <span class="fu">:</span> init bp
	<span class="fu">|</span> otherwise <span class="fu">=</span> bp
	<span class="kw">where</span>
	o0 <span class="fu">=</span> originals<span class="fu">!!</span><span class="dv">0</span>
	o1 <span class="fu">=</span> originals<span class="fu">!!</span><span class="dv">1</span>
	m <span class="fu">=</span> div (o1 <span class="fu">-</span> o0) <span class="dv">2</span>
	bp <span class="fu">=</span> reverse
		<span class="fu">.</span> foldl (\acc n <span class="ot">-&gt;</span> (m<span class="fu">*</span>n <span class="fu">+</span> o0)<span class="fu">:</span>acc) []
		<span class="fu">$</span> take len [<span class="dv">0</span><span class="fu">..</span>]

<span class="ot">isArithmetic ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isArithmetic ts
	<span class="co">-- A progression (before we even get to whether it is arithmetic) must have</span>
	<span class="co">-- at least 2 terms in it.</span>
	<span class="fu">|</span> length ts <span class="fu">&lt;</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">False</span>
	<span class="fu">|</span> otherwise <span class="fu">=</span> all (<span class="fu">==</span>m) <span class="fu">$</span> zipWith (<span class="fu">-</span>) (tail ts) (init ts)
	<span class="kw">where</span>
	t0 <span class="fu">=</span> ts<span class="fu">!!</span><span class="dv">0</span>
	t1 <span class="fu">=</span> ts<span class="fu">!!</span><span class="dv">1</span>
	m <span class="fu">=</span> t1 <span class="fu">-</span> t0

<span class="ot">mutate ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
mutate <span class="fu">=</span> map makeOdd
	<span class="kw">where</span>
<span class="ot">	makeOdd ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
	makeOdd n
		<span class="co">-- 0 cannot be turned into an odd number! Keep it as is.</span>
		<span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
		<span class="fu">|</span> odd n <span class="fu">=</span> n
		<span class="fu">|</span> otherwise <span class="fu">=</span> makeOdd <span class="fu">$</span> div n <span class="dv">2</span>

<span class="co">-- Given a list of &#39;a&#39;s, return the elements at indices [0n, 1n, 2n, 3n, ...].</span>
<span class="co">-- E.g., given a list [0..] and n = 2, we get [0, 2, 4, 6..]. From</span>
<span class="co">-- http://stackoverflow.com/a/2028758/437583.</span>
<span class="ot">everyNth0 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
everyNth0 _ [] <span class="fu">=</span> []
everyNth0 n as <span class="fu">=</span> head as <span class="fu">:</span> everyNth0 n (drop n as)

<span class="co">-- Same as `everyNth0`, but start at the nth element. E.g., given a list [0..]</span>
<span class="co">-- and n = 2, we get [1, 3, 5, 7..].</span>
<span class="ot">everyNth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
everyNth n <span class="fu">=</span> everyNth0 n <span class="fu">.</span> drop (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/Unmutate.hs"  mimetype=text/plain > Unmutate.hs </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/test-unmutate.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span>

<span class="kw">import </span><span class="dt">Unmutate</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain tests

<span class="ot">tests ::</span> <span class="dt">TestTree</span>
tests <span class="fu">=</span> testGroup <span class="st">&quot;Tests&quot;</span> [qcProps, unitTests]

<span class="kw">data</span> <span class="dt">AP</span> <span class="fu">=</span> <span class="dt">AP</span> [<span class="dt">Integer</span>]
	<span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- Generate a random arithmetic progression.</span>
<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">AP</span> <span class="kw">where</span>
	arbitrary <span class="fu">=</span> <span class="kw">do</span>
		<span class="co">-- Choose random m (change between terms).</span>
		m <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Int</span>
		<span class="co">-- Choose random first term. It&#39;s important that we make it into an</span>
		<span class="co">-- Integer type, because if we use Int we might end up with integer</span>
		<span class="co">-- overflow if m is too large.</span>
		t <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Integer</span>
		<span class="co">-- Choose random length of 4 to 50.</span>
		len <span class="ot">&lt;-</span> choose (<span class="dv">4</span>, <span class="dv">50</span>)
		return
			<span class="fu">.</span> <span class="dt">AP</span>
			<span class="fu">.</span> foldl (\acc n <span class="ot">-&gt;</span> ((fromIntegral m)<span class="fu">*</span>n <span class="fu">+</span> t)<span class="fu">:</span>acc) []
			<span class="fu">$</span> take len [<span class="dv">0</span><span class="fu">..</span>]

<span class="ot">qcProps ::</span> <span class="dt">TestTree</span>
qcProps <span class="fu">=</span> testGroup <span class="st">&quot;(checked by QuickCheck)&quot;</span>
	[ QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in calculable (isJust))&quot;</span>
		(\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> isJust <span class="fu">.</span> unmutate <span class="fu">$</span> mutate ts)
	, QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in a nonempty list)&quot;</span>
		(\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> not
			<span class="fu">.</span> null
			<span class="fu">.</span> fromJust
			<span class="fu">.</span> unmutate
			<span class="fu">$</span> mutate ts)
	, QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in an arithmetic progression)&quot;</span>
		(\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> isArithmetic
			<span class="fu">.</span> fromJust
			<span class="fu">.</span> unmutate
			<span class="fu">$</span> mutate ts)
	]

<span class="ot">unitTests ::</span> <span class="dt">TestTree</span>
unitTests <span class="fu">=</span> testGroup <span class="st">&quot;Unit tests&quot;</span>
	[ testCase <span class="st">&quot;Unmutate (empty list is not calculable)&quot;</span>
		<span class="fu">$</span> unmutate ([]<span class="ot">::</span>[<span class="dt">Int</span>])
		<span class="fu">@?=</span> <span class="dt">Nothing</span>
	, testCase <span class="st">&quot;Unmutate (AP is all odd, so AP == MP)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (m = 0, so all elements in mp are the same)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 1)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 2)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">7</span>, <span class="dv">47</span>, <span class="dv">5</span>, <span class="dv">113</span>, <span class="dv">73</span>, <span class="dv">179</span>, <span class="dv">53</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">14</span>, <span class="dv">47</span>, <span class="dv">80</span>, <span class="dv">113</span>, <span class="dv">146</span>, <span class="dv">179</span>, <span class="dv">212</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 3)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">749</span>, <span class="dv">999</span>, <span class="dv">125</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">1498</span>, <span class="dv">999</span>, <span class="dv">500</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 4)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="fu">-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">33</span>, <span class="dv">11</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="fu">-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>, <span class="dv">44</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	]</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/test-unmutate.hs"  mimetype=text/plain > test-unmutate.hs </a>
</div>
</div>
<p>As you can see, most of the real work involves identifying the <strong>original, immutable numbers</strong> we can work with as-is (<span class="math inline">\(\mathrm{O}\)</span>) (as opposed to the ones we have to ignore (<span class="math inline">\(\mathrm{O_F}\)</span>)) to construct our tentative sister arithmetic progression <span class="math inline">\(BP\)</span>.</p>
<h1>Ruby version</h1>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/unmutate.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Unmutate</span>
  <span class="kw">def</span> <span class="dt">Unmutate</span>.unmutate(ts)
    <span class="kw">if</span> ts.size &lt; <span class="dv">4</span>
      <span class="kw">return</span> <span class="dv">nil</span>
    <span class="kw">end</span>

    bp1_terms = every_nth0(<span class="dv">2</span>, ts)
    bp1 = make_BP(ts.size, <span class="dv">false</span>, bp1_terms)
    bp2_terms = every_nth(<span class="dv">2</span>, ts)
    bp2 = make_BP(ts.size, <span class="dv">true</span>, bp2_terms)

    <span class="kw">if</span> ts.uniq.size == <span class="dv">1</span>
      ts
    <span class="kw">elsif</span> <span class="dt">Unmutate</span>.arithmetic?(ts)
      ts
    <span class="kw">elsif</span> <span class="dt">Unmutate</span>.mutate(bp1) == ts
      bp1
    <span class="kw">elsif</span> <span class="dt">Unmutate</span>.mutate(bp2) == ts
      bp2
    <span class="kw">else</span>
      <span class="dv">nil</span>
    <span class="kw">end</span>
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">Unmutate</span>.make_BP(len, make_first_term, originals)
    <span class="kw">if</span> originals.size &lt; <span class="dv">2</span>
      <span class="kw">return</span> []
    <span class="kw">end</span>

    o0 = originals[<span class="dv">0</span>]
    o1 = originals[<span class="dv">1</span>]
    m = (o1 - o0) / <span class="dv">2</span>
    bp = []

    <span class="kw">for</span> n <span class="kw">in</span> (<span class="dv">0</span>..(len - <span class="dv">1</span>)) <span class="kw">do</span>
      bp &lt;&lt; m*n + o0
    <span class="kw">end</span>

    <span class="kw">if</span> make_first_term
      [o0 - m] + bp.take(len - <span class="dv">1</span>)
    <span class="kw">else</span>
      bp
    <span class="kw">end</span>
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">Unmutate</span>.mutate(ts)
    ts.map{|t| make_odd t}
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">Unmutate</span>.arithmetic?(ts)
    <span class="kw">if</span> ts.size &lt; <span class="dv">2</span>
      <span class="kw">return</span> <span class="dv">false</span>
    <span class="kw">end</span>

    m = ts[<span class="dv">1</span>] - ts[<span class="dv">0</span>]
    ms = ts.drop(<span class="dv">1</span>).zip(ts.take(ts.size - <span class="dv">1</span>))

    ms.each <span class="kw">do</span> |t1, t0|
      <span class="kw">if</span> (t1 - t0) != m
        <span class="kw">return</span> <span class="dv">false</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    <span class="dv">true</span>
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> make_odd(t)
  <span class="kw">if</span> t.odd? || t == <span class="dv">0</span>
    t
  <span class="kw">else</span>
    make_odd(t/<span class="dv">2</span>)
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> every_nth0(n, ts)
  arr = []
  <span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">0</span>..(ts.size - <span class="dv">1</span>)) <span class="kw">do</span>
    <span class="kw">if</span> i % n == <span class="dv">0</span>
      arr &lt;&lt; ts[i]
    <span class="kw">end</span>
  <span class="kw">end</span>
  arr
<span class="kw">end</span>

<span class="kw">def</span> every_nth(n, ts)
  arr = []
  <span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">0</span>..(ts.size - <span class="dv">1</span>)) <span class="kw">do</span>
    <span class="kw">if</span> (i + <span class="dv">1</span>) % n == <span class="dv">0</span>
      arr &lt;&lt; ts[i]
    <span class="kw">end</span>
  <span class="kw">end</span>
  arr
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/unmutate.rb"  mimetype=text/plain > unmutate.rb </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/test-unmutate.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="co"># Usage: ruby test-unmutate.rb</span>

require <span class="st">&#39;minitest/autorun&#39;</span>
require_relative <span class="st">&#39;./unmutate.rb&#39;</span>

<span class="kw">class</span> <span class="dt">TestUnmutate</span> &lt; <span class="dt">Minitest</span>::<span class="dt">Test</span>
  <span class="kw">def</span> test_empty_list_incalculable
    assert_equal <span class="dv">nil</span>, <span class="dt">Unmutate</span>.unmutate([])
  <span class="kw">end</span>

  <span class="kw">def</span> test_all_odd_no_change
    assert_equal [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_m_is_0
    assert_equal [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_1
    assert_equal [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">5</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_2
    assert_equal [<span class="dv">14</span>, <span class="dv">47</span>, <span class="dv">80</span>, <span class="dv">113</span>, <span class="dv">146</span>, <span class="dv">179</span>, <span class="dv">212</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">7</span>, <span class="dv">47</span>, <span class="dv">5</span>, <span class="dv">113</span>, <span class="dv">73</span>, <span class="dv">179</span>, <span class="dv">53</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_3
    assert_equal [<span class="dv">1498</span>, <span class="dv">999</span>, <span class="dv">500</span>, <span class="dv">1</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">749</span>, <span class="dv">999</span>, <span class="dv">125</span>, <span class="dv">1</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_4
    assert_equal [-<span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>, <span class="dv">44</span>],
      <span class="dt">Unmutate</span>.unmutate([-<span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">33</span>, <span class="dv">11</span>])
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/test-unmutate.rb"  mimetype=text/plain > test-unmutate.rb </a>
</div>
</div>
<p>This Ruby version is essentially a port of the Haskell version. The problem at hand is so mathematical that it makes sense to simply preserve the clean Haskell definitions.</p>
<h1>Conclusion</h1>
<p>I hope you enjoyed this somewhat prolonged mathematical adventure. The most interesting part for me was seeing the problem as a linear equation, and using the formula (which I learned in high school) to derive powerful conclusions. High school algebra is useful after all! Until next time, happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>Programming Puzzles: Letter and Word Frequency</title>
    <link href="http://listx.github.io/post/2015-04-22-letter-word-frequency.html" />
    <id>http://listx.github.io/post/2015-04-22-letter-word-frequency.html</id>
    <published>2015-04-22T00:00:00Z</published>
    <updated>2015-04-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-04-22</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-04-22-letter-word-frequency.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/ruby.html">ruby</a>
</div>

<h2 id="motivation">Motivation</h2>
<p>I recently purchased an ErgoDox keyboard<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, and I’ve been thinking about creating my own keyboard layout in the spirit of the Dvorak Simplified Keyboard layout (DSK). One of the guiding principles of DSK was putting an emphasis on reducing finger travel by identifying the most commonly occurring letters of the English language, and placing them on the home row of the keyboard. Now, the Dvorak layout was patented in 1936 according to Wikipedia, with subsequent adjustments culminating in the present form of DSK.</p>
<p>I want to find out for myself what letters are the most common. Sure, I could blindly trust an online source like Wikipedia, but it just feels like an easy problem to solve. Also, I am not sure if Dvorak considered <em>word</em> frequency as well as <em>letter</em> frequency. Ideally, one should use the data of both word and letter frequency to determine what is the most commonly typed “letter” on a US ASCII keyboard for English writers.</p>
<h2 id="the-problems">The Problems</h2>
<h3 id="letter-frequency">Letter Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each letter occurs in the file. You must treat <code>A</code> as the same letter as <code>a</code>. You may limit yourself to the plain US ASCII 26-letter alphabet, discarding all letters with diacritics. Sort the letters by their frequence; for each letter, display the letter itself, its relative frequency percentage to the file as a whole, and the number of times this letter appears (raw count). E.g., the letter <code>a</code> counted by this program might look like this: <code>a = 2.00% (200 occurrences)</code>.</p>
<h3 id="word-frequency">Word Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each <em>word</em> occurs in the file. The precise definition of a “word” is up to you, but you must exclude arabic numerals and also standalone punctuation characters (e.g., “* is not a word”). Display the 100 most common words in similar fashion to the Letter Frequency problem.</p>
<p>Both the letter and word frequency problems will use the Project Gutenberg plaintext file of <a href="http://www.gutenberg.org/cache/epub/2701/pg2701.txt"><em>Moby Dick</em></a>.</p>
<p>Now, before you go on to read my solutions, I encourage you to write a solution on your own using your favorite programming language.</p>
<h2 id="ruby-version">Ruby Version</h2>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/text_freq.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">TextFreq</span>
  <span class="co"># Given a string, count every occurrence of letters a-z (case insensitively).</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_l(src)
    <span class="co"># Construct the array to hold the running totals (occurrences) of each</span>
    <span class="co"># letter. There are 26 letters in the alphabet, so we can just have an array</span>
    <span class="co"># of 26 integers.</span>
    occs = <span class="dt">Array</span>.new(<span class="dv">26</span>, <span class="dv">0</span>)

    <span class="co"># Count occurrences of each letter.</span>
    src.each_char <span class="kw">do</span> |c|
      <span class="kw">if</span> !char_to_idx(c.downcase).nil?
        occs[char_to_idx(c.downcase)] += <span class="dv">1</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    occs
  <span class="kw">end</span>

  <span class="co"># Simply check if the given character belongs to the range of lowercase ASCII</span>
  <span class="co"># characters that make up the alphabet. &quot;a&quot; is 97, and &quot;z&quot; is 122; the numbers</span>
  <span class="co"># for bounds-checking &quot;c&quot; come from these two (offset by 1 to account for the</span>
  <span class="co"># exclusive comparison).</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.char_to_idx(c)
    <span class="dv">96</span> &lt; c.ord &amp;&amp; c.ord &lt; <span class="dv">123</span> ? c.ord - <span class="dv">97</span> : <span class="dv">nil</span>
  <span class="kw">end</span>

  <span class="co"># Given a string, count every occurrence of a particular word. We define a</span>
  <span class="co"># &quot;word&quot; as a sequence of charactes that</span>
  <span class="co">#   - does not have any punctuation characters at the beginning or end, and</span>
  <span class="co">#   - does not have any numbers in it</span>
  <span class="co"># . We take into account that text files from Project Gutenberg use a double</span>
  <span class="co"># dash for an em dash to separate two words.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_w(src)
    occs = {}
    words = src.split(<span class="ot">/\W*\s\W*/</span>).map <span class="kw">do</span> |w|
        w.empty? ? <span class="dv">nil</span> : w.downcase
      <span class="kw">end</span>.compact
    words.each <span class="kw">do</span> |w|
      <span class="co"># Guard against cases like &quot;*&quot; for bullet points and such.</span>
      <span class="kw">if</span> w =~ <span class="ot">/\w/</span>
        <span class="kw">if</span> w =~ <span class="ot">/--/</span>
          w.split(<span class="st">&quot;--&quot;</span>).each <span class="kw">do</span> |y|
            count_word(occs, lstrip_punc(y))
          <span class="kw">end</span>
        <span class="kw">else</span>
          count_word(occs, lstrip_punc(w))
        <span class="kw">end</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    occs
  <span class="kw">end</span>

  <span class="co"># Add 1 to the hash for an existing key (word); otherwise, store a new</span>
  <span class="co"># instance of that word.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.count_word(hash, w)
    hash.key?(w) ? hash[w] += <span class="dv">1</span> : hash.store(w, <span class="dv">1</span>)
    hash
  <span class="kw">end</span>

  <span class="co"># Remove leading punctuation.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.lstrip_punc(w)
    w.match(<span class="ot">/\w.*/</span>)[<span class="dv">0</span>]
  <span class="kw">end</span>

  <span class="co"># Display the frequencies of letters and or words. For letters, we are only</span>
  <span class="co"># concerned about 26 different values, so we print all of them out. However</span>
  <span class="co"># for words, depending on the corpus there might be thousands, or even</span>
  <span class="co"># millions, of different words; thus, we only display the top 100 most common</span>
  <span class="co"># words.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.disp_freq(occs)
    <span class="kw">if</span> occs.is_a?(<span class="dt">Array</span>)
      sum = occs.inject(<span class="dv">0</span>, :+)
      occs.zip((<span class="st">&quot;a&quot;</span>..<span class="st">&quot;z&quot;</span>).to_a).sort.reverse.each <span class="kw">do</span> |cnt, c|
        puts <span class="st">&quot;</span><span class="ot">#{</span>c<span class="ot">}</span><span class="st"> = &quot;</span>\
          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\
          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span>
      <span class="kw">end</span>
    <span class="kw">else</span>
      sum = occs.values.inject(<span class="dv">0</span>, :+)
      occs.sort_by {|w, cnt| cnt}.reverse.take(<span class="dv">100</span>).each <span class="kw">do</span> |w, cnt|
        puts <span class="st">&quot;</span><span class="ot">#{</span>w<span class="ot">}</span><span class="st"> = &quot;</span>\
          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\
          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span>
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/text_freq.rb"  mimetype=text/plain > text_freq.rb </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/analyze.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">#!/usr/bin/env ruby</span>

require_relative <span class="st">&#39;./text_freq&#39;</span>

fname = <span class="dt">ARGV</span>[<span class="dv">0</span>]
file = <span class="dt">File</span>.open(fname, <span class="st">&#39;r:utf-8&#39;</span>)
corpus = file.read

occs_l = <span class="dt">TextFreq</span>.freq_l(corpus)
<span class="dt">TextFreq</span>.disp_freq(occs_l)

puts <span class="st">&quot;-&quot;</span> * <span class="dv">80</span>

occs_w = <span class="dt">TextFreq</span>.freq_w(corpus)
<span class="dt">TextFreq</span>.disp_freq(occs_w)

file.close</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/analyze.rb"  mimetype=text/plain > analyze.rb </a>
</div>
</div>
<p>And here is the output (<code>pg2701.txt</code> is <em>Moby Dick</em>):</p>
<pre><code>$ ./analyze.rb ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.74% (14616 occurrences)
of = 3.10% (6708 occurrences)
and = 2.99% (6488 occurrences)
a = 2.20% (4760 occurrences)
to = 2.16% (4677 occurrences)
in = 1.95% (4223 occurrences)
that = 1.38% (2999 occurrences)
his = 1.17% (2530 occurrences)
it = 1.12% (2419 occurrences)
i = 0.92% (1988 occurrences)
but = 0.84% (1823 occurrences)
he = 0.82% (1777 occurrences)
with = 0.82% (1770 occurrences)
as = 0.81% (1751 occurrences)
is = 0.81% (1747 occurrences)
for = 0.76% (1645 occurrences)
was = 0.76% (1645 occurrences)
all = 0.70% (1523 occurrences)
this = 0.66% (1440 occurrences)
at = 0.62% (1334 occurrences)
by = 0.56% (1223 occurrences)
not = 0.54% (1169 occurrences)
from = 0.51% (1105 occurrences)
on = 0.49% (1069 occurrences)
him = 0.49% (1062 occurrences)
so = 0.49% (1061 occurrences)
be = 0.49% (1060 occurrences)
whale = 0.45% (972 occurrences)
you = 0.44% (944 occurrences)
one = 0.42% (906 occurrences)
or = 0.37% (797 occurrences)
there = 0.37% (792 occurrences)
now = 0.36% (779 occurrences)
had = 0.36% (779 occurrences)
have = 0.36% (772 occurrences)
were = 0.32% (683 occurrences)
they = 0.31% (664 occurrences)
which = 0.30% (655 occurrences)
then = 0.29% (628 occurrences)
me = 0.29% (621 occurrences)
their = 0.29% (620 occurrences)
are = 0.29% (619 occurrences)
some = 0.29% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.28% (600 occurrences)
no = 0.27% (594 occurrences)
my = 0.27% (589 occurrences)
like = 0.27% (581 occurrences)
upon = 0.26% (567 occurrences)
what = 0.26% (566 occurrences)
out = 0.24% (528 occurrences)
into = 0.24% (523 occurrences)
up = 0.24% (516 occurrences)
more = 0.23% (506 occurrences)
if = 0.23% (500 occurrences)
them = 0.22% (471 occurrences)
we = 0.21% (455 occurrences)
man = 0.21% (445 occurrences)
old = 0.20% (444 occurrences)
ahab = 0.20% (432 occurrences)
ye = 0.20% (428 occurrences)
would = 0.20% (428 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
these = 0.19% (405 occurrences)
over = 0.19% (403 occurrences)
will = 0.18% (396 occurrences)
ship = 0.18% (391 occurrences)
though = 0.18% (383 occurrences)
sea = 0.18% (382 occurrences)
its = 0.18% (382 occurrences)
only = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
down = 0.17% (367 occurrences)
any = 0.17% (363 occurrences)
who = 0.16% (345 occurrences)
yet = 0.16% (344 occurrences)
her = 0.15% (329 occurrences)
time = 0.15% (326 occurrences)
very = 0.15% (323 occurrences)
do = 0.15% (321 occurrences)
long = 0.15% (319 occurrences)
about = 0.15% (318 occurrences)
than = 0.14% (311 occurrences)
still = 0.14% (311 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (303 occurrences)
said = 0.14% (301 occurrences)
captain = 0.14% (300 occurrences)
before = 0.14% (300 occurrences)
here = 0.14% (299 occurrences)
has = 0.14% (294 occurrences)
must = 0.13% (292 occurrences)
two = 0.13% (288 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
last = 0.13% (276 occurrences)
head = 0.13% (275 occurrences)
see = 0.12% (268 occurrences)
thou = 0.12% (267 occurrences)</code></pre>
<p>. The file of course contains remarks and legalese from Project Gutenberg, so if you want more accuracy you would have to redact those parts before running this script.</p>
<h3 id="letter-frequency-1">Letter Frequency</h3>
<p>The <code>freq_l</code> method views letters in the limited US ASCII range and uses crude, C-like letter-to-integer equivalence via <code>char_to_idx</code>. We use a simple array of 26 integers, each one corresponding to a letter. But thanks to its stupidity, <code>freq_l</code> runs quite fast — chugging through Moby Dick in a few seconds on my Core i7-4770K 4GHz machine.</p>
<h3 id="word-frequency-1">Word Frequency</h3>
<p>The <code>freq_w</code> method relies almost entirely on a single regex, <code>/\W*\s\W*/</code>, to split the input into words. These words are further processed; we perform a basic sanity check with the <code>/\w/</code> regex to make sure we are not dealing with just numbers or punctuation, and we also take into account the em dash <code>--</code>. We use a basic hash structure to store the words as keys, and their counts as values.</p>
<h2 id="haskell-version">Haskell Version</h2>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/TextFreq.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">TextFreq</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>
<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Data.Ord</span> (comparing)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import qualified</span> <span class="dt">Text.Printf</span> <span class="kw">as</span> <span class="dt">TP</span>

<span class="kw">type</span> <span class="dt">LHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Char</span> <span class="dt">Word64</span>

<span class="kw">type</span> <span class="dt">WProto</span> <span class="fu">=</span> <span class="dt">T.Text</span>
<span class="kw">type</span> <span class="dt">WHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">WProto</span> <span class="dt">Word64</span>
<span class="kw">data</span> <span class="dt">WFSM</span>
	<span class="fu">=</span> <span class="dt">WordIn</span>
	<span class="fu">|</span> <span class="dt">WordOutMaybe</span>
	<span class="fu">|</span> <span class="dt">WordOut</span>
	<span class="kw">deriving</span> (<span class="dt">Eq</span>)
<span class="kw">data</span> <span class="dt">WBuild</span> <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WFSM</span> <span class="dt">WProto</span> <span class="dt">WHash</span>

<span class="ot">freqL ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">LHash</span>
freqL <span class="fu">=</span> T.foldl step occs
	<span class="kw">where</span>
	occs <span class="fu">=</span> M.empty
	step lhash c
		<span class="fu">|</span> isAlpha c <span class="fu">=</span> M.insertWith (<span class="fu">+</span>) (toLower c) <span class="dv">1</span> lhash
		<span class="fu">|</span> otherwise <span class="fu">=</span> lhash

<span class="ot">freqW ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">WHash</span>
freqW <span class="fu">=</span> (\(<span class="dt">WBuild</span> _ _ whash) <span class="ot">-&gt;</span> whash) <span class="fu">.</span> T.foldl step occs
	<span class="kw">where</span>
	<span class="co">-- Use WordOut as the initial state for WFSM, because we&#39;re starting from</span>
	<span class="co">-- nothing!</span>
<span class="ot">	occs ::</span> <span class="dt">WBuild</span>
	occs <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty M.empty
	step wb<span class="fu">@</span>(<span class="dt">WBuild</span> wfsm wproto whash) c
		<span class="co">-- Letter.</span>
		<span class="fu">|</span> isAlpha c <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- This is when we first encounter a letter.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.singleton c&#39;) whash
			_ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.snoc wproto c&#39;) whash
		<span class="co">-- Apostrophe. We ignore all leading apostrophes and only store</span>
		<span class="co">-- apostrophes at the end of a word, such as &quot;goin&#39;&quot;.</span>
		<span class="fu">|</span> c <span class="fu">==</span> <span class="ch">&#39;\&#39;&#39;</span> <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- This is when we encounter an apostrophe either at the middle or</span>
			<span class="co">-- end of a word.</span>
			<span class="dt">WordIn</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOutMaybe</span> (T.snoc wproto c&#39;) whash
			<span class="co">-- E.g., &quot;goin&#39;&#39;&quot; (a contracted &quot;goin&#39;&#39;&quot; ending with a nested inner</span>
			<span class="co">-- quote). We store it as &quot;goin&#39;&quot;.</span>
			<span class="dt">WordOutMaybe</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty
				<span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash
			<span class="co">-- Already out of a word area, such as a space character. We do</span>
			<span class="co">-- nothing.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb
		<span class="co">-- If we&#39;re looking at neither a letter nor an apostrophe.</span>
		<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- A series of nonsense chars; ignore.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb
			<span class="co">-- End of a word.</span>
			_ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty
				<span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash
		<span class="kw">where</span>
		c&#39; <span class="fu">=</span> toLower c

<span class="ot">dispFreqL ::</span> <span class="dt">LHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dispFreqL lhash <span class="fu">=</span> mapM_ f <span class="fu">.</span> reverse <span class="fu">.</span> sortBy (comparing snd) <span class="fu">$</span> M.toList lhash
	<span class="kw">where</span>
<span class="ot">	total ::</span> <span class="dt">Word64</span>
	total <span class="fu">=</span> sum <span class="fu">$</span> M.elems lhash
<span class="ot">	f ::</span> (<span class="dt">Char</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
	f (c, n) <span class="fu">=</span> putStrLn <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3
		<span class="kw">where</span>
<span class="ot">		perc ::</span> <span class="dt">Double</span>
		perc
			<span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
			<span class="fu">|</span> otherwise <span class="fu">=</span> (fromIntegral n) <span class="fu">/</span> (fromIntegral total) <span class="fu">*</span> <span class="dv">100</span>
		msg1 <span class="fu">=</span> [c] <span class="fu">++</span> <span class="st">&quot; = &quot;</span>
		msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc
		msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span>

<span class="ot">dispFreqW ::</span> <span class="dt">WHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dispFreqW whash <span class="fu">=</span> mapM_ f <span class="fu">.</span> take <span class="dv">100</span> <span class="fu">.</span> reverse <span class="fu">.</span> sortBy (comparing snd) <span class="fu">$</span> M.toList whash
	<span class="kw">where</span>
<span class="ot">	total ::</span> <span class="dt">Word64</span>
	total <span class="fu">=</span> sum <span class="fu">$</span> M.elems whash
<span class="ot">	f ::</span> (<span class="dt">WProto</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
	f (w, n) <span class="fu">=</span> putStrLn <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3
		<span class="kw">where</span>
<span class="ot">		perc ::</span> <span class="dt">Double</span>
		perc
			<span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
			<span class="fu">|</span> otherwise <span class="fu">=</span> (fromIntegral n) <span class="fu">/</span> (fromIntegral total) <span class="fu">*</span> <span class="dv">100</span>
		msg1 <span class="fu">=</span> T.unpack w <span class="fu">++</span> <span class="st">&quot; = &quot;</span>
		msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc
		msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/TextFreq.hs"  mimetype=text/plain > TextFreq.hs </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/analyze.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">System.Environment</span>

<span class="kw">import </span><span class="dt">TextFreq</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
	args <span class="ot">&lt;-</span> getArgs
	src <span class="ot">&lt;-</span> T.readFile <span class="fu">$</span> args<span class="fu">!!</span><span class="dv">0</span>
	dispFreqL <span class="fu">$</span> freqL src
	putStrLn <span class="fu">$</span> replicate <span class="dv">80</span> <span class="ch">&#39;-&#39;</span>
	dispFreqW <span class="fu">$</span> freqW src</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/analyze.hs"  mimetype=text/plain > analyze.hs </a>
</div>
</div>
<p>Here is the same run against our copy of <em>Moby Dick</em>:</p>
<pre><code>$ ./analyze ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.67% (14620 occurrences)
of = 3.07% (6732 occurrences)
and = 2.97% (6502 occurrences)
a = 2.18% (4788 occurrences)
to = 2.15% (4706 occurrences)
in = 1.93% (4231 occurrences)
that = 1.37% (3005 occurrences)
his = 1.15% (2530 occurrences)
it = 1.11% (2434 occurrences)
i = 0.91% (1993 occurrences)
but = 0.83% (1823 occurrences)
he = 0.81% (1780 occurrences)
with = 0.81% (1770 occurrences)
as = 0.80% (1752 occurrences)
is = 0.80% (1748 occurrences)
was = 0.75% (1646 occurrences)
for = 0.75% (1646 occurrences)
all = 0.70% (1543 occurrences)
this = 0.66% (1443 occurrences)
at = 0.61% (1335 occurrences)
by = 0.56% (1226 occurrences)
not = 0.53% (1171 occurrences)
whale = 0.51% (1108 occurrences)
from = 0.50% (1105 occurrences)
on = 0.49% (1073 occurrences)
him = 0.49% (1067 occurrences)
so = 0.49% (1066 occurrences)
be = 0.49% (1064 occurrences)
you = 0.43% (946 occurrences)
one = 0.42% (914 occurrences)
there = 0.37% (805 occurrences)
or = 0.36% (797 occurrences)
now = 0.36% (783 occurrences)
had = 0.36% (779 occurrences)
have = 0.35% (773 occurrences)
were = 0.31% (683 occurrences)
they = 0.30% (664 occurrences)
which = 0.30% (655 occurrences)
like = 0.30% (647 occurrences)
me = 0.29% (632 occurrences)
then = 0.29% (630 occurrences)
their = 0.28% (620 occurrences)
some = 0.28% (619 occurrences)
are = 0.28% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.27% (600 occurrences)
no = 0.27% (596 occurrences)
my = 0.27% (589 occurrences)
upon = 0.26% (568 occurrences)
what = 0.26% (566 occurrences)
out = 0.25% (539 occurrences)
up = 0.24% (524 occurrences)
into = 0.24% (523 occurrences)
more = 0.23% (508 occurrences)
if = 0.23% (501 occurrences)
man = 0.22% (476 occurrences)
them = 0.22% (474 occurrences)
we = 0.21% (455 occurrences)
sea = 0.21% (454 occurrences)
old = 0.21% (452 occurrences)
ship = 0.20% (438 occurrences)
ahab = 0.20% (436 occurrences)
ye = 0.20% (431 occurrences)
would = 0.20% (430 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
over = 0.19% (409 occurrences)
these = 0.19% (406 occurrences)
will = 0.18% (398 occurrences)
though = 0.18% (384 occurrences)
its = 0.17% (382 occurrences)
only = 0.17% (378 occurrences)
down = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
any = 0.17% (364 occurrences)
who = 0.16% (347 occurrences)
yet = 0.16% (345 occurrences)
head = 0.16% (344 occurrences)
time = 0.15% (334 occurrences)
long = 0.15% (334 occurrences)
her = 0.15% (332 occurrences)
do = 0.15% (324 occurrences)
very = 0.15% (323 occurrences)
about = 0.15% (318 occurrences)
still = 0.14% (312 occurrences)
than = 0.14% (311 occurrences)
captain = 0.14% (308 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (306 occurrences)
said = 0.14% (305 occurrences)
here = 0.14% (302 occurrences)
before = 0.14% (301 occurrences)
two = 0.14% (298 occurrences)
boat = 0.14% (297 occurrences)
has = 0.13% (294 occurrences)
must = 0.13% (293 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
white = 0.13% (281 occurrences)
last = 0.13% (278 occurrences)</code></pre>
<p>.</p>
<h3 id="letter-frequency-2">Letter Frequency</h3>
<p><code>freqL</code> handles letter frequency, and it is a simple <code>foldl</code> operation over the input, while using the <code>Map</code> data structure from the <code>Data.Map</code> library (which acts as a simple hash structure with keys and values). The de facto Haskell compiler GHC comes with the <code>base</code> library which includes the <code>Data.Char</code> module; unlike Ruby, we can simply ask whether a character is a letter with <code>isAlpha</code>, and then use <code>toLower</code> on it to convert it to lowercase. <code>freqL</code> owes its brevity to these standard library functions.</p>
<p>Thanks to these standard library functions, we can easily keep track of more than just the basic 26 alphabetical letters (although in the case of <em>Moby Dick</em>, there does not seem to be any such characters).</p>
<h3 id="word-frequency-2">Word Frequency</h3>
<p>This is probably a convoluted way to keep track of words. I did not opt for using regular expressions, because I wanted to try out a different approach instead of just translating the Ruby solution. I could have used the excellent Parsec library, but I just felt like rolling my own solution.</p>
<p><code>freqW</code> works by looking at just one character at a time, just like <code>freqL</code>. It also keeps track of the evaluation of the previously-looked-at character, with the <code>wfsm</code> variable (for <em>Word Finite State Machine</em>, a fancy but still pertinent name). <code>wfsm</code> can either say that the last character made us go <em>in</em> a word (<code>WordIn</code>), <em>out</em> of a word for sure (<code>WordOut</code>), or possibly out of a word (<code>WordOutMaybe</code>). Depending on the status of <code>wfsm</code> and the current character, <code>freqW</code> makes various choices.</p>
<p>Now, this mechanism isn’t without its warts. But still, I consider it somewhat elegant in its description of all possible states.</p>
<h2 id="a-diff">A Diff</h2>
<p>For fun, let’s look at the diff of the outputs of the Ruby and Haskell versions. Interestingly, the letter frequency outputs were identical. The word frequency outputs did have some significant changes, such as the word <em>whale</em> occurring 972 and 1108 times in the Ruby and Haskell versions, respectively. I’ve sorted the output by lines for saner diffing.</p>
<pre><code>$ diff -u routW houtW
--- routW	2015-04-22 22:01:59.061404962 -0700
+++ houtW	2015-04-22 22:02:57.679828155 -0700
@@ -1,100 +1,100 @@
-a = 2.20% (4760 occurrences)
+a = 2.18% (4788 occurrences)
 about = 0.15% (318 occurrences)
-ahab = 0.20% (432 occurrences)
-all = 0.70% (1523 occurrences)
-an = 0.28% (600 occurrences)
-and = 2.99% (6488 occurrences)
-any = 0.17% (363 occurrences)
-are = 0.29% (619 occurrences)
-as = 0.81% (1751 occurrences)
-at = 0.62% (1334 occurrences)
-be = 0.49% (1060 occurrences)
+ahab = 0.20% (436 occurrences)
+all = 0.70% (1543 occurrences)
+an = 0.27% (600 occurrences)
+and = 2.97% (6502 occurrences)
+any = 0.17% (364 occurrences)
+are = 0.28% (619 occurrences)
+as = 0.80% (1752 occurrences)
+at = 0.61% (1335 occurrences)
+be = 0.49% (1064 occurrences)
 been = 0.19% (415 occurrences)
-before = 0.14% (300 occurrences)
-but = 0.84% (1823 occurrences)
-by = 0.56% (1223 occurrences)
-captain = 0.14% (300 occurrences)
-do = 0.15% (321 occurrences)
-down = 0.17% (367 occurrences)
-for = 0.76% (1645 occurrences)
-from = 0.51% (1105 occurrences)
-great = 0.14% (303 occurrences)
+before = 0.14% (301 occurrences)
+boat = 0.14% (297 occurrences)
+but = 0.83% (1823 occurrences)
+by = 0.56% (1226 occurrences)
+captain = 0.14% (308 occurrences)
+do = 0.15% (324 occurrences)
+down = 0.17% (378 occurrences)
+for = 0.75% (1646 occurrences)
+from = 0.50% (1105 occurrences)
+great = 0.14% (306 occurrences)
 had = 0.36% (779 occurrences)
-has = 0.14% (294 occurrences)
-have = 0.36% (772 occurrences)
-he = 0.82% (1777 occurrences)
-head = 0.13% (275 occurrences)
-her = 0.15% (329 occurrences)
-here = 0.14% (299 occurrences)
-him = 0.49% (1062 occurrences)
-his = 1.17% (2530 occurrences)
-i = 0.92% (1988 occurrences)
-if = 0.23% (500 occurrences)
-in = 1.95% (4223 occurrences)
+has = 0.13% (294 occurrences)
+have = 0.35% (773 occurrences)
+he = 0.81% (1780 occurrences)
+head = 0.16% (344 occurrences)
+her = 0.15% (332 occurrences)
+here = 0.14% (302 occurrences)
+him = 0.49% (1067 occurrences)
+his = 1.15% (2530 occurrences)
+i = 0.91% (1993 occurrences)
+if = 0.23% (501 occurrences)
+in = 1.93% (4231 occurrences)
 into = 0.24% (523 occurrences)
-is = 0.81% (1747 occurrences)
-it = 1.12% (2419 occurrences)
-its = 0.18% (382 occurrences)
-last = 0.13% (276 occurrences)
-like = 0.27% (581 occurrences)
-long = 0.15% (319 occurrences)
-man = 0.21% (445 occurrences)
-me = 0.29% (621 occurrences)
-more = 0.23% (506 occurrences)
+is = 0.80% (1748 occurrences)
+it = 1.11% (2434 occurrences)
+its = 0.17% (382 occurrences)
+last = 0.13% (278 occurrences)
+like = 0.30% (647 occurrences)
+long = 0.15% (334 occurrences)
+man = 0.22% (476 occurrences)
+me = 0.29% (632 occurrences)
+more = 0.23% (508 occurrences)
 most = 0.13% (284 occurrences)
-must = 0.13% (292 occurrences)
+must = 0.13% (293 occurrences)
 my = 0.27% (589 occurrences)
-no = 0.27% (594 occurrences)
-not = 0.54% (1169 occurrences)
-now = 0.36% (779 occurrences)
-of = 3.10% (6708 occurrences)
-old = 0.20% (444 occurrences)
-on = 0.49% (1069 occurrences)
-one = 0.42% (906 occurrences)
+no = 0.27% (596 occurrences)
+not = 0.53% (1171 occurrences)
+now = 0.36% (783 occurrences)
+of = 3.07% (6732 occurrences)
+old = 0.21% (452 occurrences)
+on = 0.49% (1073 occurrences)
+one = 0.42% (914 occurrences)
 only = 0.17% (378 occurrences)
-or = 0.37% (797 occurrences)
+or = 0.36% (797 occurrences)
 other = 0.19% (416 occurrences)
-out = 0.24% (528 occurrences)
-over = 0.19% (403 occurrences)
-said = 0.14% (301 occurrences)
-sea = 0.18% (382 occurrences)
-see = 0.12% (268 occurrences)
+out = 0.25% (539 occurrences)
+over = 0.19% (409 occurrences)
+said = 0.14% (305 occurrences)
+sea = 0.21% (454 occurrences)
 seemed = 0.13% (283 occurrences)
-ship = 0.18% (391 occurrences)
-so = 0.49% (1061 occurrences)
-some = 0.29% (619 occurrences)
-still = 0.14% (311 occurrences)
+ship = 0.20% (438 occurrences)
+so = 0.49% (1066 occurrences)
+some = 0.28% (619 occurrences)
+still = 0.14% (312 occurrences)
 such = 0.17% (376 occurrences)
 than = 0.14% (311 occurrences)
-that = 1.38% (2999 occurrences)
-the = 6.74% (14616 occurrences)
-their = 0.29% (620 occurrences)
-them = 0.22% (471 occurrences)
-then = 0.29% (628 occurrences)
-there = 0.37% (792 occurrences)
-these = 0.19% (405 occurrences)
-they = 0.31% (664 occurrences)
-this = 0.66% (1440 occurrences)
+that = 1.37% (3005 occurrences)
+the = 6.67% (14620 occurrences)
+their = 0.28% (620 occurrences)
+them = 0.22% (474 occurrences)
+then = 0.29% (630 occurrences)
+there = 0.37% (805 occurrences)
+these = 0.19% (406 occurrences)
+they = 0.30% (664 occurrences)
+this = 0.66% (1443 occurrences)
 those = 0.14% (307 occurrences)
-thou = 0.12% (267 occurrences)
-though = 0.18% (383 occurrences)
-time = 0.15% (326 occurrences)
-to = 2.16% (4677 occurrences)
-two = 0.13% (288 occurrences)
-up = 0.24% (516 occurrences)
-upon = 0.26% (567 occurrences)
+though = 0.18% (384 occurrences)
+time = 0.15% (334 occurrences)
+to = 2.15% (4706 occurrences)
+two = 0.14% (298 occurrences)
+up = 0.24% (524 occurrences)
+upon = 0.26% (568 occurrences)
 very = 0.15% (323 occurrences)
-was = 0.76% (1645 occurrences)
+was = 0.75% (1646 occurrences)
 we = 0.21% (455 occurrences)
-were = 0.32% (683 occurrences)
-whale = 0.45% (972 occurrences)
+were = 0.31% (683 occurrences)
+whale = 0.51% (1108 occurrences)
 what = 0.26% (566 occurrences)
 when = 0.28% (607 occurrences)
 which = 0.30% (655 occurrences)
-who = 0.16% (345 occurrences)
-will = 0.18% (396 occurrences)
-with = 0.82% (1770 occurrences)
-would = 0.20% (428 occurrences)
-ye = 0.20% (428 occurrences)
-yet = 0.16% (344 occurrences)
-you = 0.44% (944 occurrences)
+white = 0.13% (281 occurrences)
+who = 0.16% (347 occurrences)
+will = 0.18% (398 occurrences)
+with = 0.81% (1770 occurrences)
+would = 0.20% (430 occurrences)
+ye = 0.20% (431 occurrences)
+yet = 0.16% (345 occurrences)
+you = 0.43% (946 occurrences)</code></pre>
<h2 id="french">French?</h2>
<p>Here is the Haskell version’s output on the first volume of <a href="http://www.gutenberg.org/cache/epub/17489/pg17489.txt"><em>Les Misérables</em></a> in the original French:</p>
<pre><code>e = 14.68% (77528 occurrences)
a = 8.12% (42892 occurrences)
i = 7.65% (40424 occurrences)
t = 7.62% (40270 occurrences)
s = 7.27% (38395 occurrences)
n = 6.76% (35704 occurrences)
r = 6.25% (32985 occurrences)
u = 6.16% (32553 occurrences)
l = 5.81% (30686 occurrences)
o = 5.17% (27315 occurrences)
d = 3.46% (18262 occurrences)
c = 3.06% (16150 occurrences)
m = 2.99% (15800 occurrences)
p = 2.61% (13784 occurrences)
v = 1.95% (10285 occurrences)
é = 1.87% (9852 occurrences)
q = 1.26% (6637 occurrences)
f = 1.18% (6245 occurrences)
h = 1.06% (5623 occurrences)
b = 0.99% (5244 occurrences)
g = 0.93% (4910 occurrences)
j = 0.56% (2973 occurrences)
à = 0.53% (2795 occurrences)
x = 0.40% (2102 occurrences)
y = 0.39% (2051 occurrences)
è = 0.32% (1702 occurrences)
ê = 0.30% (1584 occurrences)
z = 0.18% (964 occurrences)
â = 0.08% (410 occurrences)
ç = 0.07% (355 occurrences)
û = 0.06% (335 occurrences)
ô = 0.05% (290 occurrences)
ù = 0.05% (285 occurrences)
w = 0.05% (284 occurrences)
î = 0.05% (276 occurrences)
k = 0.03% (151 occurrences)
ï = 0.01% (47 occurrences)
ë = 0.00% (5 occurrences)
ü = 0.00% (2 occurrences)
ñ = 0.00% (2 occurrences)
--------------------------------------------------------------------------------
de = 3.89% (4472 occurrences)
la = 2.64% (3040 occurrences)
et = 2.57% (2949 occurrences)
il = 2.25% (2582 occurrences)
le = 2.22% (2548 occurrences)
à = 1.94% (2236 occurrences)
les = 1.34% (1538 occurrences)
un = 1.27% (1459 occurrences)
que = 1.17% (1350 occurrences)
qui = 1.11% (1278 occurrences)
dans = 0.99% (1134 occurrences)
une = 0.92% (1062 occurrences)
ce = 0.92% (1062 occurrences)
en = 0.90% (1036 occurrences)
des = 0.82% (948 occurrences)
pas = 0.76% (879 occurrences)
se = 0.75% (859 occurrences)
ne = 0.73% (843 occurrences)
était = 0.69% (792 occurrences)
vous = 0.68% (783 occurrences)
je = 0.67% (770 occurrences)
avait = 0.66% (760 occurrences)
lui = 0.63% (721 occurrences)
du = 0.62% (714 occurrences)
elle = 0.57% (660 occurrences)
sur = 0.56% (640 occurrences)
sa = 0.55% (635 occurrences)
pour = 0.54% (620 occurrences)
son = 0.53% (611 occurrences)
au = 0.50% (579 occurrences)
cette = 0.48% (556 occurrences)
on = 0.47% (537 occurrences)
est = 0.46% (533 occurrences)
qu&#39;il = 0.46% (528 occurrences)
a = 0.46% (524 occurrences)
tout = 0.45% (514 occurrences)
plus = 0.44% (508 occurrences)
comme = 0.44% (503 occurrences)
dit = 0.39% (446 occurrences)
avec = 0.38% (432 occurrences)
c&#39;est = 0.36% (416 occurrences)
y = 0.35% (404 occurrences)
par = 0.34% (392 occurrences)
mais = 0.30% (350 occurrences)
nous = 0.30% (340 occurrences)
ses = 0.28% (321 occurrences)
là = 0.27% (308 occurrences)
bien = 0.27% (305 occurrences)
deux = 0.26% (303 occurrences)
monsieur = 0.26% (296 occurrences)
même = 0.26% (295 occurrences)
cela = 0.26% (295 occurrences)
ces = 0.26% (294 occurrences)
si = 0.24% (273 occurrences)
où = 0.23% (269 occurrences)
m = 0.23% (266 occurrences)
me = 0.21% (238 occurrences)
l&#39;évêque = 0.21% (236 occurrences)
homme = 0.20% (234 occurrences)
sans = 0.20% (233 occurrences)
aux = 0.20% (232 occurrences)
fait = 0.20% (230 occurrences)
madeleine = 0.19% (214 occurrences)
qu&#39;on = 0.18% (210 occurrences)
jean = 0.18% (210 occurrences)
d&#39;un = 0.18% (208 occurrences)
c&#39;était = 0.17% (199 occurrences)
valjean = 0.17% (197 occurrences)
être = 0.17% (196 occurrences)
fantine = 0.17% (192 occurrences)
d&#39;une = 0.17% (190 occurrences)
javert = 0.15% (177 occurrences)
the = 0.15% (176 occurrences)
peu = 0.15% (173 occurrences)
cet = 0.15% (173 occurrences)
faire = 0.15% (172 occurrences)
puis = 0.15% (169 occurrences)
moi = 0.15% (168 occurrences)
j&#39;ai = 0.14% (164 occurrences)
chose = 0.14% (164 occurrences)
été = 0.14% (163 occurrences)
maire = 0.14% (162 occurrences)
dire = 0.14% (159 occurrences)
rien = 0.14% (158 occurrences)
quand = 0.14% (157 occurrences)
sont = 0.13% (153 occurrences)
quelque = 0.13% (153 occurrences)
tous = 0.13% (152 occurrences)
porte = 0.13% (150 occurrences)
ou = 0.13% (148 occurrences)
toute = 0.13% (147 occurrences)
chapitre = 0.13% (144 occurrences)
sous = 0.12% (142 occurrences)
peut = 0.12% (140 occurrences)
mon = 0.12% (138 occurrences)
moment = 0.12% (138 occurrences)
dieu = 0.12% (137 occurrences)
encore = 0.12% (134 occurrences)
l&#39;homme = 0.11% (130 occurrences)
eût = 0.11% (130 occurrences)</code></pre>
<p>. The most common French word in this book is <em>de</em>, meaning <em>of</em> in English. This is because the word for <em>the</em> is split into many different words, most notably <em>la</em> and <em>le</em>, not to mention <em>l’</em> as in <em>l’homme</em> (as you can see near the end of the list), due to the French language’s gender and vowel contraction rules (unlike English, contractions like <em>l’homme</em> in French are mandatory regardless of tone).</p>
<p>And, as a bit of trivia, it is interesting to note that <em>dieu</em> (God) edges out <em>l’homme</em> (man) by 7 occurrences in this text.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope you’ve had some fun working on these letter and word frequency problems. The word frequency problem, if you really want to do it correctly, should be handled by a parser using a robust library. By writing these programs, I learned that the <em>input</em> of a program (Unicode? ASCII only?) is just as important as its output.</p>
<p>Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>After I receive, assemble, and acclimate myself to it, I will post a review.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Generating Random Numbers without Modulo Bias, Redux</title>
    <link href="http://listx.github.io/post/2015-02-27-removing-modulo-bias-redux.html" />
    <id>http://listx.github.io/post/2015-02-27-removing-modulo-bias-redux.html</id>
    <published>2015-02-27T00:00:00Z</published>
    <updated>2015-02-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-02-27</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-27-removing-modulo-bias-redux.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/rng.html">rng</a>, <a href="/tag/c.html">c</a>
</div>

<p>In an earlier post, I discussed <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">how to remove modulo bias from your C code</a>. I would like to add a different version of removing modulo bias, inspired by the code from the <a href="http://www.pcg-random.org/">PCG family</a> of random number generators.</p>
<h2 id="the-pcg-version">The PCG Version</h2>
<p>In the <a href="http://www.pcg-random.org/download.html">official minimal C implementation</a> of PCG, there is a function called <code>pcg32_boundedrand_r</code>, which takes a <code>bound</code> variable. The code for that function is as follows:</p>
<div class="sourceCode"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">uint32_t</span> pcg32_boundedrand_r(pcg32_random_t* rng, <span class="dt">uint32_t</span> bound)
{
	<span class="dt">uint32_t</span> threshold = -bound % bound;
	<span class="kw">for</span> (;;) {
		<span class="dt">uint32_t</span> r = pcg32_random_r(rng);
		<span class="kw">if</span> (r &gt;= threshold)
			<span class="kw">return</span> r % bound;
	}
}</code></pre></td></tr></table></div>
<p>. If <code>bound</code> is 5, then the function will return a uniform range from 0 to 4. I.e., the return value <code>r</code> is such that <span class="math inline">\(0 \leq r &lt; bound\)</span>.</p>
<h2 id="explanation-of-the-pcg-version">Explanation of the PCG Version</h2>
<p>Although I generally prefer to explain code in the order they appear, top to bottom, for this case I would like to explain the <code>pcg32_boundedrand_r()</code> function by talking about the usual broken version found in the wild.</p>
<h3 id="broken-version">Broken Version</h3>
<p>The broken version is like this:</p>
<pre><code>r = some_rng();
return r % bound;</code></pre>
<p>. Unless <code>r</code> is a multiple of <code>bound</code>, we will incur the wrath of modulo bias in the above code. Why is this? Well, consider what the modulo operator does. All it does is chop off any excess range of values that is not a multiple of <code>bound</code>. Consider the following ASCII diagram, where the maximum value returned by our <code>some_rng()</code> function is just 11:</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 10 11</code></pre>
<p>. So, <code>some_rng()</code> has 12 possible unique values, 0 through 11. If our bound was <code>4</code>, then doing <code>r % bound</code> is perfectly fine, because we can chop the RNG range into three equal parts of length 4 each, like this:</p>
<pre><code>0 1 2 3 | 4 5 6 7 | 8 9 10 11</code></pre>
<p>. If each of the 12 values 0 through 11 occurs uniformly<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, then we can assume that each of the values occurs <span class="math inline">\(\frac{1}{12}\)</span> times. If we apply <code>% 4</code> to the values, then our output range looks like this:</p>
<pre><code>0 1 2 3 | 0 1 2 3 | 0 1 2 3</code></pre>
<p>. Can you see how the three subparts are the same? What’s more, 0 will occur <span class="math inline">\(\frac{3}{12} = \frac{1}{4}\)</span> times. The same goes for <code>1</code>, <code>2</code>, and <code>3</code>. Because all 4 possible values, 0 through 4, occur an equal <span class="math inline">\(\frac{1}{4}\)</span> times, there is <em>no modulo bias here</em>!</p>
<h4 id="what-if-the-modulus-is-not-a-nice-number-with-respect-to-rand_max">What if the modulus is not a nice number with respect to <code>RAND_MAX</code>?</h4>
<p>This is where the problem occurs. <code>RAND_MAX</code> is the highest value returned by our RNG, and thus defines the range of the possible values output by the RNG.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> Continuing with our example above, if instead of <code>bound = 4</code>, we used another value like 5, we will get this instead:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11</code></pre>
<p>— or essentially, these values are output if we just naively use <code>r % bound</code>:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>. Can you see how <code>0</code> and <code>1</code> will occur <span class="math inline">\(\frac{3}{12}\)</span> times, but <code>2</code>, <code>3</code>, and <code>4</code> will occur only <span class="math inline">\(\frac{2}{12}\)</span> times?</p>
<h4 id="the-fix-adjust-the-range">The fix — adjust the range!</h4>
<p>Now, we can fix the above example by simply throwing out certain values. The approach I used in the <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">old blog post</a> was to discard the right hand side values. So, in our example with <code>bound = 5</code>, where we have</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>, the old example tried to discard the last 2 values, like this:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | x x</code></pre>
<p>. In other words, if <code>r</code> fell within the range 10 through 11, then we’d simply discard it and call <code>some_rand()</code> again.</p>
<p>But it doesn’t have to be this way. Instead of throwing out the values on the right, we can throw out the values on the left! So, instead of</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | x x</code></pre>
<p>we can instead do</p>
<pre><code>x x 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>. Can you see how all of the values 0 through 4 occur exactly 2 times? No more bias!</p>
<h3 id="pcgs-approach">PCG’s approach</h3>
<p>The approach in PCG is the same; here is the code again:</p>
<div class="sourceCode"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">uint32_t</span> pcg32_boundedrand_r(pcg32_random_t* rng, <span class="dt">uint32_t</span> bound)
{
	<span class="dt">uint32_t</span> threshold = -bound % bound;
	<span class="kw">for</span> (;;) {
		<span class="dt">uint32_t</span> r = pcg32_random_r(rng);
		<span class="kw">if</span> (r &gt;= threshold)
			<span class="kw">return</span> r % bound;
	}
}</code></pre></td></tr></table></div>
<p>. The <code>threshold</code> value is the initial range that must be discarded. So we can visualize it like this:</p>
<pre><code>x x 2 3 4 | 0 1 2 3 4 | 0 1

// The `x x` here is the initial threshold range, that must be discarded.</code></pre>
<p>On line 3, we determine the value of <code>threshold</code>, and then on line 4 we enter a <code>for</code> loop that repeatedly calls the RNG until we get a value outside of this threshold range (well, technically, <em>greater-than-or-equal-to</em> the threshold value). If we do get such a value, then we return the modulo of it. If we visualize it, it’s like this:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11

- Discard 0 and 1 (the threshold area).

x x 2 3 4 | 5 6 7 8 9 | 10 11

- Return (r % bound).

x x 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>.</p>
<h4 id="how-is-threshold-calculated">How is <code>threshold</code> calculated?</h4>
<p>The above high-level explanation should be sufficient for you, dear reader. But if you want to go down to the innards of C, to see how <code>pcg32_boundedrand_r</code> works, read on.</p>
<p>The cornerstone of the PCG approach is to use a variable called <code>threshold</code>. The code to calculate <code>threshold</code> is somewhat complicated:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> threshold = -bound % bound;</code></pre></div>
<p>. Now, let’s remind ourselves that the whole point of <code>threshold</code> is to be a minimum value that sets a cutoff of values to be discarded — if the generated value <code>r</code> is too low (lower than our threshold), then we discard it.</p>
<p>Consider the following diagram, with <code>RAND_MAX</code> set to <code>11</code>, and <code>bound</code> set to 5:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11</code></pre>
<p>. We can visualze the above like this instead:</p>
<pre><code>R R R R R | _ _ R R R | R R</code></pre>
<p>. The underscores represent the values that must be <em>skipped</em> over, in order to eliminate modulo bias. The question then, is to figure out how to count the number of underscores. In our case, it is 2, and so as long as we skip the first two values 0 and 1, we should be fine.</p>
<p>The first step is to count backwards from the right-hand edge:</p>
<pre><code>                |&lt;---count|
R R R R R | _ _ R R R | R R
                t         |
                          \-&gt; RAND_MAX</code></pre>
<p>. We end up where <code>t</code> is on the diagram above, by counting backwards from <code>RAND_MAX</code>. If we then take the modulo of this by <code>count</code> itself, then we end up with <code>t</code> being the value we want — the number of underscores. This is the essence of <code>-bound % bound</code> — we first take <code>-bound</code> which is obtained by counting backwards from <code>RAND_MAX</code>, and then we take the modulo of this number by <code>bound</code> itself, to get what we need. Using the ASCII diagram again, we get</p>
<pre><code>                |&lt;-----count|
0 1 2 3 4 | 5 6 7 8 9 | 10 11
                t          |
                           \-&gt; RAND_MAX
</code></pre>
<p>where <code>t</code> is 7, and now applying % 5, we get:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1
                t</code></pre>
<p><code>t = 2</code>, the correct answer! You can try out different values for <code>RAND_MAX</code> and <code>bound</code>, but you will get the right answer each time using <code>threshold = -bound % bound</code>.</p>
<h5 id="but-why-is--bound-the-way-it-is">But why is <code>-bound</code> the way it is?</h5>
<p>The <a href="http://stackoverflow.com/questions/2711522/what-happens-if-i-assign-a-negative-value-to-an-unsigned-variable">C standard</a> says that a negative unsigned value is stored as a positive value. Without getting too technical, here are the values of <code>bound</code> as it becomes “negative”:</p>
<pre><code>Bound | Actual value
------+-------------
2     | 2
1     | 1
0     | 0
-1    | (2^32) - 1 (same as RAND_MAX)
-2    | (2^32) - 2 (same as RAND_MAX - 1)
-3    | (2^32) - 3 (same as RAND_MAX - 2)
... and so on</code></pre>
<p>. In our case, if our <code>RAND_MAX</code> is 11, and <code>bound</code> is 5, then <code>-bound</code> is indeed 7.</p>
<pre><code>Bound | Actual value
------+-------------
0     | 0
-1    | 11 - 0 (same as RAND_MAX)
-2    | 11 - 1 (same as RAND_MAX - 1)
-3    | 11 - 2 (same as RAND_MAX - 2)
-4    | 11 - 3 (same as RAND_MAX - 3)
-5    | 11 - 4 (same as RAND_MAX - 4) = 7
... and so on</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>I thoroughly enjoyed looking at the source code in PCG, only to discover an elegant solution around removing modulo bias. Unfortunately, I do not know the true origin of this approach; it is possible that the authors of the PCG code invented it, but I find this improbable. Meanwhile, I strongly recommend the following code for anyone using a low-level generator that does not come with a bounded version:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/rng/pcg-style.c"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Uniformly return an integer from 0 to (bound - 1). We assume that rand()</span>
<span class="co"> * returns a 32-bit unsigned integer, so we use uint32_t.</span>
<span class="co"> */</span>
<span class="dt">uint32_t</span> bound = some_arbitrary_bound;
<span class="dt">uint32_t</span> r;
<span class="dt">uint32_t</span> threshold = -bound % bound;
<span class="kw">while</span> (r = rand() &lt; threshold) {};
<span class="kw">return</span> r % bound;</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/rng/pcg-style.c"  mimetype=text/plain > pcg-style.c </a>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Any RNG worth their salt will return a uniformly distributed value, typically from 0 to <code>RAND_MAX</code>. In the example here, our <code>RAND_MAX</code> is 11.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>For a 32-bit unsigned integer RNG, <span class="math inline">\(2^{32} - 1\)</span> (all 1 bits set) is the highest value that can be returned. That is, our RNG returns a value from 0 (no bits set) to <code>RAND_MAX</code> (all bits set). This means that our RNG generates everything from all 0s to all 1s and everything in between.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Programming Puzzle: Game Button Sequence Recognizer</title>
    <link href="http://listx.github.io/post/2015-02-24-puzzle-game-button-recognizer.html" />
    <id>http://listx.github.io/post/2015-02-24-puzzle-game-button-recognizer.html</id>
    <published>2015-02-24T00:00:00Z</published>
    <updated>2015-02-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-02-24</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-24-puzzle-game-button-recognizer.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/ruby.html">ruby</a>
</div>

<p>So just yesterday, I did a live coding interview. Looking back, the problem I was presented with was very simple, but true to my usual nervous self, I over-analzyed the problem — completely missing the point and needlessly complicating things. In an effort to redeem myself, I thought about the problem again and even went out as to write tests for it, in both Ruby and Haskell. If you want to have a crack at the problem yourself, be conservative about scrolling down the page! Without further ado, I present the problem to you.</p>
<h2 id="the-problem">The Problem</h2>
<p>You are a game engine API writer. You need to implement a mechanism that allows your developers to store and retrieve game moves based on the input to the game engine. The two functions for this mechanism should be named <code>register()</code> and <code>on_button()</code>.</p>
<p><code>register()</code> should take a named button sequence, and store it into the database of all named sequences. A single named sequence might look like this: <code>([&quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;], &quot;hadoken&quot;)</code>.</p>
<p><code>on_button()</code> should take a single key, and then return all named sequences that match the ones in the database. E.g., <code>on_button(&quot;punch&quot;)</code> should return <code>&quot;hadoken&quot;</code> if the previous two inputs were <code>&quot;down&quot;</code> and <code>&quot;forward&quot;</code>.</p>
<h3 id="some-constraints">Some Constraints</h3>
<h4 id="multiple-sequences">Multiple Sequences</h4>
<p>Because our API is flexible, we allow <em>multiple</em> named sequences with the <em>same sequence</em>. Thus, you can expect something like this:</p>
<pre><code>register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut&quot;)
register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut_2&quot;)
on_button(&quot;up&quot;)        # no result
on_button(&quot;punch&quot;)     # [&quot;uppercut&quot;, &quot;uppercut_2&quot;]</code></pre>
<p>. You don’t have to worry about multiple named sequences with the same sequence and also the same name — we will worry about this “exact duplicate” situation in a later version of our API.</p>
<h4 id="input-history">Input History</h4>
<p>You might have noticed that <code>on_button()</code> depends on the input history of whatever buttons were <em>previously</em> entered into the game. Because of this, you can alternatively write an <code>on_buttons()</code> function (plural with an “s”) that takes the history of buttons as input; this way you don’t have to silently depend on the global state of input history.</p>
<h2 id="my-nervous-wreck-solution">My Nervous-Wreck Solution</h2>
<p>I decided to use pure Haskell code in the actual interview. The code I wrote had the general idea, but it was a big failure because it performed a naive, custom search without any thought given to data structures. I actually went back and revised the code to make it compile and work <em>after</em> the interview was over; here it is in all its glory:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/interview_ver.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="fu">=</span> [(<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>)]
<span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="fu">=</span> [<span class="dt">String</span>]
<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="co">-- Default DB of button sequences.</span>
<span class="ot">buttonSeqDB ::</span> <span class="dt">ButtonSeqDB</span>
buttonSeqDB <span class="fu">=</span>
	[ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;hadoken&quot;</span>)
	, ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;charger&quot;</span>)
	, ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut&quot;</span>)
	]

<span class="ot">register ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span>
register sequence name db
	<span class="fu">|</span> null sequence <span class="fu">=</span> db
	<span class="fu">|</span> alreadyExists <span class="fu">=</span> db
	<span class="fu">|</span> otherwise <span class="fu">=</span> (sequence, name) <span class="fu">:</span> db
	<span class="kw">where</span>
	alreadyExists <span class="fu">=</span> elem (sequence, name) db

<span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons buttonHist db <span class="fu">=</span> map snd
	<span class="fu">.</span> fst
	<span class="fu">.</span> foldl step ([], db)
	<span class="fu">$</span> reverse buttonHist
	<span class="kw">where</span>
	step acc<span class="fu">@</span>(foundSoFar, dbRem) button
		<span class="fu">|</span> null remaining <span class="fu">=</span> acc
		<span class="fu">|</span> otherwise <span class="fu">=</span>
			( foundSoFar <span class="fu">++</span> entriesComplete
			, dbRem&#39;
			)
		<span class="kw">where</span>
		remaining <span class="fu">=</span> filter ((<span class="fu">==</span>button) <span class="fu">.</span> last <span class="fu">.</span> fst)
			<span class="fu">$</span> filter (not <span class="fu">.</span> null <span class="fu">.</span> fst) dbRem
		dbRem&#39; <span class="fu">=</span> map (\(a, b) <span class="ot">-&gt;</span> (init a, b)) remaining
		entriesComplete <span class="fu">=</span> filter (null <span class="fu">.</span> fst) dbRem&#39;</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/interview_ver.hs"  mimetype=text/plain > interview_ver.hs </a>
</div>
</div>
<p>. I have to admit, the <code>step</code> function in <code>onButtons</code> is essentially unreadable. But it does work:</p>
<pre><code>$ ghci code/toy/game-button-seq/interview_ver.hs
GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( code/toy/game-button-seq/interview_ver.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; onButtons [&quot;down&quot;, &quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;] buttonSeqDB
[&quot;charger&quot;,&quot;hadoken&quot;]</code></pre>
<p>.</p>
<p>Anyway, I will explain the behavior of the code. The first thing to notice is that we feed into <code>step</code> the <em>reversed</em> list of <code>buttonHist</code>, so that we examine the button press history, from newest to oldest. So we look at the just-pressed-button, then the one before that, and the one before, etc, backwards up the history.</p>
<p>As we look at each <code>button</code>, we use it to filter out all known sequences. This filtering is done in <code>remaining</code>, where we check the last button of every known sequence, and see if that matches the current button. That’s what the line <code>filter ((==button) . last . fst)</code> does; the sister line <code>filter (not . null . fst) dbRem</code> is just there to prevent calling <code>last</code> on an empty list.</p>
<p>After we’re done checking, we modify the entire sequence database <code>db</code>, such that we only care about the first <span class="math inline">\(N - 1\)</span> buttons in the sequence. This way, on the next iteration, we can rest assured that checking against the “last” button in a sequence is not always the same button. In subsequent runs of <code>step</code>, we have <code>dbRem</code>‘s sequences slowly get reduced down to nothing as we keep chopping off all sequences’ last button. Keep in mind that we feed the filtered, matching entries of <code>db</code> back into subsequent runs of <code>step</code>, so that effectively we’re only working with matching sequences. Once we reach down to no buttons, we label these named sequences as <code>entriesComplete</code>, and append it into <code>foundSoFar</code>.</p>
<h3 id="analysis">Analysis</h3>
<p>Obviously, this code has many problems. First, it is virtually unreadable. Readability is important, and the code feels very counter-intuitive — it is marvelously complex when the problem statement sounds so simple.</p>
<p>Second, the fact that we have to bring in and mutate <code>dbRem</code>, which is a copy of the original given <code>ButtonSeqDB</code> type, seems wasteful. We’re wasting a lot of CPU cycles here.</p>
<h2 id="ruby-solution-using-hashes">Ruby Solution Using Hashes</h2>
<p>So on the day after (that is, <em>today</em> as of the time of this writing), I thought about the problem again and realized we can use hashes. It is a very simple approach, with far less lines of code. I even wrote some tests for it. Here is the implementation below.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/hash_ver.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">GameButtonSeq</span>
  <span class="co"># button_seq = [&quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;]</span>
  <span class="co"># name = &quot;hadoken&quot;</span>
  <span class="co"># button_seq_db = a hash of {sequence =&gt; name}, but a sequence can have</span>
  <span class="co"># multiple names if that sequence already exists.</span>
  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.register(button_seq, name, button_seq_db)
    <span class="co"># If the sequence already exists, simply add the new name to the old name,</span>
    <span class="co"># and store it as a list of names.</span>
    <span class="kw">if</span> button_seq_db.key?(button_seq)
      button_seq_db[button_seq] = [name] + button_seq_db[button_seq]
    <span class="kw">else</span>
      button_seq_db[button_seq] = [name]
    <span class="kw">end</span>

    button_seq_db
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.on_buttons(button_seq, button_seq_db)
    found = []
    <span class="co"># We search the entire button_seq_db hash for the full length of N buttons</span>
    <span class="co"># first, then N - 1 buttons, then N - 2 buttons, until the search input</span>
    <span class="co"># becomes 0. Meanwhile, we collect any and all matches that come our way.</span>
    <span class="co"># The point is to search based on the *last* input button, as this is the</span>
    <span class="co"># &quot;current&quot; button that should &quot;finish&quot; whatever combination/move we were</span>
    <span class="co"># trying to do.</span>
    <span class="kw">while</span> button_seq.size &gt; <span class="dv">0</span>
      <span class="kw">if</span> button_seq_db.key?(button_seq)
        found &lt;&lt; button_seq_db[button_seq]
      <span class="kw">end</span>
      <span class="co"># Discard oldest button press, and search again. Even if we have a match,</span>
      <span class="co"># it&#39;s important to search for other matches, too.</span>
      button_seq.shift
    <span class="kw">end</span>

    <span class="co"># Clean up, so that we get [&quot;foo&quot;, &quot;bar&quot;] instead of [[&quot;foo&quot;], [&quot;bar&quot;]].</span>
    found.flatten
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.add_hist(button_hist, button_name)
    button_hist + [button_name]
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/hash_ver.rb"  mimetype=text/plain > hash_ver.rb </a>
</div>
</div>
<p>And here is the test suite for it. You can run it with <code>ruby test_hash_ver.rb</code>.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/test_hash_ver.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby">require <span class="st">&#39;minitest/autorun&#39;</span>
require_relative <span class="st">&#39;./hash_ver.rb&#39;</span>

<span class="kw">class</span> <span class="dt">TestPuz</span> &lt; <span class="dt">Minitest</span>::<span class="dt">Test</span>

  <span class="kw">def</span> setup
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;hadoken&quot;</span>, {})
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;charger&quot;</span>, <span class="ot">@db</span>)
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut&quot;</span>, <span class="ot">@db</span>)

    <span class="co"># Aside: We can easily limit the size of button_hist[] by forcefully always</span>
    <span class="co"># saving only the last N key presses, with N determined by the longest</span>
    <span class="co"># button sequence.</span>
    <span class="ot">@button_hist</span> = []

    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;forward&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;punch&quot;</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_multiple_names_entered
    db2 = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut_2&quot;</span>, <span class="ot">@db</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(button_hist2, <span class="st">&quot;punch&quot;</span>)
    assert_equal [<span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, db2)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_no_sequence_found
    <span class="co"># Add an unrecognized button.</span>
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;back&quot;</span>)
    assert_equal [],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, <span class="ot">@db</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_one_sequence_found
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(button_hist2, <span class="st">&quot;punch&quot;</span>)
    assert_equal [<span class="st">&quot;uppercut&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, <span class="ot">@db</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_multiple_sequences_found
    assert_equal [<span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(<span class="ot">@button_hist</span>, <span class="ot">@db</span>)
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/test_hash_ver.rb"  mimetype=text/plain > test_hash_ver.rb </a>
</div>
</div>
<h3 id="analysis-1">Analysis</h3>
<p>The key insight was when I realized that you could indeed use a hash even though we have the requirement that multiple, identical button sequences can have different names. The trick is to simply store the value as not a single name, but an array of possible names. This is reflected in the <code>GameButtonSeq.register</code> method.</p>
<p>The heart of <code>on_buttons()</code> is a single <code>while</code> loop that checks the given button history against the database; we reduce the button sequence by 1 button on each iteration to check against shorter matches as well. That’s what the <code>button_seq.shift</code> is for.</p>
<h2 id="haskell-solution-using-hashes">Haskell Solution Using Hashes</h2>
<p>Inspired by the Ruby solution, I rewrote a Haskell version — with tests to boot! Here is the implementation.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/GameButtonSeq.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">GameButtonSeq</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="co">-- The database stores a list of Name values, because multiple sequences can</span>
<span class="co">-- have the same name, in which case we store just one instance of the sequence,</span>
<span class="co">-- but a list of multiple Name values.</span>
<span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]
<span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="fu">=</span> [<span class="dt">String</span>]
<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="co">-- If a button sequence is already given some set of names, add the current</span>
<span class="co">-- given name into that list of names..</span>
<span class="ot">register ::</span> (<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>) <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span>
register (buttonSeq, name) db <span class="fu">=</span> <span class="kw">case</span> M.lookup buttonSeq db <span class="kw">of</span>
	<span class="dt">Just</span> names <span class="ot">-&gt;</span> M.insert buttonSeq (name<span class="fu">:</span>names) db
	<span class="dt">Nothing</span> <span class="ot">-&gt;</span> M.insert buttonSeq [name] db

<span class="co">-- Input `buttonSeq` is a list of buttons pressed, from oldest to newest, so</span>
<span class="co">-- that the head of the list contains the oldest button.</span>
<span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons buttonHist db <span class="fu">=</span> concatMap extractNames buttonHists
	<span class="kw">where</span>
	buttonHists <span class="fu">=</span> take (length buttonHist) <span class="fu">$</span> iterate tail buttonHist
	extractNames bHist <span class="fu">=</span> <span class="kw">case</span> M.lookup bHist db <span class="kw">of</span>
		<span class="dt">Just</span> names <span class="ot">-&gt;</span> names
		<span class="dt">Nothing</span> <span class="ot">-&gt;</span> []

<span class="ot">onButtons2 ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons2 buttonHist db <span class="fu">=</span> concat <span class="fu">$</span> mapMaybe (flip M.lookup db) buttonHists
	<span class="kw">where</span>
	buttonHists <span class="fu">=</span> take (length buttonHist) <span class="fu">$</span> iterate tail buttonHist</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/GameButtonSeq.hs"  mimetype=text/plain > GameButtonSeq.hs </a>
</div>
</div>
<p>The file is named <code>GameButtonSeq</code> because of Haskell naming conventions for files containing module code. And here is the test for it.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/test_hash_ver.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span>

<span class="kw">import </span><span class="dt">GameButtonSeq</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain tests

<span class="ot">tests ::</span> <span class="dt">TestTree</span>
tests <span class="fu">=</span> testGroup <span class="st">&quot;Tests&quot;</span> [qcProps, unitTests]

<span class="ot">qcProps ::</span> <span class="dt">TestTree</span>
qcProps <span class="fu">=</span> testGroup <span class="st">&quot;(checked by QuickCheck)&quot;</span>
	[ QC.testProperty <span class="st">&quot;GameButtonSeq (empty DB cannot produce matches)&quot;</span> <span class="fu">$</span>
		\buttonHist <span class="ot">-&gt;</span> onButtons (<span class="ot">buttonHist ::</span> <span class="dt">ButtonSeq</span>) M.empty <span class="fu">==</span> []
	]

<span class="ot">unitTests ::</span> <span class="dt">TestTree</span>
unitTests <span class="fu">=</span> testGroup <span class="st">&quot;Unit tests&quot;</span>
	[ testCase <span class="st">&quot;GameButtonSeq (entry of multiple sequences with same name)&quot;</span> <span class="fu">$</span>
		(onButtons [<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]
		<span class="fu">$</span> register ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut_2&quot;</span>) buttonSeqDB)
			<span class="fu">@?=</span>
			[<span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span>]
	, testCase <span class="st">&quot;GameButtonSeq (no sequence found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>, <span class="st">&quot;down&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[]
	, testCase <span class="st">&quot;GameButtonSeq (one sequences found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[<span class="st">&quot;uppercut&quot;</span>]
	, testCase <span class="st">&quot;GameButtonSeq (multiple sequences found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[<span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span>]
	]
	<span class="kw">where</span>
	<span class="co">-- Default DB of button sequences.</span>
<span class="ot">	buttonSeqDB ::</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]
	buttonSeqDB <span class="fu">=</span> M.fromList
		[ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;hadoken&quot;</span>])
		, ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;charger&quot;</span>])
		, ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;uppercut&quot;</span>])
		]</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/test_hash_ver.hs"  mimetype=text/plain > test_hash_ver.hs </a>
</div>
</div>
<h3 id="analysis-2">Analysis</h3>
<p>This Haskell version uses the standard <code>Data.Map</code> module, which provides an efficient, basic hash data structure. What we first do is expand <code>buttonHist</code> to all of the cases we are interested in — namely, all of the subsequences of concern. E.g., given a list like <code>[&quot;up&quot;, &quot;down&quot;, &quot;right&quot;, &quot;left&quot;]</code>, <code>buttonHists</code> becomes:</p>
<pre><code>[ [&quot;up&quot;, &quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,       [&quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,               [&quot;right&quot;, &quot;left&quot;]
,                        [&quot;left&quot;]
]</code></pre>
<p>(spaces added for readability). What we do is reduce the initial input list into all of the “sublist” combinations of <span class="math inline">\(N\)</span> buttons, <span class="math inline">\(N - 1\)</span> buttons, <span class="math inline">\(N - 2\)</span> buttons, etc.</p>
<p>The next step is to simply look at each sublist with <code>concatMap</code>, calling <code>extractNames</code>; we treat each sublist as a key, and look for it in our <code>db</code> hash. We then simply concatenate the results.</p>
<p>The <code>onButtons2</code> is an alternate version which uses <code>mapMaybe</code> to reduce it down to just two lines of code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I cringe as I look back at the half-baked code I wrote during the interview. Even the working, compilable version that I wrote after the interview remains ugly and hard to reason about. I can picture my interviewer being grossed out by my ugly, hacky version wondering if I even know what hashes are…</p>
<p>The moral of the story is to think carefully about the most obvious data structure to use, before embarking on writing a solution — no matter how trivial it seems. For myself, I was nervous and did not realize how simple the problem actually was until the day after when I rewrote the solution in Ruby. It was so simple and straightforward that I even wrote some test cases for it<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>I hope you had some fun writing out your own solutions. Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You can test the Haskell hash version in this blog post if you clone this blog’s repo and then build it with Cabal (I’ve listed the program as an executable with all the constraints in the <code>blog.cabal</code> file in the repo root folder). For the Ruby version, simply do <code>ruby path/to/test_hash_ver.rb</code> and Ruby will run the tests inside.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Using the Nix Package Manager for Haskell Development from Arch Linux</title>
    <link href="http://listx.github.io/post/2015-02-10-using-nix-from-arch.html" />
    <id>http://listx.github.io/post/2015-02-10-using-nix-from-arch.html</id>
    <published>2015-02-10T00:00:00Z</published>
    <updated>2015-02-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-02-10</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-10-using-nix-from-arch.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/arch.html">arch</a>, <a href="/tag/linux.html">linux</a>, <a href="/tag/nix.html">nix</a>
</div>

<p>I recently installed and configured NixOS on a laptop and had to learn how to develop Haskell on it. The Nix community uses something called <code>cabal2nix</code> (version 2.0 and up!) and <code>nix-shell</code> to get the job done. While things work quite smoothly right now in NixOS, I was wondering if I could do the same on my desktop Arch Linux box.</p>
<p>The answer is yes — you can easily use Nix to create a ‘system sandbox’ of sorts (the Nix store) that is completely isolated from Arch’s own Haskell packages/GHC. To be clear, what we are trying to do is install the Nix package manager (which is composed of many satellite programs like <code>nix-env</code>, <code>nix-shell</code>, etc.) so that we can develop Haskell programs with all the advantages that come with it.</p>
<p>For myself, I have several different Haskell projects, and I wanted to avoid redownloading and recompiling the same packages for each project’s Cabal sandbox environment. Using Nix, I still have the same Cabal sandboxes (one for each project root), but Nix allows all the different sandboxes to share the same packages if the versions and dependencies are the same. And plus, because the Nix store (where Nix stores everything — <code>/nix/store</code>) is independent of Arch’s <code>pacman</code> tool, there is no fear of conflict or things breaking whenever you upgrade Arch Linux’s own Haskell packages.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h1 id="use-the-nix-manual-to-install-nix">Use the Nix Manual to install Nix</h1>
<p>The <a href="http://nixos.org/nix/manual/">Nix manual</a> has up-to-date documentation on how to get Nix. When we say <em>Nix</em>, we are talking about the collection of console programs (with a <code>nix-</code> prefix in their names) that make up to form the Nix package management system — much like how <em>Git</em> is made up of smaller programs that work as a team. There is a <code>nix</code> package on the AUR, but I suggest simply following this guide.</p>
<p>The first step is to run the install script from the NixOS site (which hosts Nix and other related programs) as a normal user:</p>
<pre><code>$ bash &lt;(curl https://nixos.org/nix/install)</code></pre>
<p>. You will now have a directory called <code>/nix</code> in your system. This is where everything related to Nix will be stored. In addition, the script will create some hidden files under your user’s home directory with the <code>.nix-</code> prefix. The most important file for now is <code>~/.nix-profile</code>, because it links to a shell script that initializes the Nix environment (to bring in <code>nix-*</code> utilities into the current shell’s scope). You will get a message from the shell script to source this file, like this:</p>
<pre><code>$ . /home/l/.nix-profile/etc/profile.d/nix.sh</code></pre>
<p>. For me, I put the whole thing into an alias for my shell called <code>nix</code>, like this:</p>
<pre><code># somewhere in my ~/.zshrc
alias nix=&#39;. /home/l/.nix-profile/etc/profile.d/nix.sh&#39;</code></pre>
<p>.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> So, whenever I want access to Nix utilities, I just type in <code>nix</code> and go on my merry way.</p>
<h1 id="install-cabal2nix-and-cabal">Install <code>cabal2nix</code> and <code>cabal</code></h1>
<p>Now, use your alias to enable Nix.</p>
<pre><code>$ nix</code></pre>
<p>You now have access to all the <code>nix-*</code> utilities that make up to provide the Nix package management system. You can list all Nix-packaged packages with <code>nix-env -qaP</code>. For us, we’re interested in the <code>cabal2nix</code> package. As of the time of this writing, it is called <code>nixpkgs.haskellPackages.cabal2nix</code>. However, the <code>haskellPackages</code> prefix refers to the old system that has been more or less deprecated as of <a href="http://article.gmane.org/gmane.linux.distributions.nixos/15513">January 2015</a>. We need to use the <code>haskellngPackages</code> (note the <code>ng</code>) prefix instead. I know that <code>nixpkgs.haskellngPackages.cabal2nix</code> isn’t listed with the <code>nix-env -qaP</code> command, but I believe that’s for legacy reasons. You can still install it! Let’s do that now:</p>
<pre><code>$ nix-env -iA nixpkgs.haskellngPackages.cabal2nix</code></pre>
<p>. This will give you the very useful <code>cabal2nix</code> binary which you can use to convert any <code>.cabal</code> file into something that Nix can understand! Let’s also install <code>cabal</code> for Nix:</p>
<pre><code>$ nix-env -iA nixpkgs.haskellngPackages.cabal-install</code></pre>
<p>. This will install <code>cabal</code> to <code>~/.nix-profile/bin/cabal</code>. This step is not really necessary if you have <code>cabal-install</code> already installed on the Arch Linux side with <code>pacman</code>. However, I still recommend it because</p>
<ol style="list-style-type: decimal">
<li>if you’re using Nix for Haskell development, there is no longer a need to use <code>cabal</code> outside of the Haskell/Nix development process;</li>
<li>it just makes sense to use the <code>cabal</code> package that comes from the same source tree as <code>cabal2nix</code> (i.e., from the same <code>haskellngPackages</code> set<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>); and</li>
<li>as of the time of this writing the <code>cabal-install</code> version from Nix packages set is newer than the Arch version.</li>
</ol>
<p>At the end of the day, your <code>cabal</code> binary should be writing to <code>~/.cabal</code> so take care to use one version and stick with it.</p>
<h1 id="nixify-your-project">Nixify your project</h1>
<h2 id="create-a-.cabal-file">Create a <code>.cabal</code> file</h2>
<p>If you haven’t done so already, create a Cabal file <code>your_project.cabal</code> in your project’s root folder to describe the dependencies in the traditional Haskell way. This step is mandatory!</p>
<h2 id="create-a-shell.nix-file">Create a <code>shell.nix</code> file</h2>
<p>Go to your project’s root folder that contains <code>your_project.cabal</code>, and do</p>
<pre><code>$ cabal2nix --shell . &gt; shell.nix</code></pre>
<p>. The actual syntax is <code>cabal2nix --shell path/to/cabal/file</code>, which prints out the contents of the <code>.nix</code> file to STDOUT. In the case above, we redirect it to a file named <code>shell.nix</code>. The name of this file is important because it is what <code>nix-shell</code> expects.</p>
<p>Now just invoke</p>
<pre><code>$ nix-shell</code></pre>
<p>and you’re set. You will be dropped into a <code>bash</code> instance that has knowledge of the Nix store. The first time you run <code>nix-shell</code>, Nix will identify any missing dependencies and install them for you. Because your project’s <code>shell.nix</code> file describes a Haskell project, <code>nix-shell</code> will install GHC along the way. So when it’s ready, you can start <code>ghci</code>. Because you installed <code>cabal2nix</code> earlier, you have access to <code>cabal</code> (i.e., <code>cabal</code> is a dependency of <code>cabal2nix</code>).</p>
<p>To build your binary just do <code>cabal build</code>! Personally I like to instantiate a Cabal sandbox with <code>cabal sandbox init</code> first, and then do <code>cabal configure</code>, <code>cabal repl</code>, <code>cabal build</code>, etc.</p>
<h1 id="local-dependencies">Local dependencies</h1>
<p>If you’re like me, you might have a Haskell library you wrote for yourself (let’s call it “Private Project X” (PPX)) which is not on Hackage. If you just want to build PPX on its own, you can use the same steps outlined above. But what if your other project depends on PPX?</p>
<p>The trick is to use <code>cabal2nix</code>, and to set up your <code>~/.nixpkgs</code> folder. You should already have <code>~/.nixpkgs</code> created by now as a result of installing Nix. Make a folder called <code>~/.nixpkgs/my-local-hs</code>. Now do</p>
<pre><code>$ cabal2nix path/to/ppx &gt; ~/.nixpkgs/my-local-hs/ppx.nix</code></pre>
<p>. This will create a Nix expression that can be used to build PPX with Nix. It’s like creating a PKGBUILD file. The next step is to create a <code>~/.nixpkgs/config.nix</code> file, as follows:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/config.nix"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="sourceCode"><pre><code class="sourceCode"># Taken from
# http://lists.science.uu.nl/pipermail/nix-dev/2015-January/015601.html.
{
  packageOverrides = super: let self = super.pkgs; in
  {
    haskellngPackages = super.haskellngPackages.override {
      overrides = self: super: {

        # Enable profiling. Taken from
        # http://lists.science.uu.nl/pipermail/nix-dev/2015-January/015620.html.
        # Comment out this line if you do not want to enable profiling!
        mkDerivation = expr: super.mkDerivation (expr // {
          enableLibraryProfiling = true; });

        # Private package
        ztile = self.callPackage ./my-local-hs/ppx.nix {};
      };
    };
  };
}</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/config.nix"  mimetype=text/plain > config.nix </a>
</div>
</div>
<p>. Now, invoke <code>cabal2nix --shell</code> for your other project that depends on PPX. When you invoke <code>nix-shell</code> for this other project, Nix should be able to resolve the dependency, based on the information you gave it in <code>~/.nixpkgs/config.nix</code>. That’s it!</p>
<h1 id="conclusion">Conclusion</h1>
<p>I recommend trying Nix out for Haskell development, or just as a secondary package manager in general. Right now, everything “Just Works” and it’s a pleasure to see different Haskell projects re-use the same packages, even when they are Cabal-sandboxed, as long as you are doing everything within <code>nix-shell</code>.</p>
<p>Even though the title of this post suggests that this is an Arch Linux guide to Nix, there is nothing Arch-specific about it. You should be able to use the steps in this post for any Linux distribution.</p>
<p>Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>That being said, if you’re using Nix then there is little reason to continue to use the Arch packages. I say this with some reluctance, as I am the author of the <a href="https://github.com/listx/cabal2pkgbuild">cabal2pkgbuild utility</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>There are no Nix utilities with <code>nix</code> as its name, so there’s no concern about name clashing.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>To figure out what Nix packages set, a.k.a. <em>channel</em> you are using, do <code>nix-channel --list</code>.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Implementing Binary Search</title>
    <link href="http://listx.github.io/post/2014-12-13-implementing-binary-search.html" />
    <id>http://listx.github.io/post/2014-12-13-implementing-binary-search.html</id>
    <published>2014-12-13T00:00:00Z</published>
    <updated>2014-12-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2014-12-13</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-12-13-implementing-binary-search.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/c.html">c</a>, <a href="/tag/ruby.html">ruby</a>, <a href="/tag/haskell.html">haskell</a>
</div>

<p>If you are a programmer, I’m sure you’ve encountered the term <em>binary search</em> at some point in time. I know what binary search is, but I’m writing this post to solidify my understanding of it. I also want to compare how it might be naively implemented across my 3 favorite languages C, Ruby, and Haskell — because naive code is the best code (to learn from)!</p>
<h2 id="binary-subdivision">Binary Subdivision</h2>
<p>You can skip this section if you want — I merely want to write how I first met and fell in love with the concept of <em>binary subdivision</em>. I first discovered binary division when I was in high school. It was a very pleasant realization, and at the time I did not fully realize what I had accidentally encountered.</p>
<p>The situation was so: my Biology teacher, Mr. Kennedy, told everyone to draw an even 4x4 square grid on the palms of our hands. Everyone was supposed to draw their own 4x4 grid — but this was when I asked myself, “how can I draw the most even-looking grid without using a ruler?” You see, I could not use a ruler because I was using my right hand to draw onto my left hand — and to hold a ruler properly I would need a third hand! So there was the problem.</p>
<p>On the one hand, I could not simply draw the four horizontal and four vertical lines one after the other, left to right, top to bottom, because I knew that I would introduce a great deal of additive error.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> I did not want to draw an ugly, lopsided square.</p>
<p>It took me a few seconds, but I came up with a plan. I first drew a single large square. Then knowing that I could easily eyeball with good accuracy where the <em>middle point of that square</em> was horizontally, I drew a vertical line down the <em>middle</em>. I then did the same thing in the other axis vertically. I repeated this procedure a few more times, <em>recursively subdividing</em> each smaller rectangular shape into halves, finally ending up with a nice-looking grid. I glanced around the room, and later looked at other students’ palms to see if they had discovered this “divide by <span class="math inline">\(\frac{1}{2}\)</span>” trick, but to my dismay no one had done it; I knew this was the case because everybody else’s square was sloppy.</p>
<p>I cannot honestly say if this was the very first time I realized the underlying geometric concepts at play here, but I can affirmatively say that it really was the first time I systematically applied such an elegant solution to a given problem. I wonder if most people who draw grids even bother to think of it as a problem.</p>
<p>To me, binary subdivision is the underpinning principle behind binary search. Continued subdvision by halves is like exponentiation in reverse; pretty soon, you end up with extremely tiny numbers. This is where the power of binary search comes from! Simply put, binary search is like binary subdivision, but you get to subdivide <em>toward</em> the location of whatever you’re looking for. Isn’t that cool?</p>
<h2 id="the-problem">The Problem</h2>
<p>The problem is simple — given a <strong>sorted</strong> list <code>KEYS</code> of items (for simplicity’s sake, positive integers), determine if <code>key</code> is in it, and also, the position of <code>key</code> in the list if it is indeed in the list. The catch is that you have no idea as to the contents of <code>KEYS</code> — only that it is sorted from smallest to largest.</p>
<h2 id="naive-approach-linear-search">Naive Approach — Linear Search</h2>
<p>The simplest way of doing this is by linear search. It is probably the novice programmer’s first reaction. You just start from the first item in <code>KEYS</code>, and run a <strong>for</strong>-loop all the way across the list, looking at every single item. There are now two possibilities — either (1) you indeed discover <code>key</code>, and report back your position (aka the “index”, usually in the form of the familiar <code>i</code> variable in C/C++/Java code), or (2) you find nothing. If you are clever, you can optimize the search in the second situation by breaking out of the <strong>for</strong>-loop if the items you are comparing are larger than <code>key</code>; after all, <code>KEYS</code> is sorted, so we know for a fact that the later numbers are only going to get bigger, so there is no point in trying to find <code>key</code> in that crowd of numbers.</p>
<p>But think of the consequences — what’s the worst case scenario? Imagine you have 1 trillion items, and that <code>key</code> is not in it, because let’s say <code>key</code> is a much bigger number than the biggest number in <code>KEYS</code> — but of course you haven’t run the linear search yet, so you don’t know that. Given this situation, you would have to search the <em>entire</em> list of all numbers in <code>KEYS</code> before reaching condition (2) described above.</p>
<p>If you wanted to get a little more clever to avoid this problem of searching all 1 trillion items, you could tell the algorithm to refuse to enter the <strong>for</strong>-loop if <code>key</code> lies outside the <em>bounds</em> of <code>KEYS</code>. Checking the bounds is easy and takes constant time, as you merely check for the first and last item’s size (again, as <code>KEYS</code> is sorted), and those are your bounds. This way, if <code>key</code> lies outside the bounds, you can <em>guarantee</em> that it is not in <code>KEYS</code>, no matter how many items <code>KEYS</code> has.</p>
<p>And, this is it. There is nothing more to optimize using this method (let’s not get into parallelization). What else can you do, really, when searching linearly, looping through every item from the beginning to the next?</p>
<h2 id="inverted-bounds-checking-aka-binary-search">Inverted Bounds-Checking, aka Binary Search</h2>
<p>The heading of this subsection might have already given you a hint as to what binary search entails. (Although, if you’ve read the <em>Binary Subdivision</em> section, you should have had a good idea anyhow.) Binary search takes the concept of bounds-checking, and applies it repeatedly, recursively, against <code>KEYS</code>. The only difference when I say “bounds-checking” in the context of binary search is that we do <em>not</em> care about the values of those bounds, but merely that they <em>are</em> the bounds. This is because we only concern ourselves with dividing the list of sorted numbers by <span class="math inline">\(\frac{1}{2}\)</span> every time and take the <em>middle</em> index <code>middle_index</code>, which is located as close as possible to the middle element (halfway between the two bounds). Indeed, the only way to get a valid <code>middle_index</code> value is if we know the bounds (the size of the list). We keep doing this recursively until <code>KEYS[mid] == key</code>.</p>
<p>The following is the pseudocode.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search-pseudo-0.txt"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode">KEYS = some random list of numbers
key = the number we&#39;re looking for in KEYS

binary_search(KEYS, key):
	middle_index = get_middle_index_index(length of KEYS)
	lower_KEYS = get_below(middle_index, KEYS)
	upper_KEYS = get_above(middle_index, KEYS)
	if key &lt; KEYS[middle_index]
		binary_search(lower_KEYS, key)
	else if key &gt; KEYS[middle_index]
		binary_search(upper_KEYS, key)
	else
		return middle_index
	end</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search-pseudo-0.txt"  mimetype=text/plain > binary-search-pseudo-0.txt </a>
</div>
</div>
<p>There are some obvious holes in the code above.</p>
<p>First, we always assume that <code>KEYS</code> is made up of multiple elements, and that its halves <code>lower_keys</code> and <code>upper_keys</code> also have multiple elements in them. In the extreme case, <code>KEYS</code> might be an empty list, which would make the whole thing explode.</p>
<p>Second, the <code>get_middle_index()</code>, <code>get_below_mid()</code>, and <code>get_above_mid()</code> functions remain undefined.</p>
<p>Aside: You might be wondering about lines 12-14. We could write</p>
<pre><code>else if key == KEYS[mid]</code></pre>
<p>instead of just <code>else</code> on line 12, but that is redundant. This is because we already test for the two other conditions of <code>key</code> being <em>lesser</em> or <em>greater</em> than <code>middle_index</code>. Therefore, we’ve excluded the two other conditions and are already only left with the third condition of <code>key == KEYS[mid]</code> evaluating to TRUE — hence we write just <code>else</code> on line 12.</p>
<p>Addressing the holes above, we get the next version.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search-pseudo-1.txt"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="sourceCode"><pre><code class="sourceCode">KEYS = some random list of numbers
first_index = 0
last_index = 999 (our KEYS is 1000 elements big)
key = the number we&#39;re looking for in KEYS

binary_search(KEYS, key, first_index, last_index):
	list_size = (last_index - first_index) + 1
	if list_size == 0
		return KEY_NOT_FOUND
	end

	middle_index = list_size / 2 + first_index

	if key &lt; KEYS[middle_index]
		binary_search(KEYS, key, first_index, middle_index - 1)
	else if key &gt; KEYS[middle_index]
		binary_search(KEYS, key, middle_index + 1, last_index)
	else
		return middle_index
	end</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search-pseudo-1.txt"  mimetype=text/plain > binary-search-pseudo-1.txt </a>
</div>
</div>
<p>There are some obvious differences — mainly the fact that we concern ourselves primarily with the first and last index numbers of the list, and work with these indices instead of working with the entire list <code>KEYS</code> itself. The <code>get_below()</code> and <code>get_above()</code> functions are gone and have been replaced with the index bounds <code>first_index, middle_index</code> and <code>middle_index + 1, last_index</code>, respectively. As you can see, working with these index numbers directly avoids a lot of abstraction. Actually, the <code>list_size</code> abstraction can be further reduced in terms of indices, so that <code>list_size == 0</code> can be rewritten as <code>first_index &gt; last_index</code>.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<h2 id="theoretical-performance">Theoretical Performance</h2>
<p>You can probably see why binary search is so powerful. It repeatedly divides the search region into <span class="math inline">\(\frac{1}{2}\)</span> of its original size. It’s sort of like <a href="http://en.wikipedia.org/wiki/Zeno%27s_paradoxes">Zeno’s Dichotomy Paradox</a>, except that it uses the “absurdity” of Zeno’s argument, and uses that to its advantage. To me, these somewhat related, even tangential, connections make binary search that much more elegant.</p>
<p>Consider this: a list that has 100,000 elements will only take, in the worst case, around 16 calls. Compare that to linear search, which will take at most 100,000 calls or iterations (if our item happens to be at the very last index).<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> The time complexity of binary search for a list of <span class="math inline">\(\mathit{KEYS\_TOTAL}\)</span> elements is defined to be <span class="math inline">\(\lfloor\log_2\mathit{KEYS\_TOTAL}\rfloor\)</span>. Because this defines an exponential relationship, we can rest assured that we can <em>cut down</em> a very large list quickly.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<h2 id="naive-implementations">Naive Implementations</h2>
<h3 id="preliminary-details">Preliminary Details</h3>
<p>I said at the beginning of the post that I would show a naive implementation in C, Ruby, and Haskell. I could have simply written a <code>binary_search()</code> function (and only that function) for all three languages — but instead I chose to write full standalone programs for all three that print out the same results. Because they are all standalone programs, you can easily tweak some settings (namely, the <code>KEYS_TOTAL</code> value), and see how it scales.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> All versions use the new <a href="http://www.pcg-random.org">PCG family</a> of pseudorandom number generators (RNGs), which have been created by Prof. Melissa E. O’Neill, author of the great paper <em>The Genuine Sieve of Eratosthenes</em>.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<h3 id="c-version-linux">C Version (Linux)</h3>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search.c"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * LICENSE: PUBLIC DOMAIN</span>
<span class="co"> *</span>
<span class="co"> * Compile with `gcc -o binary-search-c -Wall -Wextra -Wpedantic --std=gnu11 -O2</span>
<span class="co"> * binary-search.c&#39;. Check via valgrind with `valgrind --leak-check=full</span>
<span class="co"> * --show-leak-kinds=all -v path/to/binary&#39;.</span>
<span class="co"> *</span>
<span class="co"> * Usage: just execute the binary as-is without any arguments. To test the RNG,</span>
<span class="co"> * call with the argument &quot;rng&quot;.</span>
<span class="co"> */</span>

<span class="ot">#include &lt;stdbool.h&gt; </span><span class="co">/* bool */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdint.h&gt; </span><span class="co">/* UINT32_MAX */</span>
<span class="ot">#include &lt;stdlib.h&gt; </span><span class="co">/* malloc() */</span>
<span class="ot">#include &lt;string.h&gt; </span><span class="co">/* strcmp() */</span>
<span class="ot">#include &lt;inttypes.h&gt; </span><span class="co">/* uint32_t */</span>

<span class="kw">typedef</span> <span class="dt">uint32_t</span> u32;
<span class="kw">typedef</span> <span class="dt">uint64_t</span> u64;

<span class="co">/*</span>
<span class="co"> * &quot;-1&quot; is an invalid value to be used as an index for an array (the index</span>
<span class="co"> * number is what binary_search() looks for.)</span>
<span class="co"> */</span>
<span class="kw">enum</span> {KEY_NOT_FOUND = -<span class="dv">1</span>};
<span class="dt">const</span> <span class="dt">int</span> KEYS_TOTAL = <span class="dv">1000000</span>;

<span class="co">// *Really* minimal PCG32 code / (c) 2014 M.E. O&#39;Neill / pcg-random.org</span>
<span class="co">// Licensed under Apache License 2.0 (NO WARRANTY, etc. see website)</span>

<span class="kw">typedef</span> <span class="kw">struct</span> { u64 state;  <span class="dt">uint64_t</span> inc; } pcg32_random_t;

u32 pcg32_random_r(pcg32_random_t *rng)
{
	u64 oldstate = rng-&gt;state;
	rng-&gt;state = oldstate * 6364136223846793005ULL + (rng-&gt;inc|<span class="dv">1</span>);
	u32 xorshifted = ((oldstate &gt;&gt; 18u) ^ oldstate) &gt;&gt; 27u;
	u32 rot = oldstate &gt;&gt; 59u;
	<span class="kw">return</span> (xorshifted &gt;&gt; rot) | (xorshifted &lt;&lt; ((-rot) &amp; <span class="dv">31</span>));
}

u32 uniform32(<span class="dt">int</span> range, pcg32_random_t *rng)
{
	<span class="dt">unsigned</span> rand_limit, rand_excess;
	u32 x;
	rand_excess = ((UINT32_MAX % range) + <span class="dv">1</span>) % range;
	rand_limit = UINT32_MAX - rand_excess;
	<span class="kw">while</span> ((x = pcg32_random_r(rng)) &gt; rand_limit) {};
	<span class="kw">return</span> x % range;
}

<span class="co">/* Populate an array with increasing numbers; we randomly choose whether to skip</span>
<span class="co"> * to the next number by an increment of 1 or 2, so as to initialize the array</span>
<span class="co"> * slightly differently each time this function is called.</span>
<span class="co"> */</span>
u32 init_array(u32 *keys, bool has_key, pcg32_random_t *rng)
{
	<span class="dt">int</span> i, j;
	<span class="kw">for</span> (i = <span class="dv">0</span>, j = <span class="dv">0</span>; i &lt; KEYS_TOTAL; i++) {
		j += uniform32(<span class="dv">2</span>, rng);
		keys[i] = i + j;
	}

	<span class="co">/*</span>
<span class="co">	 * If we want to choose a key, randomly choose one from one of the</span>
<span class="co">	 * existing elements; otherwise, return an impossible key (where</span>
<span class="co">	 * &quot;impossible&quot; means a key whose value lies outside the range of values</span>
<span class="co">	 * that exist in the array).</span>
<span class="co">	 */</span>
	<span class="kw">if</span> (has_key)
		<span class="kw">return</span> keys[uniform32(KEYS_TOTAL, rng)];
	<span class="kw">else</span>
		<span class="co">/* Impossible key = biggest key + 1 */</span>
		<span class="kw">return</span> keys[KEYS_TOTAL - <span class="dv">1</span>] + <span class="dv">1</span>;
}

<span class="dt">int</span> binary_search(u32 *keys, u32 key, <span class="dt">int</span> min, <span class="dt">int</span> max)
{
	<span class="dt">int</span> list_size;
	<span class="dt">int</span> mid;

	list_size = (max - min) + <span class="dv">1</span>;
	<span class="kw">if</span> (list_size == <span class="dv">0</span>)
		<span class="kw">return</span> KEY_NOT_FOUND;

	mid = (list_size / <span class="dv">2</span>) + min;

	<span class="kw">if</span> (key &lt; keys[mid]) {
		<span class="kw">return</span> binary_search(keys, key, min, mid - <span class="dv">1</span>);
	} <span class="kw">else</span> <span class="kw">if</span> (key &gt; keys[mid]) {
		<span class="kw">return</span> binary_search(keys, key, mid + <span class="dv">1</span>, max);
	} <span class="kw">else</span> {
		<span class="kw">return</span> mid;
	}
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv)
{
	<span class="dt">int</span> i, min, max;
	<span class="dt">int</span> mid;
	bool has_key;
	u32 *keys;
	u32 key;
	pcg32_random_t rng = {0x1234567890abcdefULL, 0x1234567890abcdefULL};

	<span class="co">/* RNG self-test. */</span>
	<span class="kw">if</span> (argc &gt; <span class="dv">1</span> &amp;&amp; strcmp(argv[<span class="dv">1</span>], <span class="st">&quot;rng&quot;</span>) == <span class="dv">0</span>) {
		printf(<span class="st">&quot;Running RNG self-test.</span><span class="ch">\n</span><span class="st">&quot;</span>);
		printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, pcg32_random_r(&amp;rng));
		<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">1000000</span>; i++) {
			pcg32_random_r(&amp;rng);
		}
		printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, pcg32_random_r(&amp;rng));
		<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">100</span>; i++) {
			printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>,
				uniform32((UINT32_MAX / <span class="dv">2</span>) + (UINT32_MAX / <span class="dv">3</span>),
				&amp;rng));
		}
		keys = malloc(KEYS_TOTAL * <span class="kw">sizeof</span>(u32));
		<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++) {
			has_key = (bool)uniform32(<span class="dv">2</span>, &amp;rng);
			key = init_array(keys, has_key, &amp;rng);
			printf(<span class="st">&quot;last number in array %d for key %&quot;</span>PRIu32<span class="st">&quot;: &quot;</span>,
				i, key);
			printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, keys[KEYS_TOTAL - <span class="dv">1</span>]);
		}
		printf(<span class="st">&quot;Done.</span><span class="ch">\n</span><span class="st">&quot;</span>);
		printf(<span class="st">&quot;END C VERSION</span><span class="ch">\n</span><span class="st">&quot;</span>);
		free(keys);
		<span class="kw">return</span> <span class="dv">0</span>;
	}

	<span class="co">/*</span>
<span class="co">	 * Allocate space for our big array of keys, as well as our</span>
<span class="co">	 * in-place-modified &quot;mid&quot; value.</span>
<span class="co">	 */</span>
	keys = malloc(KEYS_TOTAL * <span class="kw">sizeof</span>(u32));

	<span class="co">/* Stress-test binary_search(). */</span>
	<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">20</span>; i++) {
		has_key = (bool)uniform32(<span class="dv">2</span>, &amp;rng);
		key = init_array(keys, has_key, &amp;rng);
		min = <span class="dv">0</span>;
		max = KEYS_TOTAL - <span class="dv">1</span>;
		mid = binary_search(keys, key, min, max);
		printf(<span class="st">&quot;%02d - &quot;</span>, i + <span class="dv">1</span>);
		<span class="kw">if</span> (mid == KEY_NOT_FOUND) {
			printf(<span class="st">&quot;key `%&quot;</span>PRIu32<span class="st">&quot;&#39; not found.</span><span class="ch">\n</span><span class="st">&quot;</span>, key);
		} <span class="kw">else</span> {
			printf(<span class="st">&quot;key `%&quot;</span>PRIu32<span class="st">&quot;&#39; found at keys[%d].</span><span class="ch">\n</span><span class="st">&quot;</span>,
				key, mid);
		}
	}

	printf(<span class="st">&quot;END C VERSION</span><span class="ch">\n</span><span class="st">&quot;</span>);
	free(keys);
	<span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search.c"  mimetype=text/plain > binary-search.c </a>
</div>
</div>
<p>Overview:</p>
<ul>
<li><code>pcg32_random_r()</code> is PCG’s minimal implementation version. This is RNG we depend on to get identical randomly-generated data in the other Ruby and Haskell versions.</li>
<li><code>uniform32()</code> tames all raw RNG’s like <code>pcg32_random_r()</code>; it <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">removes any bias</a> that might be introduced if we were to use a simple modulo operation. Hence, we use <code>uniform32()</code> for all our RNG needs.</li>
<li><code>init_array()</code> takes an empty array of fixed size, and populates it with semi-random numbers. I say <em>semi-random</em> because the number chosen to populate the array, in sequence, is steadily bumped up with the <code>j</code> variable, <strong>eliminating the need for sorting it afterwards</strong> in preparation for passing it to <code>binary_search()</code>.</li>
<li>Finally, we have <code>binary_search()</code> itself, written in a way to closely match the pseudocode presented above.</li>
</ul>
<p>I’ve tried to keep the code simple. You may find it disturbing that we use the same type for <code>KEY_NOT_FOUND</code> as the actual valid key value (<code>mid</code>) itself. This kind of type overloading is common in C, and is what gives C its bare metal speed — at the cost of (probable) disaster, of course.</p>
<h3 id="ruby-version">Ruby Version</h3>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="co"># LICENSE: PUBLIC DOMAIN</span>

<span class="co"># Interact with `irb -I . -r path/to/this/file&#39;.</span>

<span class="co"># Usage: just execute the binary as-is without any arguments. To test the RNG,</span>
<span class="co"># call with the argument &quot;rng&quot;.</span>

<span class="dt">U32_MAX</span> = <span class="bn">0xffffffff</span>
<span class="dt">U64_MAX</span> = <span class="bn">0xffffffffffffffff</span>
<span class="dt">U32_MOD</span> = <span class="dt">U32_MAX</span> + <span class="dv">1</span>
<span class="dt">U64_MOD</span> = <span class="dt">U64_MAX</span> + <span class="dv">1</span>

<span class="dt">KEYS_TOTAL</span> = <span class="dv">1000000</span>

<span class="kw">class</span> <span class="dt">PCG32</span>
	<span class="ot">@state</span>
	<span class="ot">@inc</span>

	<span class="kw">def</span> initialize(state, inc)
		<span class="ot">@state</span> = state
		<span class="ot">@inc</span> = inc
	<span class="kw">end</span>

	<span class="kw">def</span> pcg32_random_r
		oldstate = <span class="ot">@state</span>
		<span class="ot">@state</span> = (((oldstate * <span class="dv">6364136223846793005</span>) % <span class="dt">U64_MOD</span>) +
			(<span class="ot">@inc</span> | <span class="dv">1</span>)) % <span class="dt">U64_MOD</span>
		xorshifted = (((oldstate &gt;&gt; <span class="dv">18</span>) ^ oldstate) &gt;&gt; <span class="dv">27</span>) % <span class="dt">U32_MOD</span>
		rot = oldstate &gt;&gt; <span class="dv">59</span>
		(xorshifted &gt;&gt; rot) | ((xorshifted &lt;&lt; ((-rot) &amp; <span class="dv">31</span>)) % <span class="dt">U32_MOD</span>)
	<span class="kw">end</span>

	<span class="kw">def</span> uniform32(range)
		rand_excess = ((<span class="dt">U32_MAX</span> % range) + <span class="dv">1</span>) % range
		rand_limit = <span class="dt">U32_MAX</span> - rand_excess
		<span class="kw">while</span> ((x = <span class="dv">self</span>.pcg32_random_r) &gt; rand_limit)
		<span class="kw">end</span>
		x % range
	<span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> init_array(keys, has_key, rng)
	j = <span class="dv">0</span>
	<span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0</span>..(<span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>)
		j += rng.uniform32(<span class="dv">2</span>)
		keys[i] = i + j
	<span class="kw">end</span>

	<span class="kw">if</span> has_key
		keys[rng.uniform32(<span class="dt">KEYS_TOTAL</span>)]
	<span class="kw">else</span>
		keys[<span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>] + <span class="dv">1</span>
	<span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> binary_search(keys, key, min, max)
	list_size = (max - min) + <span class="dv">1</span>
	<span class="kw">if</span> (list_size == <span class="dv">0</span>)
		<span class="kw">return</span> <span class="dv">nil</span>
	<span class="kw">end</span>

	mid = (list_size / <span class="dv">2</span>) + min

	<span class="kw">if</span> (key &lt; keys[mid])
		binary_search(keys, key, min, mid - <span class="dv">1</span>)
	<span class="kw">elsif</span> (key &gt; keys[mid])
		binary_search(keys, key, mid + <span class="dv">1</span>, max)
	<span class="kw">else</span>
		mid
	<span class="kw">end</span>
<span class="kw">end</span>

<span class="co"># Begin program</span>

rng = <span class="dt">PCG32</span>.new(<span class="bn">0x1234567890abcdef</span>, <span class="bn">0x1234567890abcdef</span>)

<span class="co"># RNG self-test.</span>
<span class="kw">if</span> (<span class="dt">ARGV</span> == [<span class="st">&quot;rng&quot;</span>])
	puts <span class="st">&quot;Running RNG self-test.&quot;</span>
	puts rng.pcg32_random_r
	<span class="kw">for</span> n <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">999999</span>
		rng.pcg32_random_r
	<span class="kw">end</span>
	puts rng.pcg32_random_r
	<span class="kw">for</span> n <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">99</span>
		puts rng.uniform32((<span class="dt">U32_MAX</span> / <span class="dv">2</span>) + (<span class="dt">U32_MAX</span> / <span class="dv">3</span>))
	<span class="kw">end</span>
	<span class="kw">for</span> n <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">9</span>
		has_key = rng.uniform32(<span class="dv">2</span>) == <span class="dv">1</span>
		keys = []
		key = init_array(keys, has_key, rng)
		puts <span class="st">&quot;last number in array </span><span class="ot">#{</span>n<span class="ot">}</span><span class="st"> for key </span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">: </span><span class="ot">#{</span>keys[<span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>]<span class="ot">}</span><span class="st">&quot;</span>
	<span class="kw">end</span>
	puts <span class="st">&quot;Done.&quot;</span>
	puts <span class="st">&quot;END RUBY VERSION&quot;</span>
	exit
<span class="kw">end</span>

keys = []

<span class="co"># Stress-test &#39;binary_search&#39; method.</span>
<span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">19</span>
	has_key = rng.uniform32(<span class="dv">2</span>) == <span class="dv">1</span>
	key = init_array(keys, has_key, rng)
	min = <span class="dv">0</span>
	max = <span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>
	mid = binary_search(keys, key, min, max)
	printf(<span class="st">&quot;%02d - &quot;</span>, i + <span class="dv">1</span>)
	<span class="kw">if</span> mid.nil?
		puts <span class="st">&quot;key `</span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">&#39; not found.&quot;</span>
	<span class="kw">else</span>
		puts <span class="st">&quot;key `</span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">&#39; found at keys[</span><span class="ot">#{</span>mid<span class="ot">}</span><span class="st">].&quot;</span>
	<span class="kw">end</span>
<span class="kw">end</span>
puts <span class="st">&quot;END RUBY VERSION&quot;</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search.rb"  mimetype=text/plain > binary-search.rb </a>
</div>
</div>
<p>This version, like the Haskell version, tries to follow the C version as much as possible. One drawback of this version is that because Ruby does not support fixed-width integers, we have to make liberal use of the modulo operator <code>%</code> to emulate integer overflow. We could just do a bitwise AND (<code>&amp;</code>) with a mask, but that would risk increased verbosity.</p>
<h3 id="haskell-version">Haskell Version</h3>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span>

<span class="co">-- LICENSE: PUBLIC DOMAIN</span>
<span class="fu">--</span>
<span class="co">-- Compile with `ghc --make -Wall -Werror -O2 -dynamic -o binary-search-hs</span>
<span class="co">-- binary-search.hs&#39;. For better conformance with the C and Ruby versions, we</span>
<span class="co">-- use snake_case instead of camelCase wherever there is a direct parallel.</span>
<span class="fu">--</span>
<span class="co">-- Interact with `ghci path/to/this/file`.</span>
<span class="fu">--</span>
<span class="co">-- Usage: just execute the binary as-is without any arguments. To test the RNG,</span>
<span class="co">-- call with the argument &quot;rng&quot;.</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Bits</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">System.Environment</span>
<span class="kw">import </span><span class="dt">System.Exit</span>
<span class="kw">import </span><span class="dt">Text.Printf</span>

<span class="ot">u32_max ::</span> <span class="dt">Word32</span>
u32_max <span class="fu">=</span> <span class="bn">0xffffffff</span>

<span class="ot">keys_total ::</span> <span class="dt">Int</span>
keys_total <span class="fu">=</span> <span class="dv">1000000</span>

<span class="kw">data</span> <span class="dt">PCG32</span> <span class="fu">=</span> <span class="dt">PCG32</span>
	{<span class="ot"> state ::</span> <span class="dt">Word64</span>
	,<span class="ot"> inc ::</span> <span class="dt">Word64</span>
	}

<span class="ot">pcg32_random_r ::</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> (<span class="dt">Word32</span>, <span class="dt">PCG32</span>)
pcg32_random_r rng<span class="fu">@</span><span class="dt">PCG32</span>{<span class="fu">..</span>} <span class="fu">=</span> (result, rng {state <span class="fu">=</span> state&#39;})
	<span class="kw">where</span>
<span class="ot">	state&#39; ::</span> <span class="dt">Word64</span>
	state&#39; <span class="fu">=</span> state <span class="fu">*</span> <span class="dv">6364136223846793005</span> <span class="fu">+</span> (inc <span class="fu">.|.</span> <span class="dv">1</span>)
<span class="ot">	xorshifted ::</span> <span class="dt">Word32</span>
	xorshifted <span class="fu">=</span> fromIntegral <span class="fu">$</span> shiftR (xor (shiftR state <span class="dv">18</span>) state) <span class="dv">27</span>
<span class="ot">	rot ::</span> <span class="dt">Word32</span>
	rot <span class="fu">=</span> fromIntegral <span class="fu">$</span> shiftR state <span class="dv">59</span>
<span class="ot">	result ::</span> <span class="dt">Word32</span>
	result <span class="fu">=</span> fromIntegral
		<span class="fu">$</span> (shiftR xorshifted <span class="fu">$</span> fromIntegral rot)
			<span class="fu">.|.</span> (shiftL xorshifted <span class="fu">$</span> fromIntegral ((<span class="fu">-</span>rot) <span class="fu">.&amp;.</span> <span class="dv">31</span>))

<span class="ot">uniform32 ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> (<span class="dt">Word32</span>, <span class="dt">PCG32</span>)
uniform32 range rng <span class="fu">=</span> find_within_range rng
	<span class="kw">where</span>
<span class="ot">	rand_excess ::</span> <span class="dt">Word32</span>
	rand_excess <span class="fu">=</span> mod ((mod u32_max range) <span class="fu">+</span> <span class="dv">1</span>) range
<span class="ot">	rand_limit ::</span> <span class="dt">Word32</span>
	rand_limit <span class="fu">=</span> u32_max <span class="fu">-</span> rand_excess
	find_within_range rng&#39; <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&gt;</span> rand_limit
		<span class="kw">then</span> find_within_range rng&#39;&#39;
		<span class="kw">else</span> (mod x range, rng&#39;&#39;)
		<span class="kw">where</span>
		(x, rng&#39;&#39;) <span class="fu">=</span> pcg32_random_r rng&#39;

<span class="ot">init_array ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> ([<span class="dt">Word32</span>], <span class="dt">Word32</span>, <span class="dt">PCG32</span>)
init_array keys_size has_key rng0 <span class="fu">=</span> (keys, key, rng3)
	<span class="kw">where</span>
	(keys&#39;, rng1) <span class="fu">=</span> genKeysList [] <span class="dv">0</span> <span class="dv">0</span> rng0
	<span class="co">-- Need to reverse the list, because Haskell (like all Lispy languages?)</span>
	<span class="co">-- builds a list backwards when using the cons (:) operator.</span>
	keys <span class="fu">=</span> reverse keys&#39;
<span class="ot">	genKeysList ::</span> [<span class="dt">Word32</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> ([<span class="dt">Word32</span>], <span class="dt">PCG32</span>)
	genKeysList arr i j0 rng <span class="fu">=</span> <span class="kw">if</span> i <span class="fu">&lt;</span> keys_size
		<span class="kw">then</span> genKeysList ((i&#39; <span class="fu">+</span> j2&#39;)<span class="fu">:</span>arr) (i <span class="fu">+</span> <span class="dv">1</span>) j2 rng&#39;
		<span class="kw">else</span> (arr, rng)
		<span class="kw">where</span>
		i&#39; <span class="fu">=</span> fromIntegral i
		j2&#39; <span class="fu">=</span> fromIntegral j2
		(j1, rng&#39;) <span class="fu">=</span> uniform32 <span class="dv">2</span> rng
		j2 <span class="fu">=</span> j0 <span class="fu">+</span> fromIntegral j1
	(key, rng3) <span class="fu">=</span> <span class="kw">if</span> has_key
		<span class="kw">then</span>
			<span class="kw">let</span>
				(idx, rng2) <span class="fu">=</span> uniform32 (fromIntegral keys_total) rng1
			<span class="kw">in</span>
			(keys<span class="fu">!!</span>(fromIntegral idx), rng2)
		<span class="kw">else</span> (keys<span class="fu">!!</span>(keys_total <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">1</span>, rng1)

<span class="co">-- We use min&#39; and max&#39; because the non-apostrophe versions name-clash with</span>
<span class="co">-- Prelude&#39;s own functions. We could hide Prelude&#39;s imports, but that seems too</span>
<span class="co">-- roundabout.</span>
<span class="ot">binary_search ::</span> [<span class="dt">Word32</span>] <span class="ot">-&gt;</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
binary_search keys key min&#39; max&#39;
	<span class="fu">|</span> list_size <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
	<span class="fu">|</span> key <span class="fu">&lt;</span> keys<span class="fu">!!</span>mid <span class="fu">=</span> binary_search keys key min&#39; (mid <span class="fu">-</span> <span class="dv">1</span>)
	<span class="fu">|</span> key <span class="fu">&gt;</span> keys<span class="fu">!!</span>mid <span class="fu">=</span> binary_search keys key (mid <span class="fu">+</span> <span class="dv">1</span>) max&#39;
	<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> mid
	<span class="kw">where</span>
	list_size <span class="fu">=</span> (max&#39; <span class="fu">-</span> min&#39;) <span class="fu">+</span> <span class="dv">1</span>
	mid <span class="fu">=</span> (div list_size <span class="dv">2</span>) <span class="fu">+</span> min&#39;

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
	<span class="kw">let</span>
		rng0 <span class="fu">=</span> <span class="dt">PCG32</span>
			{ state <span class="fu">=</span> <span class="bn">0x1234567890abcdef</span>
			, inc <span class="fu">=</span> <span class="bn">0x1234567890abcdef</span>
			}
	args <span class="ot">&lt;-</span> getArgs
	when (args <span class="fu">==</span> [<span class="st">&quot;rng&quot;</span>]) <span class="fu">$</span> <span class="kw">do</span>
		putStrLn <span class="st">&quot;Running RNG self-test&quot;</span>
		<span class="kw">let</span>
			(num0, rng1) <span class="fu">=</span> pcg32_random_r rng0
		putStrLn <span class="fu">$</span> show num0
		rng2 <span class="ot">&lt;-</span> foldM warmupRng rng1 [<span class="dv">0</span><span class="fu">..</span><span class="dv">999999</span><span class="ot">::</span><span class="dt">Int</span>]
		<span class="kw">let</span>
			(num1, rng3) <span class="fu">=</span> pcg32_random_r rng2
		putStrLn <span class="fu">$</span> show num1
		rng4 <span class="ot">&lt;-</span> foldM testUniform32 rng3 [<span class="dv">0</span><span class="fu">..</span><span class="dv">99</span><span class="ot">::</span><span class="dt">Int</span>]
		_ <span class="ot">&lt;-</span> foldM testArray rng4 [<span class="dv">0</span><span class="fu">..</span><span class="dv">9</span><span class="ot">::</span><span class="dt">Int</span>]
		putStrLn <span class="st">&quot;Done.&quot;</span>
		putStrLn <span class="st">&quot;END HASKELL VERSION&quot;</span>
		exitSuccess
	_ <span class="ot">&lt;-</span> foldM testBinarySearch rng0 [<span class="dv">0</span><span class="fu">..</span><span class="dv">19</span><span class="ot">::</span><span class="dt">Int</span>]
	putStrLn <span class="st">&quot;END HASKELL VERSION&quot;</span>
	<span class="kw">where</span>
	warmupRng rng _ <span class="fu">=</span> return <span class="fu">.</span> snd <span class="fu">$</span> pcg32_random_r rng
	testUniform32 rng _ <span class="fu">=</span> <span class="kw">do</span>
		putStrLn <span class="fu">$</span> show num
		return rng&#39;
		<span class="kw">where</span>
		(num, rng&#39;) <span class="fu">=</span> uniform32 (div u32_max <span class="dv">2</span> <span class="fu">+</span> div u32_max <span class="dv">3</span>) rng
	testArray rng0 i <span class="fu">=</span> <span class="kw">do</span>
		putStrLn <span class="fu">$</span> <span class="st">&quot;last number in array &quot;</span>
			<span class="fu">++</span> show i
			<span class="fu">++</span> <span class="st">&quot; for key &quot;</span>
			<span class="fu">++</span> show key
			<span class="fu">++</span> <span class="st">&quot;: &quot;</span>
			<span class="fu">++</span> show (keys<span class="fu">!!</span>(keys_total <span class="fu">-</span> <span class="dv">1</span>))
		return rng2
		<span class="kw">where</span>
		(res, rng1) <span class="fu">=</span> uniform32 <span class="dv">2</span> rng0
		has_key <span class="fu">=</span> res <span class="fu">==</span> <span class="dv">1</span>
		(keys, key, rng2) <span class="fu">=</span> init_array keys_total has_key rng1
	testBinarySearch rng0 i <span class="fu">=</span> <span class="kw">do</span>
		printf <span class="st">&quot;%02d - &quot;</span> (i <span class="fu">+</span> <span class="dv">1</span>)
		<span class="kw">case</span> foundMid <span class="kw">of</span>
			<span class="dt">Just</span> mid <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;key `&quot;</span>
				<span class="fu">++</span> show key
				<span class="fu">++</span> <span class="st">&quot;&#39; found at keys[&quot;</span>
				<span class="fu">++</span> show mid
				<span class="fu">++</span> <span class="st">&quot;].&quot;</span>
			<span class="dt">Nothing</span> <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;key `&quot;</span>
				<span class="fu">++</span> show key
				<span class="fu">++</span> <span class="st">&quot;&#39; not found.&quot;</span>
		return rng2
		<span class="kw">where</span>
		(res, rng1) <span class="fu">=</span> uniform32 <span class="dv">2</span> rng0
		has_key <span class="fu">=</span> res <span class="fu">==</span> <span class="dv">1</span>
		(keys, key, rng2) <span class="fu">=</span> init_array keys_total has_key rng1
		min&#39; <span class="fu">=</span> <span class="dv">0</span>
		max&#39; <span class="fu">=</span> keys_total <span class="fu">-</span> <span class="dv">1</span>
		foundMid <span class="fu">=</span> binary_search keys key min&#39; max&#39;</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search.hs"  mimetype=text/plain > binary-search.hs </a>
</div>
</div>
<p>It pained me not to make use of Haskell’s much faster, efficient <code>Array</code> data structure instead of plain lists (that are constructed with the square brackets <code>[]</code>). And, I have to admit that it is written in a strange style; I’ve preserved the names of the variables from C and Ruby where I could, even though mixing snake_case with camelCase results in utter ugliness. I also restrained myself from using the <code>State</code> monad for keeping track of <code>PCG32</code>’s state. For you non-Haskellers, that means that I manually passed around RNG state (as you can see with <code>rng0</code>, <code>rng1</code>, <code>rng2</code>, etc.) as arguments and return values, because I did not want to place another barrier against quickly grasping the code. Do you really want monad transformers in a “naive” implementation?<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></p>
<p>The most immediate effect to me when writing the Haskell version was just how stateful the <code>uniform32()</code> and <code>init_array()</code> functions were. The C/Ruby brethren perform lots of variable mutation in those parts, and are consequently difficult to understand from a <em>pure</em> (type system) perspective. All of the silent type promotions in C were blatantly exposed by the Glasgow Haskell Compiler (GHC), making it necessary for me to include all of those explicit <code>fromIntegral</code> type promotions myself in <code>pcg32_random_r</code> and <code>init_array</code>.</p>
<p>But even with all of these explicit conversions and the un-idiomatic Haskell style (excluding coding style), I find the Haskell version much easier to understand. Just compare how clean <code>binary_search</code> looks in Haskell versus the other ones! And the fact that you can basically define nested functions/methods with the <code>where</code> clause makes hole-driven development a piece of cake.</p>
<h2 id="conclusion-and-hopes">Conclusion and Hopes</h2>
<p>I hope you’ve enjoyed looking at the various implementations of binary search. Binary search is certainly something you can write on your own, although getting the surrounding technicalities correct can be a chore — but isn’t that always the case when trying to obvserve the behavior of an algorithm in practice? You can look at the cute 10 or 15-line pseudocode on Wikipedia all day, but how can you be sure that it works? This focus on <strong>real world examples</strong> has been a driving principle behind all of my blog posts, and I hope it has helped you understand the algorithm better.</p>
<p>Binary search is something you can apply in real life, too. For me, I came into contact with it again when I learned about <code>git bisect</code>. I personally try to use binary search myself when I code; for example, if a large block of code does not work, I delete large chunks out, making the deletions ever finer, until I get to the source of the problem. You can think of these examples as binary search, where the key is the (as yet unknown) bad commit or line of code you have to fix. You can be your own algorithm! Isn’t that cool?</p>
<p>Thanks for reading, and happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It’s like in the children’s <a href="http://en.wikipedia.org/wiki/Chinese_whispers">“Telephone”</a> game, where the error of one person gets magnified at every step, until the end when the message gets so garbled up it becomes comical.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>“Hole-driven-development”, as I like to call it, is a top-down approach to development. You first define the larger pieces, and continuously define the smaller sub-pieces, until you reach atomic pieces (those pieces which cannot be further sub-divided). You might have noticed that this style of writing code has an eerie parallel to the whole (no pun intended!) discussion about binary subdivision, and so forth.</p>
<p>As an aside, in the Haskell community, <em>hole-driven Haskell</em> takes the same approach, but first you define the behaviors of the functions through its type signatures, and leave the implementation details undefined. This way, you can use the compiler’s type system to help you define what you want as you go; this is certainly a step up from <em>unassisted</em> hole-driven development that we are doing with the pseudocode here.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The condition <code>first_index &gt; last_index</code> might not make sense. This was the pseudocode on Wikipedia at the time I wrote this, and it didn’t make sense to me at first. But think of it this way: binary search involves division of the list into halves, repeatedly. So <code>first_index</code> and <code>last_index</code> get closer and closer to each other. The point is that the distance between these two markers will close, shrinking the list into smaller and smaller subparts. We can’t simply check if these two points meet, by writing <code>first_index == last_index</code>, because of the base case of a 1-element list. Such a list will have <code>first_index</code> as 0, and the <code>last_index</code> as also 0 — because there is only 1 index! In this case, the condition <code>first_index == last_index</code> to check for an empty list is inadequate.</p>
<p>If you look at how we call <code>binary_search()</code> again in lines 15 and 17, you will notice that the new definitions of <code>first_index</code> and <code>last_index</code> depend on <code>middle_index</code>, and it’s this interplay with <code>middle_index</code> that forces <code>last_index</code> to eventually become smaller than <code>first_index</code>. If you work out the algorithm through some small cases, you will see this happen eventually.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Linear search does have the advantage that, on a sorted list, it can take advantage of branch prediction. This is because the <code>if/else</code> test will <em>always go in one direction</em>, until when we get a match or when the element considered is greater than the search key. But in the long run as you increase the search space, binary search will beat linear search hands down.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>However, be mindful to the fact that binary search relies on the input list being sorted. Sorting a list itself is a fundamental problem in computer science, and there are numerous sorting algorithms as well as data structures that make such sorting more amenable. In the real world, I think 90% of your time is going to be spent sorting the list first, by which time the speed benefits of binary search probably won’t hold much influence. If the search space is always small, you could easily get away with linear search — why bother adding complexity where you don’t need it?<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>You could trivially add on a proper command-line argument handling mechanism. In particular, <code>KEYS_TOTAL</code> is dying to be decoupled from the program’s internals — but I leave that as an exercise to you. (Hint: use a command-line option parsing library!)<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>MELISSA E. O’NEILL (2009). The Genuine Sieve of Eratosthenes. Journal of Functional Programming, 19, pp 95-106. doi:10.1017/S0956796808007004. <a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">Online draft version</a>.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>What if I had indeed made use of the <code>State</code> monad, you ask? Well, first I wouldn’t need to pass in, or get back, the RNG state variables. I would just run the RNG-state-changing functions <em>inside</em> the <code>State</code> monad (actually, probably the <code>StateT</code> monad transformer as we’re in the <code>IO</code> monad anyway), to <code>get</code>/<code>put</code> the RNG states to read/write those values.<a href="#fnref8">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>

</feed>
