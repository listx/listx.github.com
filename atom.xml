<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Linus's Blog</title>
    <link href="http://funloop.org/atom.xml" rel="self" />
    <link href="http://funloop.org" />
    <id>http://funloop.org/atom.xml</id>
    <author>
        <name>Linus Arver</name>
        <email></email>
    </author>
    <updated>2016-04-29T00:00:00Z</updated>
    <entry>
    <title>Software Development Philosophy</title>
    <link href="http://funloop.org/post/2016-04-29-software-development-philosophy.html" />
    <id>http://funloop.org/post/2016-04-29-software-development-philosophy.html</id>
    <published>2016-04-29T00:00:00Z</published>
    <updated>2016-04-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2016-04-29</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2016-04-29-software-development-philosophy.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>
</div>

<p>I’ve been meaning to write about software development best practices for a while now. Here are some things that I believe in, after having distilled countless blog posts, comments, and arguments over the years.</p>
<h1 id="take-version-control-seriously">1: Take version control seriously</h1>
<p>Learning how to use version control was easily one of the big eye-opening events in my technical journey. I get sad when I see commit messages without any real explanation such as “Ugh!” or “Oops”.</p>
<p>Although modern version control systems have many technical benefits (distributed nature allowing parallel collaboration, guaranteed data integrity, etc), I believe that the overruling importance of version control is <strong>history preservation</strong>. Reading the commit history of a well-maintained project is a pleasure: each commit explains why that commit was necessary at the time it was written, with references to other documents, bug reports, etc. If you have fine-grained commits, you can go back in time to reproduce bugs, or even use things like <strong>git-bisect</strong> to figure out which commit introduced a bug. If you are working to fix a regression that was introduced “around two months ago,” the last thing you want to do is look at 2-month old commits with useless commit messages.</p>
<h1 id="be-consistent">2: Be consistent</h1>
<p>No one can deny the power of simplicity. On the other hand, how do we achieve simplicity?</p>
<p>Start by being consistent. There are multiple domains of “consistency” in a software project but here are some basic ones: coding style, naming convention, and comments. Yes, comments have to be written in a particular way as well! Let’s look at each in turn.</p>
<h2 id="coding-style">Coding style</h2>
<p>The simplest form of consistency is coding style. Every project must have some general consensus for coding style. Although 100% adherence may not be practical, you should at least make all <em>new</em> code follow the same convention. Automated linters can help in this area.</p>
<h2 id="naming-convention">Naming convention</h2>
<p>This is a superset of coding style. If you have variable names, they should be consistently named. If you use the term <strong>cfg</strong> in one variable or function, you should use it everywhere; do not use <strong>conf</strong> or <strong>config</strong> elsewhere.</p>
<p>For functions, quite often in imperative languages they perform some action. And naturally, the action is performed on something. Now, where do we put the verb and the direct object? It doesn’t really matter, but be consistent!</p>
<p>For the following functions, notice how the verb comes before the object, consistently:</p>
<ul>
<li><code>init_config()</code></li>
<li><code>init_hash()</code></li>
<li><code>mark_foo()</code></li>
<li><code>gen_foo()</code></li>
</ul>
<p>. I believe that such subtle details do matter in the long run.</p>
<h2 id="comments">Comments</h2>
<p>Too often I find random-looking comments strewn across a single file — some one-liners, some just one word, etc. Comments should be written in a consistent style, too!</p>
<p>Comments form the backbone of documentation for anyone not intimately familiar with the codebase. Thus, comments should never assume that the reader knows the basics of what’s going on. Rather, comments should strive to explain things to the layman, the outsider.</p>
<p>Writing comments in this style does not mean that you should always repeat everything from zero; instead, explain the general bird’s eye view in one place, and refer to this introductory view. Also, avoid writing one-liner comments if you can, as they encourage laziness and half-baked explanations (how much meaning can you really convey in 1 line?); write a nice explanation for each “atomic” unit of code — this is typically one function definition.</p>
<p>Lastly, do not comment out code and check it into a commit! This is a habit of the era before version control became popular. If you really want to save commented code, at least preface it with an explanation. Mystery dead code is the worst!</p>
<h1 id="have-one-source-of-truth">3: Have one source of truth</h1>
<p>This is another way of saying the DRY principle (“Do not Repeat Yourself”) which I find somewhat vague. I hereby coin this rule as the HOST principle (“Have One Source of Truth”).</p>
<p>Under the HOST principle, if you are working with multiple components that depend on each other, it’s important to establish who is the original source for which things. Any component that feeds from the source of truth must act subserviently to the originator, as far as that piece of truth is concerned. The Object-Oriented Programming model encapsulates this with public and private methods; in the purely functional model this is less of a concern because of the lack of side effects.</p>
<p>This is the one principle that gets overlooked time and again. It’s probably because the HOST principle can be violated in so many ways. Below are some typical violations.</p>
<h2 id="global-variables">Global variables</h2>
<p>Whereas global <strong>constants</strong> would be fine, global <strong>variables</strong> by their very nature allow anything to edit the originating source of truth. The result, all too often, is spaghetti code where it is unclear which function has authority over another function.</p>
<h2 id="non-modularity">Non-modularity</h2>
<p>A common mistake is when people do not make things modular and just copy/paste large files making minor changes between each one. For example, let’s say that there exists 3 different developer environments — “development”, “staging”, and “production” — and that each one shares about 90% of the configuration values, with the other 10% changing depending on the environment. You should not write 3 separate files; instead, you should keep in source control 1 file with all of the various values, and have some other process automatically generate the individual environment-specific configuration file. This way, you don’t have to edit 3 files when you make some global change that affects all environments.</p>
<h2 id="lack-of-testing">Lack of testing</h2>
<p>In the ideal world, every program ships with a contract, telling the user that the program will do X, Y, and Z, in such and such a way under such and such conditions. This contract would be the source of truth about a program’s intended behavior at runtime. Alas, such “contracts” do not exist, at least at the program-behavior-at-runtime level. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> While excellent documentation, commit history, and even community-driven “best practices” all attempt to define how a program behaves and what to expect, they still bow down to the test suite. This is because tests, by their very nature, are written expressly to keep in line the behavior of a program over its lifetime.</p>
<p>Not all projects can have the traditional test suite covering every corner case (e.g., the Linux Kernel is one such project). But most projects can. At the very least, you should have some standard practice or system of ensuring that your program is stable and behaves as intended.</p>
<h1 id="accuracy-is-more-important-than-performance">4: Accuracy is more important than performance</h1>
<p>Ultimately, software is written to perform some <strong>task</strong>. If your software does not perform that task, it is useless. Your code should care foremost about correctness (being free from bugs).</p>
<p>Whereas performance can always be improved given a naive (but correct) implementation, it is not so the other way around — a highly-performant yet buggy implementation cannot be easily debugged while maintaining existing performance benchmarks.</p>
<h1 id="be-cautious-of-new-code">5: Be cautious of new code</h1>
<p>Old code exists because it worked last year, last month, two weeks ago, and yesterday. Let that sink in. At the end of the day, something that works makes the <strong>user</strong> happy.</p>
<p>If you have a new design or some new way of doing something, it better be superior to the old way. It should be as clear as night and day. Typically, new code is in bug fixes, where the “night and day” difference is obvious. But sometimes it is in new features or even in refactored code — and still, it should be judged against the same high standards.</p>
<p>When I <a href="./2014-09-09-my-first-contribution-to-git.html">submitted my patch to fix some Git documentation</a> some years back, I originally submitted 7 commits. Of the 7, one of them was a patch to update the itemized list syntax; it was purely a change of form, not function. The maintainer (Junio Hamano) questioned this patch, and it was eventually dropped because I really could not make a good case for it. I keep thinking about this encounter once in a while, and remind myself that even something as harmless a documentation change should be treated with caution.</p>
<p>All projects require new code — and this is how projects grow. Growth has to be done in moderation and with great care — this is how software must evolve. We can analogize software growth as mutation over time, with each commit as a particular “mutation”. We choose the best ones (thanks to distributed VCS branching/merging!) one at a time, easing growing pains. Commits with far-reaching changes are the worst type of mutations and should be avoided; an exception is if you have changes that delete more code than add code — these are golden if they can be vetted and proven to work, as they can cut bloat and slim down the codebase.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In the real world, it’s hard to cross all your t’s and dot your i’s — I am no exception with regard to my own projects at home and at work. If I had to pick only one rule from the five above, it would be the first (treat version control seriously). Maybe I am biased because I love Git. Still, it’s hard to argue against having version control; the rest of the guidelines above can be argued against under particular circumstances, but version control remains sacrosanct. Version control is king!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This is one reason why I love purity in Haskell so much — pure functions guarantee their inputs and outputs! It’s like coding with little mini-contracts everywhere!<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>My Quest for Keyboard Perfection: The Esrille Nisse</title>
    <link href="http://funloop.org/post/2016-04-14-esrille-nisse-keyboard.html" />
    <id>http://funloop.org/post/2016-04-14-esrille-nisse-keyboard.html</id>
    <published>2016-04-14T00:00:00Z</published>
    <updated>2016-04-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2016-04-14</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2016-04-14-esrille-nisse-keyboard.org" title="History">*</a>
	<br>
	<a href="/tag/hardware.html">hardware</a>, <a href="/tag/esrille.html">esrille</a>, <a href="/tag/cherry%20mx.html">cherry mx</a>
</div>

<p>About a year ago, I preordered an ErgoDox keyboard from Massdrop. Unfortunately, that order was delayed for months; frustrated and disillusioned with the experience, I searched for an alternative. Eventually I settled on the <a href="https://www.esrille.com/keyboard/">Esrille Nisse</a>. It was more expensive than the ErgoDox, but it looked more ergonomic so I took a leap of faith and decided to buy it. I am glad I did!</p>
<p>I’ve had the Nisse since last October, but did not use it right away. I spent many days spread across six months customizing the firmware and also writing my own keyboard layout optimization program to make the most out of my new keyboard. Every time I thought I had finally settled on a design, I thought of ways of improving it. My initial stab at a first iteration of my custom layout was completed just days ago; I’m just happy to write about it as I promised at the <a href="./2016-01-04-status-update.html">beginning of the year</a>!</p>
<p>Here is a brief review of the Nisse on build quality, comfort, and price, followed by a section on how I’ve customized it (to the extreme!) and my thoughts on going down this path.</p>
<h1 id="build-quality">Build Quality</h1>
<p>The Nisse has a thin outer metal case. You can easily remove the case by undoing a handful of screws. While it doesn’t give an impression of the same kind of build strength as a Filco or Unicomp, it feels well-designed. There is no backplate for the key switches, and this gives the keyboard a much lighter feel. I personally would like it to have a thicker case and backplate, but I imagine that that would move the keyboard up to a much higher price point.</p>
<h1 id="comfort">Comfort</h1>
<p>I ordered mine with Cherry MX Brown switches, and they felt fine. I write in the past tense because, during my long wait for the ErgoDox, I had ordered a set of aftermarket Cherry MX springs which are much stiffer than the stock Brown springs (rated at 67 grams). I swapped out the springs and enjoy them so far; they somewhat imitate the much stiffer buckling spring switches found in the Unicomp but without the loud clicking noise. I should add that I also added 3mm thick O-rings around the stem of each keycap to reduce not only noise but keypress travel to reasonable effect.</p>
<p>Overall, I really love the thumb row of keys. They really make a lot of sense giving each thumb 5 keys to work with on the same row (more ergonomic than the ErgoDox), and I am learning to use my right thumb more (on Qwerty I always use the left thumb for pressing the spacebar, as my brain tends to get confused if I try to use both thumbs for it).</p>
<h1 id="price">Price</h1>
<p>The Nisse is not cheap. I had to pay close to $500 USD for this keyboard and wait a few weeks for it to get produced (it is not a mass-produced item; I am the proud owner of Nisse #42). Given that I don’t spend money on other things in life, I was able to afford it. Still, you should only get something like this if you are serious about your keyboard typing comfort and want to upgrade the experience. My fingers spend many hours every single day on a keyboard, so I trust my investment.</p>
<h1 id="customizability">Customizability</h1>
<p>This is where the Nisse really shines. The firmware is compiled from a handful of C files. This keyboard is unique in that it comes preloaded with multiple layouts; as of the time of this writing, the preloaded layouts are as follows:</p>
<ul>
<li>English
<ul>
<li>Qwerty</li>
<li>Dvorak</li>
<li>Colemak</li>
</ul></li>
<li>Japanese
<ul>
<li>Qwerty (JIS)</li>
<li>Stickney Next</li>
<li>Nicola (Thumb Shift)</li>
<li>M-type</li>
<li>JIS X6004</li>
<li>TRON Kana</li>
</ul></li>
</ul>
<p>. There is also a shared FN layer between the English and Japanese layouts.</p>
<p>Through much trial and error, I was able to incorporate some cool ideas that come with one of the Japanese layouts into my own custom layout, which I’ve dubbed the <a href="https://github.com/listx/new-keyboard/tree/zq">“ZQ” layout</a>. I added an extra “FN2” layer and also made the Shift key “sticky” (premptively hitting the Shift key is enough — no need to press the Shift key simultaneously with a letter key to get a capital letter). In addition, I bound some punctuation marks to be just one keypress, such as double quotes (“), dollar sign ($), and underscore (_). Because of the extra FN2 layer, everything is reachable with minimal effort. In fact, a lot of keys around the far corners of the keyboard are surplus keys and left unbound.</p>
<p>As for the actual keyboard layout, I wrote a <a href="https://github.com/listx/keylo">Haskell program</a> to help find a decent layout. It uses either simulated annealing or a simple hill climber algorithm to find an optimal layout. Because the search space is so large, and because a lot of the rules and penalties for what makes a good layout can be somewhat arbitrary, I’ve discovered that it takes a combination of human guidance (artificially imposed constraints) and computer search to find the most desirable layouts.</p>
<p>Below you can see my layout’s base layer. The empty squares represent empty (unbound) keys. Because I’m using ASCII art to represent the layout, it’s a bit awkward, but I’ve done my best to label the legends with non-interfering symbols so that it is unambiguous. (This is actually better than taking photos because I use blank keycaps.)</p>
<pre><code>    □ □ □ □ □ □     □ □ □ □ □ □
    = ~ / ? &amp;         ` 1 - ! $
□ □ z r d f . 1     2 &quot; y u p q □ □
□ 2 s n t h l :     * x a e i o 3 □ &lt;--- Home row
  3 c w g m ;         &#39; j k b v 4
      4 5 6 7 8     5 , 6 7 8 &lt;--------- Thumb row

Left-side legend
1) Home
2) Shift
3) Escape
4) Super (Windows key)
5) Caps Lock (remapped with xmodmap to Hyper key)
6) Space
7) Enter
8) Control

Right-side legend
1) Underscore
2) End
3) Shift
4) Tab
5) FN2
6) FN
7) Alt
8) Right Alt (aka &quot;AltGr&quot; for US International Layout)
</code></pre>
<p>Here’s my FN layer.</p>
<pre><code>    □ □ □ □ □ □     □ □ □ □ □ □
    □ □ c □ □         □ □ a □ □
□ □ b 7 8 9 □ d     b % [ \ | ] □ □
□ □ a 4 5 6 □ □     □ # { ( ) } □ □
  □ 0 1 2 3 □         ^ &lt; + @ &gt; □
      □ □ □ □ □     □ □ □ □ □

Left-side legend
a) 00 (Macro that presses &#39;0&#39; 2x)
b) 000 (Macro that presses &#39;0&#39; 3x)
c) Shift+Insert
d) Page Up

Right-side legend
a) Super+x (my hotkey to spawn terminals)
b) Page Down
</code></pre>
<p>Finally, this is the FN2 layer.</p>
<pre><code>    □ □ □ □ □ □     □ □ □ □ □ □
    □ □ □ □ □         □ □ □ □ □
□ □ i j k l □ □     □ □ □ a □ □ □ □
□ □ e f g h □ □     □ □ b c d □ □ □
  □ a b c d □         □ □ □ □ □ □
      □ □ □ □ □     □ □ □ □ □

Left-side legend
a) F1
b) F2
c) F3
d) F4
e) F5
f) F6
g) F7
h) F8
i) F9
j) F10
k) F11
l) F12

Right-side legend
a) Up Arrow
b) Left Arrow
c) Down Arrow
d) Right Arrow
</code></pre>
<p>There were some overriding design choices behind the layout; the most important ones are listed below.</p>
<ul>
<li>HJKL keys should be somewhat intuitive (H must be left of L; J must be left of K and preferably on the same row).</li>
<li>Common keys should be on the home row.</li>
<li>Most modifier keys should be used with the thumbs.</li>
<li>For better granularity, punctuation symbols should be treated uniquely as separate keys (do not treat “/” and “?” as the same physical key).</li>
<li>Use numpad arrangement for numbers.</li>
</ul>
<p>The result of all of these considerations is that my layout does not make use of all the physical keys the hardware gives us; instead, it uses keys closest to my fingers.</p>
<p>I have yet to master my own custom layout, but it’s coming along with incremental, daily improvments. I hope to reach 60 wpm in a few month’s time, after which I should be able to switch to it full-time on my primary desktop computer. I will probably make additional changes to the layout as I get more “real world” experience with it; we shall see.</p>
<p>Because of the openness of the firmware, the Nisse is extremely customizable, and I’m very happy with it. One modification I am particularly fond of is how I’ve managed to map the <code>Shift</code>, <code>FN</code>, and <code>FN2</code> keys to the blue, green, and red LEDs on the keyboard. These LEDs are traditionally used for the Scroll, Caps, and Num lock keys and in all my years of using the computer I’ve hardly ever seen either the Scroll or Caps LEDs being lit; it’s nice to see these LEDs go off when I use my modifier keys as a visual reminder of the layers involved.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I know that I’m going down a rabbit hole here. If Esrille ever goes under, it means I am on my own as far as obtaining a replacement board with the same physical dimensions. Hopefully that day will never come, but if it does, I might just grab an ErgoDox or something else that’s similar and port my layout to that system.</p>
<p>As it stands, there are still improvements to be made — but it’s all in the firmware. For example, I’d like to also make a layout for Japanese (type Japanese faster!), probably by just shifting some of the keys in the existing TRON or some other layout that the Nisse comes with to match ZQ’s distribution of letter keys vs. punctuation keys. The same goes for a Korean layout.</p>
<p>Those concerns will probably be addressed sometime later this year, or perhaps the next. It all depends on how much time I end up studying those languages again. For now, I’m just happy learning to type a little bit more comfortably on the Nisse (lots of home row goodness!).</p>
<p>Happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>Status Update</title>
    <link href="http://funloop.org/post/2016-01-04-status-update.html" />
    <id>http://funloop.org/post/2016-01-04-status-update.html</id>
    <published>2016-01-04T00:00:00Z</published>
    <updated>2016-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2016-01-04</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2016-01-04-status-update.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/life.html">life</a>
</div>

<p>Happy 2016 everyone!</p>
<p>I thought I should update this blog, even though it’s taking time away from some really fun side hobbies/projects! This post breaks with the unspoken tradition on this blog, which is that every post should be something meaningful, with original content; but, I now think that I should use this space for more personal/opinion/meta things too, not just pure technical articles.</p>
<p>Anyway, below are some updates on various things going on in my life.</p>
<h1 id="side-projects">Side projects</h1>
<p>I have a number of side projects all clamoring for my loving care. In years past, I would work on multiple projects at the same time, and start new ones even without finishing old ones. This year, I plan to just focus on one project at a time!</p>
<p>Currently, I am working on a computer keyboard layout optimizer, using the well-known <a href="https://en.wikipedia.org/wiki/Simulated_annealing">Simulated Annealing</a> algorithm. It’s a very interesting problem, and although currently my SA implementation lacks enough heuristics to make it perform any differently than random search, it is still fun to hack on. Once it is done, I will open-source it.</p>
<p>After that, I want to finish up the core features for a simple terminal-based password manager program. Making a GUI application, even console-based, is quite the challenge!</p>
<h2 id="haskell-book">Haskell book</h2>
<p>Eagle-eyed readers may have noticed that I silently pushed back timeframe for my <a href="http://funloop.org/papers.html#haskell-for-newbies-tentative-title-coming-2016">book</a> the Haskell programming language. I did this on purpose, because what with a new job and whatnot, I have not had the time as before to work on it. But, it is not dead, and I do intend to finish it — later this year!</p>
<h1 id="new-hobbies">New hobbies</h1>
<p>I picked up a new hobby — the ancient game of <a href="https://en.wikipedia.org/wiki/Go_(game)">Go</a>! I’ve been playing on my phone and even got myself some decent equipment, and I have to say that it is much more fun than chess (I say this as a former avid chess player). Maybe I’ll find a way to tie it into programming.</p>
<p>My brother gave me a rather expensive camera and I started to take some pictures with it, although I have yet to really put serious time into it. But I do know that it’s one of the first things I’m grabbing the next time I go on a trip.</p>
<h1 id="retrospect">Retrospect</h1>
<p>Perhaps this section is a bit out of place, but I think I should mention the big highlights of 2015 for myself:</p>
<ul>
<li>I got hired at a <a href="http://www.twinprime.com/">fantastic tech company</a> (doing DevOps) and basically ended the self-imposed exile of staying out of the professional tech world</li>
<li>I moved to a new place (closer to work)</li>
<li>I bought a new car (truck!)</li>
<li>I learned a lot of new things (from work)</li>
</ul>
<p>. I should note that, before my current job, I had purposefully refrained from seeking professional positions in the tech sector because I had a fear that somehow my passion for programming would be lost. Thankfully, I can say that this fear was unfounded. Almost every day, after work and dinner, I sit and code (Haskell)!</p>
<h1 id="onward">Onward</h1>
<p>I will be posting something at least once a month, I hope, to share some thoughts with you all. I thank all past, present, and future readers, for giving me the motivation to keep this blog alive!</p>
]]></summary>
</entry>
<entry>
    <title>Tig Tips</title>
    <link href="http://funloop.org/post/2015-09-12-tig-tips.html" />
    <id>http://funloop.org/post/2015-09-12-tig-tips.html</id>
    <published>2015-09-12T00:00:00Z</published>
    <updated>2015-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-09-12</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-09-12-tig-tips.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/linux.html">linux</a>, <a href="/tag/git.html">git</a>
</div>

<p>I love <a href="https://github.com/jonas/tig">tig</a>. Still, I think the defaults aren’t the best for most developers. Here are two easy customizations to make the default view better.</p>
<p>First, put</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">alias</span> tig=<span class="st">&#39;tig -n 1000&#39;</span></code></pre></div>
<p>in your <code>~/.bashrc</code> to reduce tig’s startup time (especially on large repositories). There’s rarely a need to go back more than 1000 commits from your current HEAD position in an interactive, GUI-driven manner. And if you really need to see everything, do</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ \<span class="kw">tig</span></code></pre></div>
<p>on the terminal to bypass the shell alias.</p>
<p>Second, put the following in your <code>~/.tigrc</code> file:</p>
<pre><code>set main-view = date author id:width=10 commit-title:yes,graph,refs
</code></pre>
<p>. This makes the default view show git commit hashes (where <code>width</code> is the number of hex digits to show), so that you don’t have to press ENTER on a particular commit to see its hash.</p>
<p>Happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>Why I Use NixOS</title>
    <link href="http://funloop.org/post/2015-08-01-why-i-use-nixos.html" />
    <id>http://funloop.org/post/2015-08-01-why-i-use-nixos.html</id>
    <published>2015-08-01T00:00:00Z</published>
    <updated>2015-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-08-01</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-08-01-why-i-use-nixos.org" title="History">*</a>
	<br>
	<a href="/tag/linux.html">linux</a>, <a href="/tag/arch.html">arch</a>, <a href="/tag/nix.html">nix</a>, <a href="/tag/nixos.html">nixos</a>
</div>

<p>Since March 2015, I’ve been using NixOS on my main desktop machine at home. I was on Arch Linux for 6~7 years before that. So, why did I switch?</p>
<h1 id="arch-linux">Arch Linux</h1>
<p>Let’s review the reasons I switched to Arch Linux in the first place. I switched to Arch Linux from Xubuntu because I did not want to do big distribution upgrades from one major version to the next. Arch Linux is based on a rolling release schedule — packages are updated on a daily basis. What people often say is that Arch is “bleeding edge”. While that is true, they don’t realize that at the same time, you can choose to do weekly or monthly upgrades (in an incremental fashion) rather than waiting six months or a year for a big fat distribution upgrade.</p>
<h2 id="system-age">System age</h2>
<p>The problem though, is that with age the system becomes increasingly confusing because of unused files/directories. You install packages, then delete them, but then your system still has traces of them left. I still have an old laptop with Arch on it dating from an earlier install probably about five years back (or more) — and the <code>$HOME</code> directory on there has a lot of dotfiles and other folders — some of which I have no clue about. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> It’s not very different from the same feeling I got as a teenager looking at Windows XP’s <code>regedit.exe</code> and wondering what some of the registry keys did, or if they were used at all.</p>
<h2 id="power-user-mindset">Power user mindset</h2>
<p>Another problem is that Arch expects the user to understand their entire system from the bottom up! The culture is very much “RTFM”, but not only that, you are expected to sign up to the Arch mailing lists and also read the distro homepage on a regular basis. Dare I say it — the only reason the Arch Wiki is so well-regarded is because of this culture of “you must know everything”.</p>
<p>This is fine, but ultimately I believe that it is too much responsibility. For example, every once in a while, <code>pacman</code> generates copies of existing system files whenever they would get overwritten by newer ones. One example is the <code>/etc/group</code> file. Call me lazy but I never bothered learning about the ins-and-outs of this file and what the syntax means. But every Arch Linux user out there has to do a <code>vimdiff</code> against the old/new versions of this file and perform the correct changes (basically merge them), usually with the helper CLI tool called <code>yaourt</code> with its <code>-C</code> flag.</p>
<h2 id="package-confusion">Package confusion</h2>
<p>As you use Arch Linux, you invariably end up installing one package after another. Right now, there is no way to introduce some hierarchical system of organizing packages. For example, let’s say you install the <code>firefox</code> package because you want to use, well, Firefox! In <code>pacman</code>’s point of view, there is no difference between <code>firefox</code> and <code>libfoo</code>. I.e., high-visibility, userland packages like <code>firefox</code> are treated the same in all respects as <code>libfoo</code>. You can do clever things like have meta-packages, which are defined in terms of other packages (e.g., LibreOffice), but this kind of organizational structure is hard-coded at the <code>PKGBUILD</code> level. <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>I’m sure there are <code>pacman</code> helper scripts/programs out there to give you a better, organized understanding of all of your installed packages. But do you really want to know that you have <code>libvdpau</code> installed, or that it needs to get updated? As you press <code>pacman -Syu&lt;ENTER&gt;</code>, do you really care about the exact names of the 50 low-level system packages that your userland programs (like Firefox) depend on?</p>
<h1 id="nixos">NixOS</h1>
<p>So what makes NixOS better?</p>
<h2 id="pros">Pros</h2>
<p>First off, system age has no real bearing on NixOS. Because everything is done in a functional way with the Nix package manager, your <strong>entire system</strong> becomes “recreated” each time you decide to upgrade. By default, you cannot directly write to places like <code>/usr/share</code> or <code>/usr/local</code>. Essentially, anything outside of <code>$HOME</code> can only be manipulated via the Nix package manager. And Nix does an excellent job of keeping all system directories clean and stateless!</p>
<p>Second, you don’t have to hand-tune system files like <code>/etc/group</code>. The NixOS configuration file is where you define system-wide things like users and groups, and after you set it once, it’s done for good.</p>
<p>Third, you can either hard-code what packages get installed system-wide in your config file (<code>/etc/nixos/configuration.nix</code>), or you can define your own set of packages on top of the ones defined by the official NixOS Nix expression. I used to do the former, but now I do the latter; and all I do now to see what packages I have installed explicitly is invoke <code>nix-env -q</code>, and I get this:</p>
<pre><code>fontforge-20141230
ghc-7.10.1
l-set-av
l-set-base
l-set-dev
l-set-games
l-set-misc
l-set-office
l-set-vm
l-set-web
pavucontrol-3.0
source-code-pro-2.010
</code></pre>
<p>. Those <code>l-set-</code> packages are ones where I have defined a hierarchy — i.e., I’ve coded up Arch Linux’s version of meta-packages. What’s great is that it’s all done in a programmatic way using the Nix expression language. <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> The rest are official packages I chose to install. But basically this sure beats doing something like <code>pacman -Q</code>, which grabs all installed packages on the entire system.</p>
<p>Fourth, I really like how I can do a <strong>system</strong> upgrade without touching my explicitly-installed packages in my user’s Nix environment (<code>nix-env</code>). I can update my version of <code>firefox</code> as much as I like without touching low-level packages like Xorg or the kernel, or vice-versa. It gives me the flexibility of a “rolling release” distro without the stability issues.</p>
<p>Fifth, the heart of NixOS — the Nix package manager — works by looking at a single “master” Nix expression. So if you have any custom Nix expressions, they better play well with the other ones officially provided upstream by the NixOS team! In Nix, no package is an island; in a sense, it’s a lot like how FreeBSD keeps all of their packages in a single code repository to guarantee stability.</p>
<h2 id="cons">Cons</h2>
<p>Granted, there are problems with NixOS. The biggest problem is the lack of adoption. It still has not hit critical mass, and most of the core contributors are overloaded with far too much work.</p>
<p>The second problem is that there is no way to do things like <code>make install</code> after you download the source code to some program <code>foo</code>. This is because NixOS does not have directories like <code>/usr/share</code> — the whole Linux Filesystem Hierarchy Standard is thrown out the window in favor of symlinks to the “compiled” Nix expressions. So, you have to Nxifiy it first, and then install it via its Nix expression (<code>foo.nix</code>). In this respect it shares the same pain point with <a href="http://www.gobolinux.org/">GoboLinux</a>. Personally this is not a huge problem for me, but it’s still a problem.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I hope this post gave you some motivation to try out NixOS. It has a steep learning curve but after you get most things working, it’s really great. Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Granted, <code>$HOME</code> directories are supposed to be “dirty” as they are by their nature stateful things. On the other hand, system directories like <code>/usr/share</code> and <code>/usr/bin</code> should be kept clean by the distribution’s package management system, but rarely is it automatic and maintenance-free. Arch Linux is no exception.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><code>PKGBUILD</code> files are like Makefiles, but for creating Arch Linux packages.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The Nix package manager only deals with *.nix files, which are exclusively written in the Nix expression language.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Emacs: Setting Up mmm-mode for Literate Haskell</title>
    <link href="http://funloop.org/post/2015-07-28-literate-haskell-mmm-mode.html" />
    <id>http://funloop.org/post/2015-07-28-literate-haskell-mmm-mode.html</id>
    <published>2015-07-28T00:00:00Z</published>
    <updated>2015-07-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-07-28</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-07-28-literate-haskell-mmm-mode.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/emacs.html">emacs</a>, <a href="/tag/haskell.html">haskell</a>
</div>

<p>I use <a href="https://wiki.haskell.org/Literate_programming">Literate Haskell</a> for some of my personal Haskell projects and for a long time I used the auto-loaded <code>literate-haskell-mode</code> that comes with <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>. This past weekend, I finally buckled down and made use of <a href="https://github.com/purcell/mmm-mode">mmm-mode</a> to make the literate programming experience better. The biggest advantage of using <code>mmm-mode</code> is that you can define subregions of your file which are handled by a different major mode. In other words, you can get proper syntax highlighting for 2, 3, or more different languages in the same file!</p>
<h1 id="setup">Setup</h1>
<p>You’ll need to install <a href="https://github.com/purcell/mmm-mode">mmm-mode</a> along with <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>. I personally use <a href="http://melpa.org/">MELPA</a> for all of my Emacs packages because once you set it up it’s really painless.</p>
<p>In your <a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html">emacs configuration file</a> add these lines:</p>
<pre><code>; Remove the hard-coded &#39;literate-haskell-mode&#39; activation for `.lhs&#39; files that
; haskell-mode comes with. In exchange, enable LaTeX mode whenever we open up a
; `.lhs&#39; file. Using mmm-mode, we will activate `haskell-mode&#39; in the code
; sections.
(setq auto-mode-alist
  (remove
    (rassoc &#39;literate-haskell-mode auto-mode-alist) auto-mode-alist))
(add-to-list &#39;auto-mode-alist &#39;(&quot;\\.lhs$&quot; . latex-mode))

; Literate Haskell - mmm-mode. Adopted from
; https://wiki.haskell.org/Literate_programming#Multi-mode_support_in_Emacs
(require &#39;mmm-auto)

(mmm-add-classes
  &#39;((literate-haskell-latex
    :submode haskell-mode
    :front &quot;^\\\\begin{code}\n&quot;
    :back &quot;^\\\\end{code}&quot;
  )))

; Re-fontify sub-mode portions when idle. The manual command for this is
; `mmm-parse-buffer&#39;. If you don&#39;t do this, then syntax highlighting won&#39;t work
; for new regions of Haskell code in the \begin{code}...\end{code} blocks.
(setq mmm-parse-when-idle &#39;t)
</code></pre>
<p>. Now it’s a matter of running the following commands whenever you open up a <code>.lhs</code> file:</p>
<pre><code>(setq mmm-global-mode &#39;t)
(setq mmm-submode-decoration-level 1)
(mmm-ify-by-class &#39;literate-haskell-latex)
</code></pre>
<p>. Personally I use <a href="https://github.com/listx/kakapo-mode">kakapo-mode</a> so I have a file called <code>kakapo-project-settings</code> that has this snippet in it:</p>
<pre><code>(defun my-kakapo-indents ()

  ...

  ; Literate Haskell
  ((string-match &quot;\\.lhs$&quot; b)
    (progn
      (h &#39;latex-mode-hook t 4)
      (setq mmm-global-mode &#39;t)
      (setq mmm-submode-decoration-level 1)
      (mmm-ify-by-class &#39;literate-haskell-latex)
    )
  )

  ...

)
</code></pre>
<p>. Emacs will now automatically pick up <code>.lhs</code> files and apply <code>latex-mode</code> and <code>haskell-mode</code> with <code>mmm-mode</code>. Happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>Useful rxvt-unicode (URxvt) Plugins</title>
    <link href="http://funloop.org/post/2015-06-25-urxvt-plugins.html" />
    <id>http://funloop.org/post/2015-06-25-urxvt-plugins.html</id>
    <published>2015-06-25T00:00:00Z</published>
    <updated>2015-06-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-06-25</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-06-25-urxvt-plugins.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/linux.html">linux</a>
</div>

<h1 id="introduction">Introduction</h1>
<p>I’ve been using <a href="http://software.schmorp.de/pkg/rxvt-unicode.html">rxvt-unicode</a> (<code>urxvt</code>) for years. But, I never really bothered to customize it beyond adding in some simple font changing hotkeys. I discovered that <code>urxvt</code> can be customized with Perl plugins. This post shows some of the plugins I’ve started using.</p>
<p>For this post, I will use the terms <strong>terminal</strong> and <code>urxvt</code> interchangeably. The plugins are configured in your <code>~/.Xdefaults</code> file, and to have this file take effect, run</p>
<pre><code>xrdb -merge ~/.Xdefaults
</code></pre>
<p>. The hotkeys are defined with key names from <a href="http://cgit.freedesktop.org/xorg/proto/x11proto/plain/keysymdef.h">keysymdef.h</a> as part of X11.</p>
<h1 id="keyboard-select">keyboard-select</h1>
<p><a href="https://github.com/muennich/urxvt-perls">Homepage</a> (part of <code>urxvt-perls</code>)</p>
<p>This is by far the most useful plugin. If you ever need surgical precision to select a particular chunk of text in your terminal, you can use this plugin. It gives you Vim-like <em>normal mode</em> navigation in your terminal — and then you can use hotkeys like <code>v</code> or <code>V</code> to select chunks of text, and use <code>y</code> to copy it to your X primary buffer.</p>
<p>I use the snippet below in my <code>~/.Xdefaults</code>:</p>
<pre><code>! keyboard-select
URxvt.keysym.M-s: perl:keyboard-select:activate
URxvt.keysym.M-r: perl:keyboard-select:search
</code></pre>
<p>. Now, <code>M-s</code> (<code>Alt-s</code> for you folks not familiar with Emacs-style shortcut-naming) in the terminal gives you Vim-like normal mode like I mentioned above. The other shortcut, <code>M-r</code>, gives your reverse search against your terminal’s buffer.</p>
<p>Let <code>M-r</code> sink in. This means that your terminal is basically running a virtual <code>less</code> pager. Any time you want to go search against some text in your terminal, just use <code>M-r</code> and search; use <code>n</code> and <code>N</code> just like <code>less</code>.</p>
<p>Actually, <code>M-r</code> is basically doing <code>M-s</code> followed by <code>?</code>. So, if you like searching forwards (not backwards), just do <code>M-s</code> and then <code>/</code>. But considering how terminal buffers are always <strong>above</strong> the cursor, it makes sense to search backwards by default with <code>M-r</code>. For me this runs against my habit of using <code>less</code> and <code>/</code>, but there you have it.</p>
<h1 id="clipboard">clipboard</h1>
<p><a href="https://github.com/muennich/urxvt-perls">Homepage</a> (part of <code>urxvt-perls</code>)</p>
<p><code>~/.Xdefaults</code> snippet:</p>
<pre><code>! clipboard
! update clipboard whenever primary gets updated
URxvt.clipboard.autocopy: true
URxvt.keysym.M-c: perl:clipboard:copy
URxvt.keysym.M-v: perl:clipboard:paste
URxvt.keysym.M-C-v: perl:clipboard:paste_escaped
</code></pre>
<p>. To be honest I think the <code>autocopy</code> feature is a bit flaky (at least when using these shortcuts inside a NixOS VirtualBox VM from a Mac) — but that’s not that important.</p>
<p><code>M-c</code> copies the X11 primary buffer (aka X selection) to the clipboard buffer.</p>
<p>What’s really nice is the <code>M-v</code> shortcut — it pastes the <strong>clipboard</strong> buffer, not the X11 primary buffer (there is <code>S-&lt;insert&gt;</code> (Shift-Insert) for that). Now you don’t have to type <code>$(xsel -b)</code> for the same thing.</p>
<p><code>M-C-v</code> (<code>Alt-Control-v</code>) does the same thing, but escapes any special characters. This is very handy — a simple use case might be using <code>M-s</code> (search shortcut discussed above) to find a particular file with a long name (think MP3 files) from the output of <code>ls</code> — you can then just use <code>v</code> to copy that filename to the X11 buffer, then use <code>M-c</code> to copy it to clipboard buffer (if <code>autocopy</code> is working this step is unnecessary), then use <code>M-C-v</code> to paste it in, escaping things like space characters so that you can use other tools like <code>cp</code> or <code>mv</code> on them more easily.</p>
<h1 id="url-select">url-select</h1>
<p><a href="https://github.com/muennich/urxvt-perls">Homepage</a> (part of <code>urxvt-perls</code>)</p>
<p><code>~/.Xdefaults</code> snippet:</p>
<pre><code>! url-select. We can middle-click on any url and this will launch the browser
! defined by `URxvt.url-select.launcher`.
URxvt.keysym.M-u: perl:url-select:select_next
URxvt.url-select.underline: true
URxvt.url-select.launcher: firefox
</code></pre>
<p>. Now you can use <code>M-u</code> to jump between any URL that was printed to the terminal buffer. Use <code>j</code> and <code>k</code> to jump to the next/previous URL, and <code>y</code> to copy it to your X primary buffer (and <code>M-c</code> to make sure it’s also in the clipboard) for easy URL handling. Or, simply press <code>ENTER</code> to open that link in your browser. Next time you grab your mouse to carefully highlight a URL in the terminal, think again!</p>
<h1 id="font-size">font-size</h1>
<p><a href="https://github.com/majutsushi/urxvt-font-size">Homepage</a></p>
<p>This plugin allows you to scale fonts up or down.</p>
<p><code>~/.Xdefaults</code> snippet:</p>
<pre><code>! `font-size` plugin
URxvt.keysym.C-minus: perl:font-size:decrease
URxvt.keysym.C-equal: perl:font-size:increase
! The default font increase step size is 1. This is for portability across all
! fonts (some fonts do not support particular font sizes). Because changing font
! size only really makes sense for anti-aliased fonts (Terminus is bitmapped),
! and because anti-aliased fonts support any size, it makes sense to just use a
! size step of 4 for faster transitions between font size changes.
URxvt.font-size.step: 4
</code></pre>
<p>. This is pretty self-explanatory. Use <code>C-minus</code> or <code>C-equal</code> to change your font size as needed — perfect for screencasts or demos!</p>
<h1 id="conclusion">Conclusion</h1>
<p>Now that I use these plugins, there’s even less interruption to use the mouse. I hope you find them as useful as I have.</p>
<p>Happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>SRM 485: AfraidOfEven</title>
    <link href="http://funloop.org/post/2015-05-04-puzzle-srm-485-afraid-of-even.html" />
    <id>http://funloop.org/post/2015-05-04-puzzle-srm-485-afraid-of-even.html</id>
    <published>2015-05-04T00:00:00Z</published>
    <updated>2015-05-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-05-04</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-05-04-puzzle-srm-485-afraid-of-even.org" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/math.html">math</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/ruby.html">ruby</a>
</div>

<h1 id="introduction">Introduction</h1>
<p>The heart of this problem comes from TopCoder’s <a href="http://community.topcoder.com/stat?c%3Dproblem_statement&amp;pm%3D11146&amp;rd%3D14238">SRM 485 “AfraidOfEven”</a>. There is quite a lot of discussion behind the somewhat elementary math principles, so you might want to skip down to the code directly after reading the problem statement.</p>
<h1 id="the-problem">The Problem</h1>
<p>An <a href="http://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic progression</a> <span class="math inline">\(AP\)</span> has been changed by the mutation function <span class="math inline">\(M()\)</span> in the following way: any even number <span class="math inline">\(w\)</span> in the sequence has been replaced by <span class="math inline">\(\frac{w}{2}\)</span>, repeatedly, until it has become odd. For example, if <span class="math inline">\(AP = \{2, 4, 6, 8\}\)</span>, then <span class="math inline">\(M(AP) = \{1, 1, 3, 1\}\)</span> (because <span class="math inline">\(\frac{6}{2} = 3\)</span> and <span class="math inline">\(3\)</span> is an odd number, it stopped mutating). Given a mutated sequence <span class="math inline">\(M(AP) = MP\)</span>, design an “unmutate” function <span class="math inline">\(U()\)</span> such that <span class="math inline">\(U(MP) \approx AP\)</span>. If more than one possible sequence <span class="math inline">\(AP\)</span> exists, find the one with the lowest lexicographical order.</p>
<h2 id="constraints">Constraints</h2>
<p><span class="math inline">\(MP\)</span> is limited to 4 to 50 terms. Each term in <span class="math inline">\(MP\)</span> is from <span class="math inline">\(1\)</span> to <span class="math inline">\(1000\)</span>, inclusive (for now; later on we will consider numbers less than <span class="math inline">\(1\)</span>). The difference (let’s call it <span class="math inline">\(m\)</span>) between each term can be <span class="math inline">\(0\)</span>, so the following is still a valid arithmetic progression: <span class="math inline">\(\{-17, -17, -17, -17, -17\}\)</span>.</p>
<h3 id="lexicographic-order">Lexicographic Order</h3>
<p>Given the input</p>
<p><span class="math display">\[
MP = \{1, 1, 3, 1, 5\}
\]</span></p>
<p>, we get the output</p>
<p><span class="math display">\[
U(AP) = \{1, 2, 3, 4, 5\}
\]</span></p>
<p>. It is possible that <span class="math inline">\(AP\)</span> was actually <span class="math inline">\(\{2, 4, 6, 8, 10\}\)</span> (or even <span class="math inline">\(\{4, 8, 12, 16, 20\}\)</span>), but because <span class="math inline">\(\{1, 2, 3, 4, 5\}\)</span> has the smaller lexicographic representation, it is the correct answer.</p>
<h1 id="interlude">Interlude</h1>
<p>I will include both Haskell and Ruby solutions in this post below. If you’d like to solve the problem on your own, please read the rest of this post at a later time.</p>
<h1 id="the-math">The Math</h1>
<p>Let us consider the universe of possible arithmetic progressions, and then derive a general algorithm. Because the mutation involves even numbers, it makes sense to look at arithmetic progressions in terms of even and odd numbers (aka <em>parity</em>).</p>
<p>The two most important parts of an arithmetic progression are the rate of change, <span class="math inline">\(m\)</span>, and the first term <span class="math inline">\(A_0\)</span>. This is because any arithmetic progression can be recreated by knowing only these two values.</p>
<p>Now, <span class="math inline">\(m\)</span> can be either even (<span class="math inline">\(E\)</span>), odd (<span class="math inline">\(O\)</span>), or zero. The first term <span class="math inline">\(A_0\)</span> can be either even or odd. Let’s plug these possible variations into a table, and see if there are any patterns we can exploit. To determine <span class="math inline">\(AP\)</span> based on <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, we only need to know three laws of parity:</p>
<ol>
<li><span class="math inline">\(\mathrm{O + O = E}\)</span></li>
<li><span class="math inline">\(\mathrm{E + E = E}\)</span></li>
<li><span class="math inline">\(\mathrm{O + E = O}\)</span></li>
</ol>
<p>. Using these laws, we can construct the entire sequence <span class="math inline">\(AP\)</span> by adding <span class="math inline">\(m\)</span> into <span class="math inline">\(A_0\)</span> repeatedly.</p>
<p>The only time that adding two numbers together results in an odd number is when one term is odd and the other term is even. This rule is true regardless of whether we are adding or subtracting (adding a negative term), or whether either term is positive or negative. Another interesting point is that adding by an even number does not change the parity of the original term, while adding by an odd number always flips the parity of the original. We now know how to construct <span class="math inline">\(AP\)</span> from <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, so let’s examine the possible outcomes below:</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center"><span class="math inline">\(m\)</span></th>
<th align="center"><span class="math inline">\(A_0\)</span></th>
<th align="center"><span class="math inline">\(AP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">5</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">6</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. Let’s now look at each of the 6 possible cases, and see if we can simplify things more. We will look at each case from the perspective of <span class="math inline">\(m\)</span>.</p>
<h2 id="mutation-when-m-is-zero">Mutation When <span class="math inline">\(m\)</span> is Zero</h2>
<p>If <span class="math inline">\(m\)</span> is zero, then <span class="math display">\[AP = {A_0, A_0, A_0\cdots{}A_0}\]</span>. That is, subsequent terms after <span class="math inline">\(A_0\)</span> do not change, so it is a constant sequence of the first term, <span class="math inline">\(A_0\)</span>.</p>
<p>If <span class="math inline">\(m\)</span> is zero and <span class="math inline">\(A_0\)</span> is <strong>odd</strong>, then all terms remain the same after the mutation; so, <span class="math inline">\(M(AP) = AP\)</span> (no change). E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{3, 3, 3, 3, \cdots{}, 3}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{3, 3, 3, 3, \cdots{}, 3}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. If <span class="math inline">\(m\)</span> is zero and <span class="math inline">\(A_0\)</span> is <strong>even</strong>, then all terms are likewise even, and all terms will become odd by application of <span class="math inline">\(M()\)</span>. What’s more, every term in <span class="math inline">\(M_0\)</span> will be the same odd number, essentially becoming “reduced” to the case where <span class="math inline">\(A_0\)</span> was originally odd. E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{10, 10, 10, 10, \cdots{}, 10}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{5, 5, 5, 5, \cdots{}, 5}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h2 id="mutation-when-m-is-even">Mutation When <span class="math inline">\(m\)</span> is Even</h2>
<p>If <span class="math inline">\(m\)</span> is even, then all terms in <span class="math inline">\(AP\)</span> are either even or odd, based on the first term <span class="math inline">\(A_0\)</span>. Essentially, <span class="math inline">\(AP\)</span> behaves in an identical manner to the case where <span class="math inline">\(m = 0\)</span> as far as parity is concerned — the only difference here is that the subsequent terms change in value by <span class="math inline">\(m\)</span>.</p>
<p>However, there is a slight twist when we apply mutation. If <span class="math inline">\(A_0 = \mathrm{O}\)</span>, then there are no numbers to mutate, and we get <span class="math inline">\(MP\)</span> where all terms are odd and they change by <span class="math inline">\(m\)</span>. But if <span class="math inline">\(A_0 = \mathrm{E}\)</span>, then we get <em>changing</em> even numbers for <span class="math inline">\(MP\)</span>. So unlike in the case of <span class="math inline">\(m = 0\)</span> where all even numbers reduced down to the same odd number after applying the mutation, we get <em>different</em> odd numbers. E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{40, 48, 56, 64, 72}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{5, 3, 7, 1, 9}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. Notice how even though <span class="math inline">\(AP\)</span> has a sequence of <em>increasing</em> terms, <span class="math inline">\(MP\)</span>’s terms are not increasing in the same manner. We will revisit this case below when simplifying the categories of behavior for <span class="math inline">\(MP\)</span>.</p>
<h2 id="mutation-when-m-is-odd">Mutation When <span class="math inline">\(m\)</span> is Odd</h2>
<p>This is where things get interesting. If <span class="math inline">\(m\)</span> is odd, then <span class="math inline">\(AP\)</span> becomes a <em>series of alternating even and odd numbers</em>. Whether <span class="math inline">\(AP\)</span> begins with an even or odd number depends, naturally, on the parity of <span class="math inline">\(A_0\)</span>. The more general observation we can make is that, given the fact that we have alternating even and odd numbers in <span class="math inline">\(AP\)</span>, <span class="math inline">\(MP\)</span> will be populated with “originally odd” and “fake odd” (mutated) terms. Let’s call these mutated terms <span class="math inline">\(O_F\)</span>. So if <span class="math inline">\(m\)</span> is odd, then we get either</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{O, E, O, E}\}, MP = \{\mathrm{O, O_F, O, O_F}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">or</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{E, O, E, O}\}, MP = \{\mathrm{O_F, O, O_F, O}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h1 id="a-summary-of-the-behavior-of-the-mutation-function-m">A Summary of the Behavior of the Mutation Function <span class="math inline">\(M()\)</span></h1>
<p>We’ve exhausted the universe of all possible arithmetic sequences, and how they would mutate after applying <span class="math inline">\(M()\)</span>. We know exactly how <span class="math inline">\(M()\)</span> behaves in all edge cases! Let us now simplify the various cases to two general cases.</p>
<h2 id="there-is-nothing-to-unmutate-as-mp-is-already-the-same-as-the-answer-ap">There is nothing to “unmutate” as <span class="math inline">\(MP\)</span> is already the same as the answer <span class="math inline">\(AP\)</span></h2>
<p>This can happen in two ways. The easiest way is if <span class="math inline">\(m = 0\)</span>, where all terms in <span class="math inline">\(MP\)</span> are the same and there is nothing to calculate (<span class="math inline">\(M()\)</span> will ensure that this case always results in the same repeating odd number). The other way is if <span class="math inline">\(m\)</span> is even, and <span class="math inline">\(A_0\)</span> is odd — resulting in an “unmutatable” sequence such that <span class="math inline">\(M(AP) = AP\)</span>. E.g. (where <span class="math inline">\(m = 10\)</span> and <span class="math inline">\(A_0 = 11\)</span>),</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(AP = \{\mathrm{11, 21, 31, 41, 51}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(MP = \{\mathrm{11, 21, 31, 41, 51}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h2 id="the-terms-in-ap-alternate-between-even-and-odd">The terms in <span class="math inline">\(AP\)</span> alternate between even and odd</h2>
<p>This covers the case when <span class="math inline">\(m\)</span> is odd. If <span class="math inline">\(m\)</span> is odd, then regardless of the parity of <span class="math inline">\(A_0\)</span>, we get an alternating sequence of even and odd numbers. The import thing to keep in mind here is that the even numbers will mutate after <span class="math inline">\(\mathrm{M()}\)</span> is applied, while the odd numbers will stay as-is as “originals”.</p>
<h1 id="how-to-design-u">How to Design <span class="math inline">\(U()\)</span></h1>
<p>Let’s think back to what our mutation function <span class="math inline">\(M()\)</span> does: it simply mutates an even number to an odd number by repeatedly dividing it by 2. If the number if odd to begin with, then there is nothing to mutate; essentially, <em>original</em> odd numbers act as immutable beacons of truth — they do not have to change form when returning to their <span class="math inline">\(AP\)</span> form! Our task in designing an “unmutate” function <span class="math inline">\(U()\)</span> is to preserve the “honest” odd numbers while converting the mutated, “fake” odd numbers back to their evenness, to get back the original progression <span class="math inline">\(AP\)</span> (or at least something close to it if there are multiple such <span class="math inline">\(AP\)</span>s out there.</p>
<p>You can now see where our extensive parity breakdown of the possible <span class="math inline">\(MP\)</span> can come in handy — we know in what patterns the honest odd numbers show themselves in <em>any</em> <span class="math inline">\(MP\)</span>. Let’s rewrite the table of all possibilities, with this analogy of “honest” and “fake” (<span class="math inline">\(O_F\)</span>) odd numbers after the mutation.</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center"><span class="math inline">\(m\)</span></th>
<th align="center"><span class="math inline">\(A_0\)</span></th>
<th align="center"><span class="math inline">\(AP\)</span></th>
<th align="center"><span class="math inline">\(MP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center"><span class="math inline">\(0\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(?\)</span></td>
</tr>
<tr class="odd">
<td align="center">5</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">6</td>
<td align="center"><span class="math inline">\(\mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>As you can see, the two dominating patterns are either the all-odd (and honest!) numbers (first 3 rows) or the alternating honest or fake odd numbers. But what about the case where <span class="math inline">\(m\)</span> is a nonzero even value and <span class="math inline">\(A_0\)</span> is even as well (row 4)? In the universe of all possible even numbers of <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, how can we know for a fact that the mutation to <span class="math inline">\(MP\)</span> will fall into a neat pattern?</p>
<h1 id="when-both-m-and-a_0-are-even">When both <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span> are even</h1>
<p>The short answer is, we can prove that all such sequences will mutate to the familiar <span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span>, <span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span>, or <span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span> pattern shown in the table above. The long answer is that it helps to think of linear equations, and to see the possible ways in which we can <em>grow</em> the <span class="math inline">\(AP\)</span> progression from <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>.</p>
<p>If you paid attention in high school algebra class, you will probably remember the formula <span class="math inline">\(y = mx + b\)</span> to describe a straight line (except the vertical line!) in the cartesian coordinate system (in the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> axes). We can use the <strong>same</strong> equation to describe the growth behavior of an arithmetic sequence! And for that, we use the following translation:</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(y = mx + b\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = mn + A_0\)</span></td>
</tr>
</tbody>
</table>
<p>, where <span class="math inline">\(A_n\)</span> is the n-th term to be calculated in <span class="math inline">\(AP\)</span>. Luckily, we’ve used the same letter <span class="math inline">\(m\)</span> in both contexts — it describes the rate of change in one, and the distance between each term in the other. Let’s simplify the equation with a concern to parity only.</p>
<p>First, let’s rewrite the equation as follows:</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E\cdot{}}n + \mathrm{E}\)</span></td>
</tr>
<tr class="even">
<td align="center">or</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E_m}\cdot{}n + \mathrm{E_{A0}}\)</span></td>
</tr>
</tbody>
</table>
<p>. The <span class="math inline">\(\mathrm{E}\)</span> here represents that this number is an even number, with the subscript denoting whether it is <span class="math inline">\(m\)</span> (<span class="math inline">\(\mathrm{E_m}\)</span>) or the first term in the sequence (<span class="math inline">\(\mathrm{E_{A0}}\)</span>). If we use this equation to map out the first 4 elements of <span class="math inline">\(AP\)</span>, we get the following:</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_0 = \mathrm{E_m\cdot{}0 + E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">\(A_1 = \mathrm{E_m\cdot{}1 + E_{A0}}\)</span></td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_2 = \mathrm{E_m\cdot{}2 + E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">\(A_3 = \mathrm{E_m\cdot{}3 + E_{A0}}\)</span></td>
</tr>
</tbody>
</table>
<p>. It should be noted that both <span class="math inline">\(\mathrm{E_m}\)</span> and <span class="math inline">\(\mathrm{E_{A0}}\)</span> remain the <strong>same</strong> throughout the entire sequence <span class="math inline">\(AP\)</span>. The only thing that changes is <span class="math inline">\(n\)</span>, which always increments by <span class="math inline">\(1\)</span>, starting from <span class="math inline">\(0\)</span>.</p>
<p>And now we’re faced with a problem. Ideally, we’d like to get rid of all those even terms in our formula — they don’t help us out at all! This is where we use the concept of <em>scaling</em>. There are two scaling rules: (1) if you multiply all terms of an arithmetic progression by some nonzero integer <span class="math inline">\(k\)</span>, <em>the new progression remains arithmetic</em>; (2) the same is true if you divide all terms by <span class="math inline">\(k\)</span>.</p>
<p>The first scaling rule works because</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n\cdot{}k = (\mathrm{E_m\cdot{}}n + \mathrm{E_{A0}})\cdot{}k\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n\cdot{}k = (\mathrm{E_m}\cdot{}{k})\cdot{}n + \mathrm{E_{A0}}\cdot{}k\)</span></td>
</tr>
</tbody>
</table>
<p>, where the terms <span class="math inline">\(\mathrm{E_{A0}}\cdot{}k\)</span> and <span class="math inline">\(\mathrm{E_m}\cdot{}k\)</span> both remain as constants — we are still dealing with a <a href="http://en.wikipedia.org/wiki/Degree_of_a_polynomial">degree 1 polynomial</a> (linear expression). Apart from increasing the first term <span class="math inline">\(\mathrm{A_0}\)</span> by <span class="math inline">\(k\)</span>, all we did was increase the gap between each term by a factor of <span class="math inline">\(k\)</span>. Likewise, if you <em>divide</em> all terms of an arithmetic progression by some nonzero integer <span class="math inline">\(k\)</span>, the new progression still remains arithmetic, because what you are doing is</p>
<table>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(A_n = \mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(\frac{A_n}{k} = \frac{\mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}}{k}\)</span></td>
</tr>
<tr class="even">
<td align="center">becomes</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(\frac{A_n}{k} = \frac{\mathrm{E_m}}{k}\cdot{}n + \frac{\mathrm{E_{A0}}}{k}\)</span></td>
</tr>
</tbody>
</table>
<p>. Division is simply multiplication by the inverse, so the same reasoning as for the first scaling rule applies here as well. By the way, we don’t have to worry about what <span class="math inline">\(A_n\cdot{}k\)</span> or <span class="math inline">\(\frac{A_n}{k}\)</span> would look like — we are merely concerned with how <em>parity</em> behaves, and for that we rely on the right hand side of the equation.</p>
<p>Going back to our problem, recall that we want to ultimately output some arithmetic progression that <em>could</em> have resulted in the given mutated list <span class="math inline">\(MP\)</span>. This is what scaling gives us — it gives us the leeway that we need to stay within our original problem domain while changing around the parity of <span class="math inline">\(A_n\)</span> with <span class="math inline">\(k\)</span>.</p>
<p>Let us scale the entire progression by <span class="math inline">\(k = \frac{1}{2}\)</span>. That is, let us repeatedly divide <span class="math inline">\(\mathrm{E_m}\)</span> and <span class="math inline">\(\mathrm{E_{A0}}\)</span> by 2, until one or both of them become odd. When either one becomes odd, we stop scaling and reuse the parity laws we discussed above to draw deeper conclusions. Which variable, <span class="math inline">\(\mathrm{E_m}\)</span> or <span class="math inline">\(\mathrm{E_{A0}}\)</span>, has more 2’s in it (as prime factors)? Which term is more <em>even</em> than the other?</p>
<p>There are three possible scenarios when we scale (let’s call it <span class="math inline">\(\mathrm{S()}\)</span>) by <span class="math inline">\(\frac{1}{2}\)</span> <strong>repeatedly</strong> as described above: (1) <span class="math inline">\(\mathrm{E_{A0}}\)</span> becomes odd first, (2) <span class="math inline">\(\mathrm{E_m}\)</span> becomes odd first, or (3) both become equally odd. If we write these three scenarios into a table, we get the following:</p>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center">Scaled by <span class="math inline">\(\frac{1}{2}\)</span> repeatedly</th>
<th align="center">Parity of Scaled <span class="math inline">\(AP\)</span></th>
<th align="center">Parity of Scaled <span class="math inline">\(MP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{E\cdot{}}n + \mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{O\cdot{}}n + \mathrm{E}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{O\cdot{}}n + \mathrm{O}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
<td align="center"><span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>. The parity of each scaled <span class="math inline">\(AP\)</span> is calculated by simply replacing <span class="math inline">\(n\)</span> with 0, 1, 2, etc. and relying on our three parity laws from the beginning of this post. If you want to lessen your load of mental arithmetic, we can simplify the parity expressions further. If we reword the additive parity laws with multiplication in mind (which is simply addition repeated many times over), we can derive two more parity laws:</p>
<ol>
<li><span class="math inline">\(\mathrm{E\cdot{}}n = \mathrm{E}\)</span>, regardless of <span class="math inline">\(n\)</span>, and</li>
<li><span class="math inline">\(\mathrm{O\cdot{}}n = \mathrm{P}_n\)</span> — i.e., the parity of <span class="math inline">\(\mathrm{O\cdot{}}n\)</span> is the same as the parity of <span class="math inline">\(n\)</span> itself</li>
</ol>
<p>. Going back to our table above, we can simplify the scaled expressions further:</p>
<ol>
<li><span class="math inline">\(\mathrm{E + O} = \mathrm{O}\)</span>, because adding by an even number preserves the parity of <span class="math inline">\(\mathrm{O}\)</span>.</li>
<li><span class="math inline">\(\mathrm{P}_n + \mathrm{E} = \mathrm{P}_n\)</span>, because adding by an even number preserves the parity of <span class="math inline">\(\mathrm{P}_n\)</span>.</li>
<li><span class="math inline">\(\mathrm{P}_n + \mathrm{O} = \neg{}\mathrm{P}_n\)</span>, because adding by an odd number flips the parity of <span class="math inline">\(\mathrm{P}_n\)</span></li>
</ol>
<p>.</p>
<p>And now we can finally say that when both <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span> are even, the parity of terms in in <span class="math inline">\(AP\)</span> can be either all odd or alternating between even and odd! I.e., if both <span class="math inline">\(m = \mathrm{E}\)</span> and <span class="math inline">\(A_0 = \mathrm{E}\)</span>, then <span class="math inline">\(M(AP) = \{\mathrm{O, O, O, O, \cdots{}}\}\)</span>, <span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span>, or <span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span>!</p>
<h1 id="back-to-designing-u">Back to Designing <span class="math inline">\(U()\)</span></h1>
<p>Through our discussion up to this point, we’ve established that the universe of all possible <span class="math inline">\(MP\)</span>’s fall under three parity patterns: all honest odd (<span class="math inline">\(\mathrm{O}\)</span>) terms, or alternating between “honest” odd (<span class="math inline">\(\mathrm{O}\)</span>) and “fake” odd (<span class="math inline">\(\mathrm{O_F}\)</span>) terms. There are actually four patterns because the all-honest-odd-terms pattern can be broken down into two cases: (1) all terms are the same odd number (<span class="math inline">\(m = 0\)</span>), or (2) the terms are the same as those in <span class="math inline">\(AP\)</span> (i.e., <span class="math inline">\(AP\)</span> was all odd terms to begin with, so there was no actual mutation involved by applying <span class="math inline">\(M()\)</span>).</p>
<p>So, we can finally start sketching out the design for our “unmutate” function <span class="math inline">\(U()\)</span>.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/pseudocode.txt"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="sourceCode"><pre><code class="sourceCode"># Convert MP into a possible AP.
def unmutate(MP)
	if length(MP) &lt; 4
		return NULL (we need at least 4 values to calculate an AP)
	elsif every term in MP are the same
		return MP (no change)
	elsif MP is already an arithmetic sequence (MP = AP)
		return MP (no change)
	else
		1) Assume every 0th, 2nd, 4th, etc. term is &quot;honest&quot; and that the rest are
		&quot;fake&quot;; construct a tentative AP (call it BP) with the honest terms by
		taking the difference between these honest terms to find the rate of change
		*m*, and see if mutate(BP) = MP --- if so, then return BP.

		2) Otherwise, every 1st, 3rd, 5th, etc. term is &quot;honest&quot; --- so
		reconstruct BP, and check if mutate(AP) = MP (i.e., check that the
		dishonest terms from mutate(BP) are the same as those in the given MP).
		If the check fails, then we know that the input was not a true MP ---
		the original AP was not an arithmetic progression to begin with!
	end
end

# Convert AP into MP
def mutate(AP)
	MP = []
	for every term &#39;a&#39; in AP:
		MP.insert(make_odd(a))
	end
end

# Divide an integer n by 2 until it becomes odd. The edge case is when n is 0,
# because dividing by 2 repeatedly does not change its parity.
def make_odd(n)
	if n is odd or n is 0
		return n
	else
		return (make_odd(n/2))
	end
end</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/pseudocode.txt"  mimetype=text/plain > pseudocode.txt </a>
</div>
</div>
<p>The interesting point is in line 18; thanks to our math work, we can even declare that a given mutated sequence was somehow either tampered with, or that the original sequence was not an arithmetic progression! We can make these assertions because we’ve exhausted all possible cases of arithmetic sequences and their mutations — and if things don’t fit the way we expect them to, then the only conclusion is that the given sequence <span class="math inline">\(MP\)</span> was not a byproduct of mutating an <em>arithmetic sequence</em>, but some other kind of sequence. Behold the power of math!</p>
<p>The other thing is that in line 34 we allow <span class="math inline">\(0\)</span> as a possible value in <span class="math inline">\(AP\)</span>. This means that after a mutation, we might still have an even number (<span class="math inline">\(0\)</span>) in <span class="math inline">\(MP\)</span>! Although this sounds like it would break all of the mathematic discussion we’ve had so far, it does not — the proof is in the Haskell code below. The short answer is that a <span class="math inline">\(0\)</span> is harmless because it shares the same quality — immutability — with all other originally odd terms in <span class="math inline">\(AP\)</span>; thus, treating it as an “odd” number does not change our logic.</p>
<h1 id="haskell-version">Haskell version</h1>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/Unmutate.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Unmutate</span> <span class="kw">where</span>

<span class="co">-- Convert mutated numbers back into an arithmetic progression (if possible).</span>
<span class="ot">unmutate ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]
unmutate ts
	<span class="co">-- The input must be at least 4 terms!</span>
	<span class="fu">|</span> length ts <span class="fu">&lt;</span> <span class="dv">4</span> <span class="fu">=</span> <span class="dt">Nothing</span>
	<span class="fu">|</span> all (<span class="fu">==</span>t) ts <span class="fu">=</span> <span class="dt">Just</span> ts
	<span class="fu">|</span> isArithmetic ts <span class="fu">=</span> <span class="dt">Just</span> ts
	<span class="fu">|</span> mutate bp1 <span class="fu">==</span> ts <span class="fu">=</span> <span class="dt">Just</span> bp1
	<span class="fu">|</span> mutate bp2 <span class="fu">==</span> ts <span class="fu">=</span> <span class="dt">Just</span> bp2
	<span class="co">-- Could optionally raise an error saying ts was not derived from an</span>
	<span class="co">-- arithmetic progression in the first place!</span>
	<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>
	<span class="kw">where</span>
	t <span class="fu">=</span> head ts
	<span class="co">-- O_F, O, O_F, O...</span>
	bp1Terms <span class="fu">=</span> everyNth0 <span class="dv">2</span> ts
	bp1 <span class="fu">=</span> makeBP (length ts) <span class="dt">False</span> bp1Terms
	<span class="co">-- O, O_F, O, O_F...</span>
	bp2Terms <span class="fu">=</span> everyNth <span class="dv">2</span> ts
	bp2 <span class="fu">=</span> makeBP (length ts) <span class="dt">True</span> bp2Terms

<span class="co">-- Create a tentative arithmetic progression &quot;BP&quot; from the given arguments. The</span>
<span class="co">-- `makeFirstTerm` boolean determines whether we are dealing with a &quot;O_F, O,</span>
<span class="co">-- O_F, O...&quot; or a &quot;O, O_F, O, O_F&quot; pattern.</span>
<span class="ot">makeBP ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
makeBP len makeFirstTerm originals
	<span class="fu">|</span> length originals <span class="fu">&lt;</span> <span class="dv">2</span> <span class="fu">=</span> []
	<span class="fu">|</span> makeFirstTerm <span class="fu">=</span> (o0 <span class="fu">-</span> m) <span class="fu">:</span> init bp
	<span class="fu">|</span> otherwise <span class="fu">=</span> bp
	<span class="kw">where</span>
	o0 <span class="fu">=</span> originals<span class="fu">!!</span><span class="dv">0</span>
	o1 <span class="fu">=</span> originals<span class="fu">!!</span><span class="dv">1</span>
	m <span class="fu">=</span> div (o1 <span class="fu">-</span> o0) <span class="dv">2</span>
	bp <span class="fu">=</span> reverse
		<span class="fu">.</span> foldl (\acc n <span class="ot">-&gt;</span> (m<span class="fu">*</span>n <span class="fu">+</span> o0)<span class="fu">:</span>acc) []
		<span class="fu">$</span> take len [<span class="dv">0</span><span class="fu">..</span>]

<span class="ot">isArithmetic ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isArithmetic ts
	<span class="co">-- A progression (before we even get to whether it is arithmetic) must have</span>
	<span class="co">-- at least 2 terms in it.</span>
	<span class="fu">|</span> length ts <span class="fu">&lt;</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">False</span>
	<span class="fu">|</span> otherwise <span class="fu">=</span> all (<span class="fu">==</span>m) <span class="fu">$</span> zipWith (<span class="fu">-</span>) (tail ts) (init ts)
	<span class="kw">where</span>
	t0 <span class="fu">=</span> ts<span class="fu">!!</span><span class="dv">0</span>
	t1 <span class="fu">=</span> ts<span class="fu">!!</span><span class="dv">1</span>
	m <span class="fu">=</span> t1 <span class="fu">-</span> t0

<span class="ot">mutate ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
mutate <span class="fu">=</span> map makeOdd
	<span class="kw">where</span>
<span class="ot">	makeOdd ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
	makeOdd n
		<span class="co">-- 0 cannot be turned into an odd number! Keep it as is.</span>
		<span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
		<span class="fu">|</span> odd n <span class="fu">=</span> n
		<span class="fu">|</span> otherwise <span class="fu">=</span> makeOdd <span class="fu">$</span> div n <span class="dv">2</span>

<span class="co">-- Given a list of &#39;a&#39;s, return the elements at indices [0n, 1n, 2n, 3n, ...].</span>
<span class="co">-- E.g., given a list [0..] and n = 2, we get [0, 2, 4, 6..]. From</span>
<span class="co">-- http://stackoverflow.com/a/2028758/437583.</span>
<span class="ot">everyNth0 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
everyNth0 _ [] <span class="fu">=</span> []
everyNth0 n as <span class="fu">=</span> head as <span class="fu">:</span> everyNth0 n (drop n as)

<span class="co">-- Same as `everyNth0`, but start at the nth element. E.g., given a list [0..]</span>
<span class="co">-- and n = 2, we get [1, 3, 5, 7..].</span>
<span class="ot">everyNth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
everyNth n <span class="fu">=</span> everyNth0 n <span class="fu">.</span> drop (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/Unmutate.hs"  mimetype=text/plain > Unmutate.hs </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/test-unmutate.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span>

<span class="kw">import </span><span class="dt">Unmutate</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain tests

<span class="ot">tests ::</span> <span class="dt">TestTree</span>
tests <span class="fu">=</span> testGroup <span class="st">&quot;Tests&quot;</span> [qcProps, unitTests]

<span class="kw">data</span> <span class="dt">AP</span> <span class="fu">=</span> <span class="dt">AP</span> [<span class="dt">Integer</span>]
	<span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- Generate a random arithmetic progression.</span>
<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">AP</span> <span class="kw">where</span>
	arbitrary <span class="fu">=</span> <span class="kw">do</span>
		<span class="co">-- Choose random m (change between terms).</span>
		m <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Int</span>
		<span class="co">-- Choose random first term. It&#39;s important that we make it into an</span>
		<span class="co">-- Integer type, because if we use Int we might end up with integer</span>
		<span class="co">-- overflow if m is too large.</span>
		t <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Integer</span>
		<span class="co">-- Choose random length of 4 to 50.</span>
		len <span class="ot">&lt;-</span> choose (<span class="dv">4</span>, <span class="dv">50</span>)
		return
			<span class="fu">.</span> <span class="dt">AP</span>
			<span class="fu">.</span> foldl (\acc n <span class="ot">-&gt;</span> ((fromIntegral m)<span class="fu">*</span>n <span class="fu">+</span> t)<span class="fu">:</span>acc) []
			<span class="fu">$</span> take len [<span class="dv">0</span><span class="fu">..</span>]

<span class="ot">qcProps ::</span> <span class="dt">TestTree</span>
qcProps <span class="fu">=</span> testGroup <span class="st">&quot;(checked by QuickCheck)&quot;</span>
	[ QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in calculable (isJust))&quot;</span>
		(\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> isJust <span class="fu">.</span> unmutate <span class="fu">$</span> mutate ts)
	, QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in a nonempty list)&quot;</span>
		(\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> not
			<span class="fu">.</span> null
			<span class="fu">.</span> fromJust
			<span class="fu">.</span> unmutate
			<span class="fu">$</span> mutate ts)
	, QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in an arithmetic progression)&quot;</span>
		(\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> isArithmetic
			<span class="fu">.</span> fromJust
			<span class="fu">.</span> unmutate
			<span class="fu">$</span> mutate ts)
	]

<span class="ot">unitTests ::</span> <span class="dt">TestTree</span>
unitTests <span class="fu">=</span> testGroup <span class="st">&quot;Unit tests&quot;</span>
	[ testCase <span class="st">&quot;Unmutate (empty list is not calculable)&quot;</span>
		<span class="fu">$</span> unmutate ([]<span class="ot">::</span>[<span class="dt">Int</span>])
		<span class="fu">@?=</span> <span class="dt">Nothing</span>
	, testCase <span class="st">&quot;Unmutate (AP is all odd, so AP == MP)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (m = 0, so all elements in mp are the same)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 1)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 2)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">7</span>, <span class="dv">47</span>, <span class="dv">5</span>, <span class="dv">113</span>, <span class="dv">73</span>, <span class="dv">179</span>, <span class="dv">53</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">14</span>, <span class="dv">47</span>, <span class="dv">80</span>, <span class="dv">113</span>, <span class="dv">146</span>, <span class="dv">179</span>, <span class="dv">212</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 3)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="dv">749</span>, <span class="dv">999</span>, <span class="dv">125</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="dv">1498</span>, <span class="dv">999</span>, <span class="dv">500</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	, testCase <span class="st">&quot;Unmutate (known case 4)&quot;</span>
		<span class="fu">$</span> unmutate [<span class="fu">-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">33</span>, <span class="dv">11</span><span class="ot"> ::</span> <span class="dt">Int</span>]
		<span class="fu">@?=</span> <span class="dt">Just</span> [<span class="fu">-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>, <span class="dv">44</span><span class="ot"> ::</span> <span class="dt">Int</span>]
	]</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/test-unmutate.hs"  mimetype=text/plain > test-unmutate.hs </a>
</div>
</div>
<p>As you can see, most of the real work involves identifying the <strong>original, immutable numbers</strong> we can work with as-is (<span class="math inline">\(\mathrm{O}\)</span>) (as opposed to the ones we have to ignore (<span class="math inline">\(\mathrm{O_F}\)</span>)) to construct our tentative sister arithmetic progression <span class="math inline">\(BP\)</span>.</p>
<h1 id="ruby-version">Ruby version</h1>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/unmutate.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Unmutate</span>
  <span class="kw">def</span> <span class="dt">Unmutate</span>.unmutate(ts)
    <span class="kw">if</span> ts.size &lt; <span class="dv">4</span>
      <span class="kw">return</span> <span class="dv">nil</span>
    <span class="kw">end</span>

    bp1_terms = every_nth0(<span class="dv">2</span>, ts)
    bp1 = make_BP(ts.size, <span class="dv">false</span>, bp1_terms)
    bp2_terms = every_nth(<span class="dv">2</span>, ts)
    bp2 = make_BP(ts.size, <span class="dv">true</span>, bp2_terms)

    <span class="kw">if</span> ts.uniq.size == <span class="dv">1</span>
      ts
    <span class="kw">elsif</span> <span class="dt">Unmutate</span>.arithmetic?(ts)
      ts
    <span class="kw">elsif</span> <span class="dt">Unmutate</span>.mutate(bp1) == ts
      bp1
    <span class="kw">elsif</span> <span class="dt">Unmutate</span>.mutate(bp2) == ts
      bp2
    <span class="kw">else</span>
      <span class="dv">nil</span>
    <span class="kw">end</span>
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">Unmutate</span>.make_BP(len, make_first_term, originals)
    <span class="kw">if</span> originals.size &lt; <span class="dv">2</span>
      <span class="kw">return</span> []
    <span class="kw">end</span>

    o0 = originals[<span class="dv">0</span>]
    o1 = originals[<span class="dv">1</span>]
    m = (o1 - o0) / <span class="dv">2</span>
    bp = []

    <span class="kw">for</span> n <span class="kw">in</span> (<span class="dv">0</span>..(len - <span class="dv">1</span>)) <span class="kw">do</span>
      bp &lt;&lt; m*n + o0
    <span class="kw">end</span>

    <span class="kw">if</span> make_first_term
      [o0 - m] + bp.take(len - <span class="dv">1</span>)
    <span class="kw">else</span>
      bp
    <span class="kw">end</span>
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">Unmutate</span>.mutate(ts)
    ts.map{|t| make_odd t}
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">Unmutate</span>.arithmetic?(ts)
    <span class="kw">if</span> ts.size &lt; <span class="dv">2</span>
      <span class="kw">return</span> <span class="dv">false</span>
    <span class="kw">end</span>

    m = ts[<span class="dv">1</span>] - ts[<span class="dv">0</span>]
    ms = ts.drop(<span class="dv">1</span>).zip(ts.take(ts.size - <span class="dv">1</span>))

    ms.each <span class="kw">do</span> |t1, t0|
      <span class="kw">if</span> (t1 - t0) != m
        <span class="kw">return</span> <span class="dv">false</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    <span class="dv">true</span>
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> make_odd(t)
  <span class="kw">if</span> t.odd? || t == <span class="dv">0</span>
    t
  <span class="kw">else</span>
    make_odd(t/<span class="dv">2</span>)
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> every_nth0(n, ts)
  arr = []
  <span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">0</span>..(ts.size - <span class="dv">1</span>)) <span class="kw">do</span>
    <span class="kw">if</span> i % n == <span class="dv">0</span>
      arr &lt;&lt; ts[i]
    <span class="kw">end</span>
  <span class="kw">end</span>
  arr
<span class="kw">end</span>

<span class="kw">def</span> every_nth(n, ts)
  arr = []
  <span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">0</span>..(ts.size - <span class="dv">1</span>)) <span class="kw">do</span>
    <span class="kw">if</span> (i + <span class="dv">1</span>) % n == <span class="dv">0</span>
      arr &lt;&lt; ts[i]
    <span class="kw">end</span>
  <span class="kw">end</span>
  arr
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/unmutate.rb"  mimetype=text/plain > unmutate.rb </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/srm485-afraid-of-even/test-unmutate.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="co"># Usage: ruby test-unmutate.rb</span>

require <span class="st">&#39;minitest/autorun&#39;</span>
require_relative <span class="st">&#39;./unmutate.rb&#39;</span>

<span class="kw">class</span> <span class="dt">TestUnmutate</span> &lt; <span class="dt">Minitest</span>::<span class="dt">Test</span>
  <span class="kw">def</span> test_empty_list_incalculable
    assert_equal <span class="dv">nil</span>, <span class="dt">Unmutate</span>.unmutate([])
  <span class="kw">end</span>

  <span class="kw">def</span> test_all_odd_no_change
    assert_equal [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_m_is_0
    assert_equal [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_1
    assert_equal [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">5</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_2
    assert_equal [<span class="dv">14</span>, <span class="dv">47</span>, <span class="dv">80</span>, <span class="dv">113</span>, <span class="dv">146</span>, <span class="dv">179</span>, <span class="dv">212</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">7</span>, <span class="dv">47</span>, <span class="dv">5</span>, <span class="dv">113</span>, <span class="dv">73</span>, <span class="dv">179</span>, <span class="dv">53</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_3
    assert_equal [<span class="dv">1498</span>, <span class="dv">999</span>, <span class="dv">500</span>, <span class="dv">1</span>],
      <span class="dt">Unmutate</span>.unmutate([<span class="dv">749</span>, <span class="dv">999</span>, <span class="dv">125</span>, <span class="dv">1</span>])
  <span class="kw">end</span>

  <span class="kw">def</span> test_known_case_4
    assert_equal [-<span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>, <span class="dv">44</span>],
      <span class="dt">Unmutate</span>.unmutate([-<span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">33</span>, <span class="dv">11</span>])
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/srm485-afraid-of-even/test-unmutate.rb"  mimetype=text/plain > test-unmutate.rb </a>
</div>
</div>
<p>This Ruby version is essentially a port of the Haskell version. The problem at hand is so mathematical that it makes sense to simply preserve the clean Haskell definitions.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I hope you enjoyed this somewhat prolonged mathematical adventure. The most interesting part for me was seeing the problem as a linear equation, and using the formula (which I learned in high school) to derive powerful conclusions. High school algebra is useful after all! Until next time, happy hacking!</p>
]]></summary>
</entry>
<entry>
    <title>Programming Puzzles: Letter and Word Frequency</title>
    <link href="http://funloop.org/post/2015-04-22-letter-word-frequency.html" />
    <id>http://funloop.org/post/2015-04-22-letter-word-frequency.html</id>
    <published>2015-04-22T00:00:00Z</published>
    <updated>2015-04-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-04-22</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-04-22-letter-word-frequency.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/ruby.html">ruby</a>
</div>

<h2 id="motivation">Motivation</h2>
<p>I recently purchased an ErgoDox keyboard<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, and I’ve been thinking about creating my own keyboard layout in the spirit of the Dvorak Simplified Keyboard layout (DSK). One of the guiding principles of DSK was putting an emphasis on reducing finger travel by identifying the most commonly occurring letters of the English language, and placing them on the home row of the keyboard. Now, the Dvorak layout was patented in 1936 according to Wikipedia, with subsequent adjustments culminating in the present form of DSK.</p>
<p>I want to find out for myself what letters are the most common. Sure, I could blindly trust an online source like Wikipedia, but it just feels like an easy problem to solve. Also, I am not sure if Dvorak considered <em>word</em> frequency as well as <em>letter</em> frequency. Ideally, one should use the data of both word and letter frequency to determine what is the most commonly typed “letter” on a US ASCII keyboard for English writers.</p>
<h2 id="the-problems">The Problems</h2>
<h3 id="letter-frequency">Letter Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each letter occurs in the file. You must treat <code>A</code> as the same letter as <code>a</code>. You may limit yourself to the plain US ASCII 26-letter alphabet, discarding all letters with diacritics. Sort the letters by their frequence; for each letter, display the letter itself, its relative frequency percentage to the file as a whole, and the number of times this letter appears (raw count). E.g., the letter <code>a</code> counted by this program might look like this: <code>a = 2.00% (200 occurrences)</code>.</p>
<h3 id="word-frequency">Word Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each <em>word</em> occurs in the file. The precise definition of a “word” is up to you, but you must exclude arabic numerals and also standalone punctuation characters (e.g., “* is not a word”). Display the 100 most common words in similar fashion to the Letter Frequency problem.</p>
<p>Both the letter and word frequency problems will use the Project Gutenberg plaintext file of <a href="http://www.gutenberg.org/cache/epub/2701/pg2701.txt"><em>Moby Dick</em></a>.</p>
<p>Now, before you go on to read my solutions, I encourage you to write a solution on your own using your favorite programming language.</p>
<h2 id="ruby-version">Ruby Version</h2>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/text_freq.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">TextFreq</span>
  <span class="co"># Given a string, count every occurrence of letters a-z (case insensitively).</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_l(src)
    <span class="co"># Construct the array to hold the running totals (occurrences) of each</span>
    <span class="co"># letter. There are 26 letters in the alphabet, so we can just have an array</span>
    <span class="co"># of 26 integers.</span>
    occs = <span class="dt">Array</span>.new(<span class="dv">26</span>, <span class="dv">0</span>)

    <span class="co"># Count occurrences of each letter.</span>
    src.each_char <span class="kw">do</span> |c|
      <span class="kw">if</span> !char_to_idx(c.downcase).nil?
        occs[char_to_idx(c.downcase)] += <span class="dv">1</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    occs
  <span class="kw">end</span>

  <span class="co"># Simply check if the given character belongs to the range of lowercase ASCII</span>
  <span class="co"># characters that make up the alphabet. &quot;a&quot; is 97, and &quot;z&quot; is 122; the numbers</span>
  <span class="co"># for bounds-checking &quot;c&quot; come from these two (offset by 1 to account for the</span>
  <span class="co"># exclusive comparison).</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.char_to_idx(c)
    <span class="dv">96</span> &lt; c.ord &amp;&amp; c.ord &lt; <span class="dv">123</span> ? c.ord - <span class="dv">97</span> : <span class="dv">nil</span>
  <span class="kw">end</span>

  <span class="co"># Given a string, count every occurrence of a particular word. We define a</span>
  <span class="co"># &quot;word&quot; as a sequence of charactes that</span>
  <span class="co">#   - does not have any punctuation characters at the beginning or end, and</span>
  <span class="co">#   - does not have any numbers in it</span>
  <span class="co"># . We take into account that text files from Project Gutenberg use a double</span>
  <span class="co"># dash for an em dash to separate two words.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_w(src)
    occs = {}
    words = src.split(<span class="ot">/\W*\s\W*/</span>).map <span class="kw">do</span> |w|
        w.empty? ? <span class="dv">nil</span> : w.downcase
      <span class="kw">end</span>.compact
    words.each <span class="kw">do</span> |w|
      <span class="co"># Guard against cases like &quot;*&quot; for bullet points and such.</span>
      <span class="kw">if</span> w =~ <span class="ot">/\w/</span>
        <span class="kw">if</span> w =~ <span class="ot">/--/</span>
          w.split(<span class="st">&quot;--&quot;</span>).each <span class="kw">do</span> |y|
            count_word(occs, lstrip_punc(y))
          <span class="kw">end</span>
        <span class="kw">else</span>
          count_word(occs, lstrip_punc(w))
        <span class="kw">end</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    occs
  <span class="kw">end</span>

  <span class="co"># Add 1 to the hash for an existing key (word); otherwise, store a new</span>
  <span class="co"># instance of that word.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.count_word(hash, w)
    hash.key?(w) ? hash[w] += <span class="dv">1</span> : hash.store(w, <span class="dv">1</span>)
    hash
  <span class="kw">end</span>

  <span class="co"># Remove leading punctuation.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.lstrip_punc(w)
    w.match(<span class="ot">/\w.*/</span>)[<span class="dv">0</span>]
  <span class="kw">end</span>

  <span class="co"># Display the frequencies of letters and or words. For letters, we are only</span>
  <span class="co"># concerned about 26 different values, so we print all of them out. However</span>
  <span class="co"># for words, depending on the corpus there might be thousands, or even</span>
  <span class="co"># millions, of different words; thus, we only display the top 100 most common</span>
  <span class="co"># words.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.disp_freq(occs)
    <span class="kw">if</span> occs.is_a?(<span class="dt">Array</span>)
      sum = occs.inject(<span class="dv">0</span>, :+)
      occs.zip((<span class="st">&quot;a&quot;</span>..<span class="st">&quot;z&quot;</span>).to_a).sort.reverse.each <span class="kw">do</span> |cnt, c|
        puts <span class="st">&quot;</span><span class="ot">#{</span>c<span class="ot">}</span><span class="st"> = &quot;</span>\
          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\
          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span>
      <span class="kw">end</span>
    <span class="kw">else</span>
      sum = occs.values.inject(<span class="dv">0</span>, :+)
      occs.sort_by {|w, cnt| cnt}.reverse.take(<span class="dv">100</span>).each <span class="kw">do</span> |w, cnt|
        puts <span class="st">&quot;</span><span class="ot">#{</span>w<span class="ot">}</span><span class="st"> = &quot;</span>\
          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\
          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span>
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/text_freq.rb"  mimetype=text/plain > text_freq.rb </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/analyze.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">#!/usr/bin/env ruby</span>

require_relative <span class="st">&#39;./text_freq&#39;</span>

fname = <span class="dt">ARGV</span>[<span class="dv">0</span>]
file = <span class="dt">File</span>.open(fname, <span class="st">&#39;r:utf-8&#39;</span>)
corpus = file.read

occs_l = <span class="dt">TextFreq</span>.freq_l(corpus)
<span class="dt">TextFreq</span>.disp_freq(occs_l)

puts <span class="st">&quot;-&quot;</span> * <span class="dv">80</span>

occs_w = <span class="dt">TextFreq</span>.freq_w(corpus)
<span class="dt">TextFreq</span>.disp_freq(occs_w)

file.close</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/analyze.rb"  mimetype=text/plain > analyze.rb </a>
</div>
</div>
<p>And here is the output (<code>pg2701.txt</code> is <em>Moby Dick</em>):</p>
<pre><code>$ ./analyze.rb ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.74% (14616 occurrences)
of = 3.10% (6708 occurrences)
and = 2.99% (6488 occurrences)
a = 2.20% (4760 occurrences)
to = 2.16% (4677 occurrences)
in = 1.95% (4223 occurrences)
that = 1.38% (2999 occurrences)
his = 1.17% (2530 occurrences)
it = 1.12% (2419 occurrences)
i = 0.92% (1988 occurrences)
but = 0.84% (1823 occurrences)
he = 0.82% (1777 occurrences)
with = 0.82% (1770 occurrences)
as = 0.81% (1751 occurrences)
is = 0.81% (1747 occurrences)
for = 0.76% (1645 occurrences)
was = 0.76% (1645 occurrences)
all = 0.70% (1523 occurrences)
this = 0.66% (1440 occurrences)
at = 0.62% (1334 occurrences)
by = 0.56% (1223 occurrences)
not = 0.54% (1169 occurrences)
from = 0.51% (1105 occurrences)
on = 0.49% (1069 occurrences)
him = 0.49% (1062 occurrences)
so = 0.49% (1061 occurrences)
be = 0.49% (1060 occurrences)
whale = 0.45% (972 occurrences)
you = 0.44% (944 occurrences)
one = 0.42% (906 occurrences)
or = 0.37% (797 occurrences)
there = 0.37% (792 occurrences)
now = 0.36% (779 occurrences)
had = 0.36% (779 occurrences)
have = 0.36% (772 occurrences)
were = 0.32% (683 occurrences)
they = 0.31% (664 occurrences)
which = 0.30% (655 occurrences)
then = 0.29% (628 occurrences)
me = 0.29% (621 occurrences)
their = 0.29% (620 occurrences)
are = 0.29% (619 occurrences)
some = 0.29% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.28% (600 occurrences)
no = 0.27% (594 occurrences)
my = 0.27% (589 occurrences)
like = 0.27% (581 occurrences)
upon = 0.26% (567 occurrences)
what = 0.26% (566 occurrences)
out = 0.24% (528 occurrences)
into = 0.24% (523 occurrences)
up = 0.24% (516 occurrences)
more = 0.23% (506 occurrences)
if = 0.23% (500 occurrences)
them = 0.22% (471 occurrences)
we = 0.21% (455 occurrences)
man = 0.21% (445 occurrences)
old = 0.20% (444 occurrences)
ahab = 0.20% (432 occurrences)
ye = 0.20% (428 occurrences)
would = 0.20% (428 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
these = 0.19% (405 occurrences)
over = 0.19% (403 occurrences)
will = 0.18% (396 occurrences)
ship = 0.18% (391 occurrences)
though = 0.18% (383 occurrences)
sea = 0.18% (382 occurrences)
its = 0.18% (382 occurrences)
only = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
down = 0.17% (367 occurrences)
any = 0.17% (363 occurrences)
who = 0.16% (345 occurrences)
yet = 0.16% (344 occurrences)
her = 0.15% (329 occurrences)
time = 0.15% (326 occurrences)
very = 0.15% (323 occurrences)
do = 0.15% (321 occurrences)
long = 0.15% (319 occurrences)
about = 0.15% (318 occurrences)
than = 0.14% (311 occurrences)
still = 0.14% (311 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (303 occurrences)
said = 0.14% (301 occurrences)
captain = 0.14% (300 occurrences)
before = 0.14% (300 occurrences)
here = 0.14% (299 occurrences)
has = 0.14% (294 occurrences)
must = 0.13% (292 occurrences)
two = 0.13% (288 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
last = 0.13% (276 occurrences)
head = 0.13% (275 occurrences)
see = 0.12% (268 occurrences)
thou = 0.12% (267 occurrences)</code></pre>
<p>. The file of course contains remarks and legalese from Project Gutenberg, so if you want more accuracy you would have to redact those parts before running this script.</p>
<h3 id="letter-frequency-1">Letter Frequency</h3>
<p>The <code>freq_l</code> method views letters in the limited US ASCII range and uses crude, C-like letter-to-integer equivalence via <code>char_to_idx</code>. We use a simple array of 26 integers, each one corresponding to a letter. But thanks to its stupidity, <code>freq_l</code> runs quite fast — chugging through Moby Dick in a few seconds on my Core i7-4770K 4GHz machine.</p>
<h3 id="word-frequency-1">Word Frequency</h3>
<p>The <code>freq_w</code> method relies almost entirely on a single regex, <code>/\W*\s\W*/</code>, to split the input into words. These words are further processed; we perform a basic sanity check with the <code>/\w/</code> regex to make sure we are not dealing with just numbers or punctuation, and we also take into account the em dash <code>--</code>. We use a basic hash structure to store the words as keys, and their counts as values.</p>
<h2 id="haskell-version">Haskell Version</h2>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/TextFreq.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">TextFreq</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>
<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Data.Ord</span> (comparing)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import qualified</span> <span class="dt">Text.Printf</span> <span class="kw">as</span> <span class="dt">TP</span>

<span class="kw">type</span> <span class="dt">LHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Char</span> <span class="dt">Word64</span>

<span class="kw">type</span> <span class="dt">WProto</span> <span class="fu">=</span> <span class="dt">T.Text</span>
<span class="kw">type</span> <span class="dt">WHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">WProto</span> <span class="dt">Word64</span>
<span class="kw">data</span> <span class="dt">WFSM</span>
	<span class="fu">=</span> <span class="dt">WordIn</span>
	<span class="fu">|</span> <span class="dt">WordOutMaybe</span>
	<span class="fu">|</span> <span class="dt">WordOut</span>
	<span class="kw">deriving</span> (<span class="dt">Eq</span>)
<span class="kw">data</span> <span class="dt">WBuild</span> <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WFSM</span> <span class="dt">WProto</span> <span class="dt">WHash</span>

<span class="ot">freqL ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">LHash</span>
freqL <span class="fu">=</span> T.foldl step occs
	<span class="kw">where</span>
	occs <span class="fu">=</span> M.empty
	step lhash c
		<span class="co">-- | isAlpha c = M.insertWith (+) (toLower c) 1 lhash -- this picks up non-ASCII &#39;word&#39; letters, even korean/japanese!</span>
		<span class="fu">|</span> elem c ([<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;z&#39;</span>] <span class="fu">++</span> [<span class="ch">&#39;A&#39;</span><span class="fu">..</span><span class="ch">&#39;Z&#39;</span>]) <span class="fu">=</span> M.insertWith (<span class="fu">+</span>) (toLower c) <span class="dv">1</span> lhash
		<span class="fu">|</span> elem c (concat puncKeys) <span class="fu">=</span> <span class="kw">case</span> lookup c puncTuples <span class="kw">of</span>
			<span class="dt">Just</span> pkey <span class="ot">-&gt;</span> M.insertWith (<span class="fu">+</span>) pkey <span class="dv">1</span> lhash
			<span class="dt">Nothing</span> <span class="ot">-&gt;</span> lhash
		<span class="fu">|</span> otherwise <span class="fu">=</span> lhash
	puncKeys <span class="fu">=</span>
		[ <span class="st">&quot;`~&quot;</span>
		, <span class="st">&quot;-_&quot;</span>
		, <span class="st">&quot;=+&quot;</span>
		, <span class="st">&quot;[{&quot;</span>
		, <span class="st">&quot;}]&quot;</span>
		, <span class="st">&quot;\\|&quot;</span>
		, <span class="st">&quot;;:&quot;</span>
		, <span class="st">&quot;&#39;\&quot;&quot;</span>
		, <span class="st">&quot;,&lt;&quot;</span>
		, <span class="st">&quot;.&gt;&quot;</span>
		, <span class="st">&quot;/?&quot;</span>
		]
	puncTuples <span class="fu">=</span> concatMap (\keyPair <span class="ot">-&gt;</span> [(head keyPair, head keyPair), (last keyPair, head keyPair)]) puncKeys

<span class="ot">freqW ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">WHash</span>
freqW <span class="fu">=</span> (\(<span class="dt">WBuild</span> _ _ whash) <span class="ot">-&gt;</span> whash) <span class="fu">.</span> T.foldl step occs
	<span class="kw">where</span>
	<span class="co">-- Use WordOut as the initial state for WFSM, because we&#39;re starting from</span>
	<span class="co">-- nothing!</span>
<span class="ot">	occs ::</span> <span class="dt">WBuild</span>
	occs <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty M.empty
	step wb<span class="fu">@</span>(<span class="dt">WBuild</span> wfsm wproto whash) c
		<span class="co">-- Letter.</span>
		<span class="fu">|</span> isAlpha c <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- This is when we first encounter a letter.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.singleton c&#39;) whash
			_ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.snoc wproto c&#39;) whash
		<span class="co">-- Apostrophe. We ignore all leading apostrophes and only store</span>
		<span class="co">-- apostrophes at the end of a word, such as &quot;goin&#39;&quot;.</span>
		<span class="fu">|</span> c <span class="fu">==</span> <span class="ch">&#39;\&#39;&#39;</span> <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- This is when we encounter an apostrophe either at the middle or</span>
			<span class="co">-- end of a word.</span>
			<span class="dt">WordIn</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOutMaybe</span> (T.snoc wproto c&#39;) whash
			<span class="co">-- E.g., &quot;goin&#39;&#39;&quot; (a contracted &quot;goin&#39;&#39;&quot; ending with a nested inner</span>
			<span class="co">-- quote). We store it as &quot;goin&#39;&quot;.</span>
			<span class="dt">WordOutMaybe</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty
				<span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash
			<span class="co">-- Already out of a word area, such as a space character. We do</span>
			<span class="co">-- nothing.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb
		<span class="co">-- If we&#39;re looking at neither a letter nor an apostrophe.</span>
		<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- A series of nonsense chars; ignore.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb
			<span class="co">-- End of a word.</span>
			_ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty
				<span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash
		<span class="kw">where</span>
		c&#39; <span class="fu">=</span> toLower c

<span class="ot">dispFreqL ::</span> <span class="dt">LHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dispFreqL lhash <span class="fu">=</span> mapM_ f <span class="fu">.</span> reverse <span class="fu">.</span> sortBy (comparing snd) <span class="fu">$</span> M.toList lhash
	<span class="kw">where</span>
<span class="ot">	total ::</span> <span class="dt">Word64</span>
	total <span class="fu">=</span> sum <span class="fu">$</span> M.elems lhash
<span class="ot">	f ::</span> (<span class="dt">Char</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
	f (c, n) <span class="fu">=</span> putStrLn <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3
		<span class="kw">where</span>
<span class="ot">		perc ::</span> <span class="dt">Double</span>
		perc
			<span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
			<span class="fu">|</span> otherwise <span class="fu">=</span> (fromIntegral n) <span class="fu">/</span> (fromIntegral total) <span class="fu">*</span> <span class="dv">100</span>
		msg1 <span class="fu">=</span> [c] <span class="fu">++</span> <span class="st">&quot; = &quot;</span>
		msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc
		msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span>

<span class="ot">dispFreqW ::</span> <span class="dt">WHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dispFreqW whash <span class="fu">=</span> mapM_ f <span class="fu">.</span> take <span class="dv">100</span> <span class="fu">.</span> reverse <span class="fu">.</span> sortBy (comparing snd) <span class="fu">$</span> M.toList whash
	<span class="kw">where</span>
<span class="ot">	total ::</span> <span class="dt">Word64</span>
	total <span class="fu">=</span> sum <span class="fu">$</span> M.elems whash
<span class="ot">	f ::</span> (<span class="dt">WProto</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
	f (w, n) <span class="fu">=</span> putStrLn <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3
		<span class="kw">where</span>
<span class="ot">		perc ::</span> <span class="dt">Double</span>
		perc
			<span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
			<span class="fu">|</span> otherwise <span class="fu">=</span> (fromIntegral n) <span class="fu">/</span> (fromIntegral total) <span class="fu">*</span> <span class="dv">100</span>
		msg1 <span class="fu">=</span> T.unpack w <span class="fu">++</span> <span class="st">&quot; = &quot;</span>
		msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc
		msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/TextFreq.hs"  mimetype=text/plain > TextFreq.hs </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/analyze.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">import </span><span class="dt">TextFreq</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
	fileList <span class="ot">&lt;-</span> T.getContents
	src <span class="ot">&lt;-</span> liftM T.concat <span class="fu">.</span> mapM (T.readFile <span class="fu">.</span> T.unpack) <span class="fu">$</span> T.lines fileList
	dispFreqL <span class="fu">$</span> freqL src
	putStrLn <span class="fu">$</span> replicate <span class="dv">80</span> <span class="ch">&#39;-&#39;</span>
	dispFreqW <span class="fu">$</span> freqW src</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/analyze.hs"  mimetype=text/plain > analyze.hs </a>
</div>
</div>
<p>Here is the same run against our copy of <em>Moby Dick</em>:</p>
<pre><code>$ ./analyze ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.67% (14620 occurrences)
of = 3.07% (6732 occurrences)
and = 2.97% (6502 occurrences)
a = 2.18% (4788 occurrences)
to = 2.15% (4706 occurrences)
in = 1.93% (4231 occurrences)
that = 1.37% (3005 occurrences)
his = 1.15% (2530 occurrences)
it = 1.11% (2434 occurrences)
i = 0.91% (1993 occurrences)
but = 0.83% (1823 occurrences)
he = 0.81% (1780 occurrences)
with = 0.81% (1770 occurrences)
as = 0.80% (1752 occurrences)
is = 0.80% (1748 occurrences)
was = 0.75% (1646 occurrences)
for = 0.75% (1646 occurrences)
all = 0.70% (1543 occurrences)
this = 0.66% (1443 occurrences)
at = 0.61% (1335 occurrences)
by = 0.56% (1226 occurrences)
not = 0.53% (1171 occurrences)
whale = 0.51% (1108 occurrences)
from = 0.50% (1105 occurrences)
on = 0.49% (1073 occurrences)
him = 0.49% (1067 occurrences)
so = 0.49% (1066 occurrences)
be = 0.49% (1064 occurrences)
you = 0.43% (946 occurrences)
one = 0.42% (914 occurrences)
there = 0.37% (805 occurrences)
or = 0.36% (797 occurrences)
now = 0.36% (783 occurrences)
had = 0.36% (779 occurrences)
have = 0.35% (773 occurrences)
were = 0.31% (683 occurrences)
they = 0.30% (664 occurrences)
which = 0.30% (655 occurrences)
like = 0.30% (647 occurrences)
me = 0.29% (632 occurrences)
then = 0.29% (630 occurrences)
their = 0.28% (620 occurrences)
some = 0.28% (619 occurrences)
are = 0.28% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.27% (600 occurrences)
no = 0.27% (596 occurrences)
my = 0.27% (589 occurrences)
upon = 0.26% (568 occurrences)
what = 0.26% (566 occurrences)
out = 0.25% (539 occurrences)
up = 0.24% (524 occurrences)
into = 0.24% (523 occurrences)
more = 0.23% (508 occurrences)
if = 0.23% (501 occurrences)
man = 0.22% (476 occurrences)
them = 0.22% (474 occurrences)
we = 0.21% (455 occurrences)
sea = 0.21% (454 occurrences)
old = 0.21% (452 occurrences)
ship = 0.20% (438 occurrences)
ahab = 0.20% (436 occurrences)
ye = 0.20% (431 occurrences)
would = 0.20% (430 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
over = 0.19% (409 occurrences)
these = 0.19% (406 occurrences)
will = 0.18% (398 occurrences)
though = 0.18% (384 occurrences)
its = 0.17% (382 occurrences)
only = 0.17% (378 occurrences)
down = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
any = 0.17% (364 occurrences)
who = 0.16% (347 occurrences)
yet = 0.16% (345 occurrences)
head = 0.16% (344 occurrences)
time = 0.15% (334 occurrences)
long = 0.15% (334 occurrences)
her = 0.15% (332 occurrences)
do = 0.15% (324 occurrences)
very = 0.15% (323 occurrences)
about = 0.15% (318 occurrences)
still = 0.14% (312 occurrences)
than = 0.14% (311 occurrences)
captain = 0.14% (308 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (306 occurrences)
said = 0.14% (305 occurrences)
here = 0.14% (302 occurrences)
before = 0.14% (301 occurrences)
two = 0.14% (298 occurrences)
boat = 0.14% (297 occurrences)
has = 0.13% (294 occurrences)
must = 0.13% (293 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
white = 0.13% (281 occurrences)
last = 0.13% (278 occurrences)</code></pre>
<p>.</p>
<h3 id="letter-frequency-2">Letter Frequency</h3>
<p><code>freqL</code> handles letter frequency, and it is a simple <code>foldl</code> operation over the input, while using the <code>Map</code> data structure from the <code>Data.Map</code> library (which acts as a simple hash structure with keys and values). The de facto Haskell compiler GHC comes with the <code>base</code> library which includes the <code>Data.Char</code> module; unlike Ruby, we can simply ask whether a character is a letter with <code>isAlpha</code>, and then use <code>toLower</code> on it to convert it to lowercase. <code>freqL</code> owes its brevity to these standard library functions.</p>
<p>Thanks to these standard library functions, we can easily keep track of more than just the basic 26 alphabetical letters (although in the case of <em>Moby Dick</em>, there does not seem to be any such characters).</p>
<h3 id="word-frequency-2">Word Frequency</h3>
<p>This is probably a convoluted way to keep track of words. I did not opt for using regular expressions, because I wanted to try out a different approach instead of just translating the Ruby solution. I could have used the excellent Parsec library, but I just felt like rolling my own solution.</p>
<p><code>freqW</code> works by looking at just one character at a time, just like <code>freqL</code>. It also keeps track of the evaluation of the previously-looked-at character, with the <code>wfsm</code> variable (for <em>Word Finite State Machine</em>, a fancy but still pertinent name). <code>wfsm</code> can either say that the last character made us go <em>in</em> a word (<code>WordIn</code>), <em>out</em> of a word for sure (<code>WordOut</code>), or possibly out of a word (<code>WordOutMaybe</code>). Depending on the status of <code>wfsm</code> and the current character, <code>freqW</code> makes various choices.</p>
<p>Now, this mechanism isn’t without its warts. But still, I consider it somewhat elegant in its description of all possible states.</p>
<h2 id="a-diff">A Diff</h2>
<p>For fun, let’s look at the diff of the outputs of the Ruby and Haskell versions. Interestingly, the letter frequency outputs were identical. The word frequency outputs did have some significant changes, such as the word <em>whale</em> occurring 972 and 1108 times in the Ruby and Haskell versions, respectively. I’ve sorted the output by lines for saner diffing.</p>
<pre><code>$ diff -u routW houtW
--- routW	2015-04-22 22:01:59.061404962 -0700
+++ houtW	2015-04-22 22:02:57.679828155 -0700
@@ -1,100 +1,100 @@
-a = 2.20% (4760 occurrences)
+a = 2.18% (4788 occurrences)
 about = 0.15% (318 occurrences)
-ahab = 0.20% (432 occurrences)
-all = 0.70% (1523 occurrences)
-an = 0.28% (600 occurrences)
-and = 2.99% (6488 occurrences)
-any = 0.17% (363 occurrences)
-are = 0.29% (619 occurrences)
-as = 0.81% (1751 occurrences)
-at = 0.62% (1334 occurrences)
-be = 0.49% (1060 occurrences)
+ahab = 0.20% (436 occurrences)
+all = 0.70% (1543 occurrences)
+an = 0.27% (600 occurrences)
+and = 2.97% (6502 occurrences)
+any = 0.17% (364 occurrences)
+are = 0.28% (619 occurrences)
+as = 0.80% (1752 occurrences)
+at = 0.61% (1335 occurrences)
+be = 0.49% (1064 occurrences)
 been = 0.19% (415 occurrences)
-before = 0.14% (300 occurrences)
-but = 0.84% (1823 occurrences)
-by = 0.56% (1223 occurrences)
-captain = 0.14% (300 occurrences)
-do = 0.15% (321 occurrences)
-down = 0.17% (367 occurrences)
-for = 0.76% (1645 occurrences)
-from = 0.51% (1105 occurrences)
-great = 0.14% (303 occurrences)
+before = 0.14% (301 occurrences)
+boat = 0.14% (297 occurrences)
+but = 0.83% (1823 occurrences)
+by = 0.56% (1226 occurrences)
+captain = 0.14% (308 occurrences)
+do = 0.15% (324 occurrences)
+down = 0.17% (378 occurrences)
+for = 0.75% (1646 occurrences)
+from = 0.50% (1105 occurrences)
+great = 0.14% (306 occurrences)
 had = 0.36% (779 occurrences)
-has = 0.14% (294 occurrences)
-have = 0.36% (772 occurrences)
-he = 0.82% (1777 occurrences)
-head = 0.13% (275 occurrences)
-her = 0.15% (329 occurrences)
-here = 0.14% (299 occurrences)
-him = 0.49% (1062 occurrences)
-his = 1.17% (2530 occurrences)
-i = 0.92% (1988 occurrences)
-if = 0.23% (500 occurrences)
-in = 1.95% (4223 occurrences)
+has = 0.13% (294 occurrences)
+have = 0.35% (773 occurrences)
+he = 0.81% (1780 occurrences)
+head = 0.16% (344 occurrences)
+her = 0.15% (332 occurrences)
+here = 0.14% (302 occurrences)
+him = 0.49% (1067 occurrences)
+his = 1.15% (2530 occurrences)
+i = 0.91% (1993 occurrences)
+if = 0.23% (501 occurrences)
+in = 1.93% (4231 occurrences)
 into = 0.24% (523 occurrences)
-is = 0.81% (1747 occurrences)
-it = 1.12% (2419 occurrences)
-its = 0.18% (382 occurrences)
-last = 0.13% (276 occurrences)
-like = 0.27% (581 occurrences)
-long = 0.15% (319 occurrences)
-man = 0.21% (445 occurrences)
-me = 0.29% (621 occurrences)
-more = 0.23% (506 occurrences)
+is = 0.80% (1748 occurrences)
+it = 1.11% (2434 occurrences)
+its = 0.17% (382 occurrences)
+last = 0.13% (278 occurrences)
+like = 0.30% (647 occurrences)
+long = 0.15% (334 occurrences)
+man = 0.22% (476 occurrences)
+me = 0.29% (632 occurrences)
+more = 0.23% (508 occurrences)
 most = 0.13% (284 occurrences)
-must = 0.13% (292 occurrences)
+must = 0.13% (293 occurrences)
 my = 0.27% (589 occurrences)
-no = 0.27% (594 occurrences)
-not = 0.54% (1169 occurrences)
-now = 0.36% (779 occurrences)
-of = 3.10% (6708 occurrences)
-old = 0.20% (444 occurrences)
-on = 0.49% (1069 occurrences)
-one = 0.42% (906 occurrences)
+no = 0.27% (596 occurrences)
+not = 0.53% (1171 occurrences)
+now = 0.36% (783 occurrences)
+of = 3.07% (6732 occurrences)
+old = 0.21% (452 occurrences)
+on = 0.49% (1073 occurrences)
+one = 0.42% (914 occurrences)
 only = 0.17% (378 occurrences)
-or = 0.37% (797 occurrences)
+or = 0.36% (797 occurrences)
 other = 0.19% (416 occurrences)
-out = 0.24% (528 occurrences)
-over = 0.19% (403 occurrences)
-said = 0.14% (301 occurrences)
-sea = 0.18% (382 occurrences)
-see = 0.12% (268 occurrences)
+out = 0.25% (539 occurrences)
+over = 0.19% (409 occurrences)
+said = 0.14% (305 occurrences)
+sea = 0.21% (454 occurrences)
 seemed = 0.13% (283 occurrences)
-ship = 0.18% (391 occurrences)
-so = 0.49% (1061 occurrences)
-some = 0.29% (619 occurrences)
-still = 0.14% (311 occurrences)
+ship = 0.20% (438 occurrences)
+so = 0.49% (1066 occurrences)
+some = 0.28% (619 occurrences)
+still = 0.14% (312 occurrences)
 such = 0.17% (376 occurrences)
 than = 0.14% (311 occurrences)
-that = 1.38% (2999 occurrences)
-the = 6.74% (14616 occurrences)
-their = 0.29% (620 occurrences)
-them = 0.22% (471 occurrences)
-then = 0.29% (628 occurrences)
-there = 0.37% (792 occurrences)
-these = 0.19% (405 occurrences)
-they = 0.31% (664 occurrences)
-this = 0.66% (1440 occurrences)
+that = 1.37% (3005 occurrences)
+the = 6.67% (14620 occurrences)
+their = 0.28% (620 occurrences)
+them = 0.22% (474 occurrences)
+then = 0.29% (630 occurrences)
+there = 0.37% (805 occurrences)
+these = 0.19% (406 occurrences)
+they = 0.30% (664 occurrences)
+this = 0.66% (1443 occurrences)
 those = 0.14% (307 occurrences)
-thou = 0.12% (267 occurrences)
-though = 0.18% (383 occurrences)
-time = 0.15% (326 occurrences)
-to = 2.16% (4677 occurrences)
-two = 0.13% (288 occurrences)
-up = 0.24% (516 occurrences)
-upon = 0.26% (567 occurrences)
+though = 0.18% (384 occurrences)
+time = 0.15% (334 occurrences)
+to = 2.15% (4706 occurrences)
+two = 0.14% (298 occurrences)
+up = 0.24% (524 occurrences)
+upon = 0.26% (568 occurrences)
 very = 0.15% (323 occurrences)
-was = 0.76% (1645 occurrences)
+was = 0.75% (1646 occurrences)
 we = 0.21% (455 occurrences)
-were = 0.32% (683 occurrences)
-whale = 0.45% (972 occurrences)
+were = 0.31% (683 occurrences)
+whale = 0.51% (1108 occurrences)
 what = 0.26% (566 occurrences)
 when = 0.28% (607 occurrences)
 which = 0.30% (655 occurrences)
-who = 0.16% (345 occurrences)
-will = 0.18% (396 occurrences)
-with = 0.82% (1770 occurrences)
-would = 0.20% (428 occurrences)
-ye = 0.20% (428 occurrences)
-yet = 0.16% (344 occurrences)
-you = 0.44% (944 occurrences)
+white = 0.13% (281 occurrences)
+who = 0.16% (347 occurrences)
+will = 0.18% (398 occurrences)
+with = 0.81% (1770 occurrences)
+would = 0.20% (430 occurrences)
+ye = 0.20% (431 occurrences)
+yet = 0.16% (345 occurrences)
+you = 0.43% (946 occurrences)</code></pre>
<h2 id="french">French?</h2>
<p>Here is the Haskell version’s output on the first volume of <a href="http://www.gutenberg.org/cache/epub/17489/pg17489.txt"><em>Les Misérables</em></a> in the original French:</p>
<pre><code>e = 14.68% (77528 occurrences)
a = 8.12% (42892 occurrences)
i = 7.65% (40424 occurrences)
t = 7.62% (40270 occurrences)
s = 7.27% (38395 occurrences)
n = 6.76% (35704 occurrences)
r = 6.25% (32985 occurrences)
u = 6.16% (32553 occurrences)
l = 5.81% (30686 occurrences)
o = 5.17% (27315 occurrences)
d = 3.46% (18262 occurrences)
c = 3.06% (16150 occurrences)
m = 2.99% (15800 occurrences)
p = 2.61% (13784 occurrences)
v = 1.95% (10285 occurrences)
é = 1.87% (9852 occurrences)
q = 1.26% (6637 occurrences)
f = 1.18% (6245 occurrences)
h = 1.06% (5623 occurrences)
b = 0.99% (5244 occurrences)
g = 0.93% (4910 occurrences)
j = 0.56% (2973 occurrences)
à = 0.53% (2795 occurrences)
x = 0.40% (2102 occurrences)
y = 0.39% (2051 occurrences)
è = 0.32% (1702 occurrences)
ê = 0.30% (1584 occurrences)
z = 0.18% (964 occurrences)
â = 0.08% (410 occurrences)
ç = 0.07% (355 occurrences)
û = 0.06% (335 occurrences)
ô = 0.05% (290 occurrences)
ù = 0.05% (285 occurrences)
w = 0.05% (284 occurrences)
î = 0.05% (276 occurrences)
k = 0.03% (151 occurrences)
ï = 0.01% (47 occurrences)
ë = 0.00% (5 occurrences)
ü = 0.00% (2 occurrences)
ñ = 0.00% (2 occurrences)
--------------------------------------------------------------------------------
de = 3.89% (4472 occurrences)
la = 2.64% (3040 occurrences)
et = 2.57% (2949 occurrences)
il = 2.25% (2582 occurrences)
le = 2.22% (2548 occurrences)
à = 1.94% (2236 occurrences)
les = 1.34% (1538 occurrences)
un = 1.27% (1459 occurrences)
que = 1.17% (1350 occurrences)
qui = 1.11% (1278 occurrences)
dans = 0.99% (1134 occurrences)
une = 0.92% (1062 occurrences)
ce = 0.92% (1062 occurrences)
en = 0.90% (1036 occurrences)
des = 0.82% (948 occurrences)
pas = 0.76% (879 occurrences)
se = 0.75% (859 occurrences)
ne = 0.73% (843 occurrences)
était = 0.69% (792 occurrences)
vous = 0.68% (783 occurrences)
je = 0.67% (770 occurrences)
avait = 0.66% (760 occurrences)
lui = 0.63% (721 occurrences)
du = 0.62% (714 occurrences)
elle = 0.57% (660 occurrences)
sur = 0.56% (640 occurrences)
sa = 0.55% (635 occurrences)
pour = 0.54% (620 occurrences)
son = 0.53% (611 occurrences)
au = 0.50% (579 occurrences)
cette = 0.48% (556 occurrences)
on = 0.47% (537 occurrences)
est = 0.46% (533 occurrences)
qu&#39;il = 0.46% (528 occurrences)
a = 0.46% (524 occurrences)
tout = 0.45% (514 occurrences)
plus = 0.44% (508 occurrences)
comme = 0.44% (503 occurrences)
dit = 0.39% (446 occurrences)
avec = 0.38% (432 occurrences)
c&#39;est = 0.36% (416 occurrences)
y = 0.35% (404 occurrences)
par = 0.34% (392 occurrences)
mais = 0.30% (350 occurrences)
nous = 0.30% (340 occurrences)
ses = 0.28% (321 occurrences)
là = 0.27% (308 occurrences)
bien = 0.27% (305 occurrences)
deux = 0.26% (303 occurrences)
monsieur = 0.26% (296 occurrences)
même = 0.26% (295 occurrences)
cela = 0.26% (295 occurrences)
ces = 0.26% (294 occurrences)
si = 0.24% (273 occurrences)
où = 0.23% (269 occurrences)
m = 0.23% (266 occurrences)
me = 0.21% (238 occurrences)
l&#39;évêque = 0.21% (236 occurrences)
homme = 0.20% (234 occurrences)
sans = 0.20% (233 occurrences)
aux = 0.20% (232 occurrences)
fait = 0.20% (230 occurrences)
madeleine = 0.19% (214 occurrences)
qu&#39;on = 0.18% (210 occurrences)
jean = 0.18% (210 occurrences)
d&#39;un = 0.18% (208 occurrences)
c&#39;était = 0.17% (199 occurrences)
valjean = 0.17% (197 occurrences)
être = 0.17% (196 occurrences)
fantine = 0.17% (192 occurrences)
d&#39;une = 0.17% (190 occurrences)
javert = 0.15% (177 occurrences)
the = 0.15% (176 occurrences)
peu = 0.15% (173 occurrences)
cet = 0.15% (173 occurrences)
faire = 0.15% (172 occurrences)
puis = 0.15% (169 occurrences)
moi = 0.15% (168 occurrences)
j&#39;ai = 0.14% (164 occurrences)
chose = 0.14% (164 occurrences)
été = 0.14% (163 occurrences)
maire = 0.14% (162 occurrences)
dire = 0.14% (159 occurrences)
rien = 0.14% (158 occurrences)
quand = 0.14% (157 occurrences)
sont = 0.13% (153 occurrences)
quelque = 0.13% (153 occurrences)
tous = 0.13% (152 occurrences)
porte = 0.13% (150 occurrences)
ou = 0.13% (148 occurrences)
toute = 0.13% (147 occurrences)
chapitre = 0.13% (144 occurrences)
sous = 0.12% (142 occurrences)
peut = 0.12% (140 occurrences)
mon = 0.12% (138 occurrences)
moment = 0.12% (138 occurrences)
dieu = 0.12% (137 occurrences)
encore = 0.12% (134 occurrences)
l&#39;homme = 0.11% (130 occurrences)
eût = 0.11% (130 occurrences)</code></pre>
<p>. The most common French word in this book is <em>de</em>, meaning <em>of</em> in English. This is because the word for <em>the</em> is split into many different words, most notably <em>la</em> and <em>le</em>, not to mention <em>l’</em> as in <em>l’homme</em> (as you can see near the end of the list), due to the French language’s gender and vowel contraction rules (unlike English, contractions like <em>l’homme</em> in French are mandatory regardless of tone).</p>
<p>And, as a bit of trivia, it is interesting to note that <em>dieu</em> (God) edges out <em>l’homme</em> (man) by 7 occurrences in this text.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope you’ve had some fun working on these letter and word frequency problems. The word frequency problem, if you really want to do it correctly, should be handled by a parser using a robust library. By writing these programs, I learned that the <em>input</em> of a program (Unicode? ASCII only?) is just as important as its output.</p>
<p>Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>After I receive, assemble, and acclimate myself to it, I will post a review.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Generating Random Numbers without Modulo Bias, Redux</title>
    <link href="http://funloop.org/post/2015-02-27-removing-modulo-bias-redux.html" />
    <id>http://funloop.org/post/2015-02-27-removing-modulo-bias-redux.html</id>
    <published>2015-02-27T00:00:00Z</published>
    <updated>2015-02-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-02-27</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-27-removing-modulo-bias-redux.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/rng.html">rng</a>, <a href="/tag/c.html">c</a>
</div>

<p>In an earlier post, I discussed <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">how to remove modulo bias from your C code</a>. I would like to add a different version of removing modulo bias, inspired by the code from the <a href="http://www.pcg-random.org/">PCG family</a> of random number generators.</p>
<h2 id="the-pcg-version">The PCG Version</h2>
<p>In the <a href="http://www.pcg-random.org/download.html">official minimal C implementation</a> of PCG, there is a function called <code>pcg32_boundedrand_r</code>, which takes a <code>bound</code> variable. The code for that function is as follows:</p>
<div class="sourceCode"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">uint32_t</span> pcg32_boundedrand_r(pcg32_random_t* rng, <span class="dt">uint32_t</span> bound)
{
	<span class="dt">uint32_t</span> threshold = -bound % bound;
	<span class="kw">for</span> (;;) {
		<span class="dt">uint32_t</span> r = pcg32_random_r(rng);
		<span class="kw">if</span> (r &gt;= threshold)
			<span class="kw">return</span> r % bound;
	}
}</code></pre></td></tr></table></div>
<p>. If <code>bound</code> is 5, then the function will return a uniform range from 0 to 4. I.e., the return value <code>r</code> is such that <span class="math inline">\(0 \leq r &lt; bound\)</span>.</p>
<h2 id="explanation-of-the-pcg-version">Explanation of the PCG Version</h2>
<p>Although I generally prefer to explain code in the order they appear, top to bottom, for this case I would like to explain the <code>pcg32_boundedrand_r()</code> function by talking about the usual broken version found in the wild.</p>
<h3 id="broken-version">Broken Version</h3>
<p>The broken version is like this:</p>
<pre><code>r = some_rng();
return r % bound;</code></pre>
<p>. Unless <code>r</code> is a multiple of <code>bound</code>, we will incur the wrath of modulo bias in the above code. Why is this? Well, consider what the modulo operator does. All it does is chop off any excess range of values that is not a multiple of <code>bound</code>. Consider the following ASCII diagram, where the maximum value returned by our <code>some_rng()</code> function is just 11:</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 10 11</code></pre>
<p>. So, <code>some_rng()</code> has 12 possible unique values, 0 through 11. If our bound was <code>4</code>, then doing <code>r % bound</code> is perfectly fine, because we can chop the RNG range into three equal parts of length 4 each, like this:</p>
<pre><code>0 1 2 3 | 4 5 6 7 | 8 9 10 11</code></pre>
<p>. If each of the 12 values 0 through 11 occurs uniformly<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, then we can assume that each of the values occurs <span class="math inline">\(\frac{1}{12}\)</span> times. If we apply <code>% 4</code> to the values, then our output range looks like this:</p>
<pre><code>0 1 2 3 | 0 1 2 3 | 0 1 2 3</code></pre>
<p>. Can you see how the three subparts are the same? What’s more, 0 will occur <span class="math inline">\(\frac{3}{12} = \frac{1}{4}\)</span> times. The same goes for <code>1</code>, <code>2</code>, and <code>3</code>. Because all 4 possible values, 0 through 4, occur an equal <span class="math inline">\(\frac{1}{4}\)</span> times, there is <em>no modulo bias here</em>!</p>
<h4 id="what-if-the-modulus-is-not-a-nice-number-with-respect-to-rand_max">What if the modulus is not a nice number with respect to <code>RAND_MAX</code>?</h4>
<p>This is where the problem occurs. <code>RAND_MAX</code> is the highest value returned by our RNG, and thus defines the range of the possible values output by the RNG.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> Continuing with our example above, if instead of <code>bound = 4</code>, we used another value like 5, we will get this instead:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11</code></pre>
<p>— or essentially, these values are output if we just naively use <code>r % bound</code>:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>. Can you see how <code>0</code> and <code>1</code> will occur <span class="math inline">\(\frac{3}{12}\)</span> times, but <code>2</code>, <code>3</code>, and <code>4</code> will occur only <span class="math inline">\(\frac{2}{12}\)</span> times?</p>
<h4 id="the-fix-adjust-the-range">The fix — adjust the range!</h4>
<p>Now, we can fix the above example by simply throwing out certain values. The approach I used in the <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">old blog post</a> was to discard the right hand side values. So, in our example with <code>bound = 5</code>, where we have</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>, the old example tried to discard the last 2 values, like this:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | x x</code></pre>
<p>. In other words, if <code>r</code> fell within the range 10 through 11, then we’d simply discard it and call <code>some_rand()</code> again.</p>
<p>But it doesn’t have to be this way. Instead of throwing out the values on the right, we can throw out the values on the left! So, instead of</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | x x</code></pre>
<p>we can instead do</p>
<pre><code>x x 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>. Can you see how all of the values 0 through 4 occur exactly 2 times? No more bias!</p>
<h3 id="pcgs-approach">PCG’s approach</h3>
<p>The approach in PCG is the same; here is the code again:</p>
<div class="sourceCode"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">uint32_t</span> pcg32_boundedrand_r(pcg32_random_t* rng, <span class="dt">uint32_t</span> bound)
{
	<span class="dt">uint32_t</span> threshold = -bound % bound;
	<span class="kw">for</span> (;;) {
		<span class="dt">uint32_t</span> r = pcg32_random_r(rng);
		<span class="kw">if</span> (r &gt;= threshold)
			<span class="kw">return</span> r % bound;
	}
}</code></pre></td></tr></table></div>
<p>. The <code>threshold</code> value is the initial range that must be discarded. So we can visualize it like this:</p>
<pre><code>x x 2 3 4 | 0 1 2 3 4 | 0 1

// The `x x` here is the initial threshold range, that must be discarded.</code></pre>
<p>On line 3, we determine the value of <code>threshold</code>, and then on line 4 we enter a <code>for</code> loop that repeatedly calls the RNG until we get a value outside of this threshold range (well, technically, <em>greater-than-or-equal-to</em> the threshold value). If we do get such a value, then we return the modulo of it. If we visualize it, it’s like this:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11

- Discard 0 and 1 (the threshold area).

x x 2 3 4 | 5 6 7 8 9 | 10 11

- Return (r % bound).

x x 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>.</p>
<h4 id="how-is-threshold-calculated">How is <code>threshold</code> calculated?</h4>
<p>The above high-level explanation should be sufficient for you, dear reader. But if you want to go down to the innards of C, to see how <code>pcg32_boundedrand_r</code> works, read on.</p>
<p>The cornerstone of the PCG approach is to use a variable called <code>threshold</code>. The code to calculate <code>threshold</code> is somewhat complicated:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> threshold = -bound % bound;</code></pre></div>
<p>. Now, let’s remind ourselves that the whole point of <code>threshold</code> is to be a minimum value that sets a cutoff of values to be discarded — if the generated value <code>r</code> is too low (lower than our threshold), then we discard it.</p>
<p>Consider the following diagram, with <code>RAND_MAX</code> set to <code>11</code>, and <code>bound</code> set to 5:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11</code></pre>
<p>. We can visualze the above like this instead:</p>
<pre><code>R R R R R | _ _ R R R | R R</code></pre>
<p>. The underscores represent the values that must be <em>skipped</em> over, in order to eliminate modulo bias. The question then, is to figure out how to count the number of underscores. In our case, it is 2, and so as long as we skip the first two values 0 and 1, we should be fine.</p>
<p>The first step is to count backwards from the right-hand edge:</p>
<pre><code>                |&lt;---count|
R R R R R | _ _ R R R | R R
                t         |
                          \-&gt; RAND_MAX</code></pre>
<p>. We end up where <code>t</code> is on the diagram above, by counting backwards from <code>RAND_MAX</code>. If we then take the modulo of this by <code>count</code> itself, then we end up with <code>t</code> being the value we want — the number of underscores. This is the essence of <code>-bound % bound</code> — we first take <code>-bound</code> which is obtained by counting backwards from <code>RAND_MAX</code>, and then we take the modulo of this number by <code>bound</code> itself, to get what we need. Using the ASCII diagram again, we get</p>
<pre><code>                |&lt;-----count|
0 1 2 3 4 | 5 6 7 8 9 | 10 11
                t          |
                           \-&gt; RAND_MAX
</code></pre>
<p>where <code>t</code> is 7, and now applying % 5, we get:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1
                t</code></pre>
<p><code>t = 2</code>, the correct answer! You can try out different values for <code>RAND_MAX</code> and <code>bound</code>, but you will get the right answer each time using <code>threshold = -bound % bound</code>.</p>
<h5 id="but-why-is--bound-the-way-it-is">But why is <code>-bound</code> the way it is?</h5>
<p>The <a href="http://stackoverflow.com/questions/2711522/what-happens-if-i-assign-a-negative-value-to-an-unsigned-variable">C standard</a> says that a negative unsigned value is stored as a positive value. Without getting too technical, here are the values of <code>bound</code> as it becomes “negative”:</p>
<pre><code>Bound | Actual value
------+-------------
2     | 2
1     | 1
0     | 0
-1    | (2^32) - 1 (same as RAND_MAX)
-2    | (2^32) - 2 (same as RAND_MAX - 1)
-3    | (2^32) - 3 (same as RAND_MAX - 2)
... and so on</code></pre>
<p>. In our case, if our <code>RAND_MAX</code> is 11, and <code>bound</code> is 5, then <code>-bound</code> is indeed 7.</p>
<pre><code>Bound | Actual value
------+-------------
0     | 0
-1    | 11 - 0 (same as RAND_MAX)
-2    | 11 - 1 (same as RAND_MAX - 1)
-3    | 11 - 2 (same as RAND_MAX - 2)
-4    | 11 - 3 (same as RAND_MAX - 3)
-5    | 11 - 4 (same as RAND_MAX - 4) = 7
... and so on</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>I thoroughly enjoyed looking at the source code in PCG, only to discover an elegant solution around removing modulo bias. Unfortunately, I do not know the true origin of this approach; it is possible that the authors of the PCG code invented it, but I find this improbable. Meanwhile, I strongly recommend the following code for anyone using a low-level generator that does not come with a bounded version:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/rng/pcg-style.c"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Uniformly return an integer from 0 to (bound - 1). We assume that rand()</span>
<span class="co"> * returns a 32-bit unsigned integer, so we use uint32_t.</span>
<span class="co"> */</span>
<span class="dt">uint32_t</span> bound = some_arbitrary_bound;
<span class="dt">uint32_t</span> r;
<span class="dt">uint32_t</span> threshold = -bound % bound;
<span class="kw">while</span> (r = rand() &lt; threshold) {};
<span class="kw">return</span> r % bound;</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/rng/pcg-style.c"  mimetype=text/plain > pcg-style.c </a>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Any RNG worth their salt will return a uniformly distributed value, typically from 0 to <code>RAND_MAX</code>. In the example here, our <code>RAND_MAX</code> is 11.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>For a 32-bit unsigned integer RNG, <span class="math inline">\(2^{32} - 1\)</span> (all 1 bits set) is the highest value that can be returned. That is, our RNG returns a value from 0 (no bits set) to <code>RAND_MAX</code> (all bits set). This means that our RNG generates everything from all 0s to all 1s and everything in between.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>

</feed>
