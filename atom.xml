<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Linus's Blog</title>
    <link href="http://listx.github.io/atom.xml" rel="self" />
    <link href="http://listx.github.io" />
    <id>http://listx.github.io/atom.xml</id>
    <author>
        <name>Linus Arver</name>
        <email></email>
    </author>
    <updated>2015-04-22T00:00:00Z</updated>
    <entry>
    <title>Programming Puzzles: Letter and Word Frequency</title>
    <link href="http://listx.github.io/post/2015-04-22-letter-word-frequency.html" />
    <id>http://listx.github.io/post/2015-04-22-letter-word-frequency.html</id>
    <published>2015-04-22T00:00:00Z</published>
    <updated>2015-04-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-04-22</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-04-22-letter-word-frequency.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/ruby.html">ruby</a>
</div>

<p>I recently purchased an ErgoDox keyboard<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, and I’ve been thinking about creating my own keyboard layout in the spirit of the Dvorak Simplified Keyboard layout (DSK). One of the guiding principles of DSK was putting an emphasis on reducing finger travel by identifying the most commonly occurring letters of the English language, and placing them on the home row of the keyboard. Now, the Dvorak layout was patented in 1936 according to Wikipedia, with subsequent adjustments culminating in the present form of DSK.</p>
<h2 id="motivation">Motivation</h2>
<p>I want to find out for myself what letters are the most common. Sure, I could blindly trust an online source like Wikipedia, but it just feels like an easy problem to solve. Also, I am not sure if Dvorak considered <em>word</em> frequency as well as <em>letter</em> frequency. Ideally, one should use the data of both word and letter frequency to determine what is the most commonly typed “letter” on a US ASCII keyboard for English writers.</p>
<h2 id="the-problems">The Problems</h2>
<h3 id="letter-frequency">Letter Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each letter occurs in the file. You must treat <code>A</code> as the same letter as <code>a</code>. You may limit yourself to the plain US ASCII 26-letter alphabet, discarding all letters with diacritics. Sort the letters by their frequence; for each letter, display the letter itself, its relative frequency percentage to the file as a whole, and the number of times this letter appears (raw count). E.g., the letter <code>a</code> counted by this program might look like this: <code>a = 2.00% (200 occurrences)</code>.</p>
<h3 id="word-frequency">Word Frequency</h3>
<p>Write a program that reads a file (plaintext) and counts how many times each <em>word</em> occurs in the file. The precise definition of a “word” is up to you, but you must exclude arabic numerals and also standalone punctuation characters (e.g., “* is not a word”). Display the 100 most common words in similar fashion to the Letter Frequency problem.</p>
<p>Both the letter and word frequency problems will use the Project Gutenberg plaintext file of <a href="http://www.gutenberg.org/cache/epub/2701/pg2701.txt"><em>Moby Dick</em></a>.</p>
<p>Now, before you go on to read my solutions, I encourage you to write a solution on your own using your favorite programming language.</p>
<h2 id="ruby-version">Ruby Version</h2>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/text_freq.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">TextFreq</span>
  <span class="co"># Given a string, count every occurrence of letters a-z (case insensitively).</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_l(src)
    <span class="co"># Construct the array to hold the running totals (occurrences) of each</span>
    <span class="co"># letter. There are 26 letters in the alphabet, so we can just have an array</span>
    <span class="co"># of 26 integers.</span>
    occs = <span class="dt">Array</span>.new(<span class="dv">26</span>, <span class="dv">0</span>)

    <span class="co"># Count occurrences of each letter.</span>
    src.each_char <span class="kw">do</span> |c|
      <span class="kw">if</span> !char_to_idx(c.downcase).nil?
        occs[char_to_idx(c.downcase)] += <span class="dv">1</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    occs
  <span class="kw">end</span>

  <span class="co"># Simply check if the given character belongs to the range of lowercase ASCII</span>
  <span class="co"># characters that make up the alphabet. &quot;a&quot; is 97, and &quot;z&quot; is 122; the numbers</span>
  <span class="co"># for bounds-checking &quot;c&quot; come from these two (offset by 1 to account for the</span>
  <span class="co"># exclusive comparison).</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.char_to_idx(c)
    <span class="dv">96</span> &lt; c.ord &amp;&amp; c.ord &lt; <span class="dv">123</span> ? c.ord - <span class="dv">97</span> : <span class="dv">nil</span>
  <span class="kw">end</span>

  <span class="co"># Given a string, count every occurrence of a particular word. We define a</span>
  <span class="co"># &quot;word&quot; as a sequence of charactes that</span>
  <span class="co">#   - does not have any punctuation characters at the beginning or end, and</span>
  <span class="co">#   - does not have any numbers in it</span>
  <span class="co"># . We take into account that text files from Project Gutenberg use a double</span>
  <span class="co"># dash for an em dash to separate two words.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.freq_w(src)
    occs = {}
    words = src.split(<span class="ot">/\W*\s\W*/</span>).map <span class="kw">do</span> |w|
        w.empty? ? <span class="dv">nil</span> : w.downcase
      <span class="kw">end</span>.compact
    words.each <span class="kw">do</span> |w|
      <span class="co"># Guard against cases like &quot;*&quot; for bullet points and such.</span>
      <span class="kw">if</span> w =~ <span class="ot">/\w/</span>
        <span class="kw">if</span> w =~ <span class="ot">/--/</span>
          w.split(<span class="st">&quot;--&quot;</span>).each <span class="kw">do</span> |y|
            count_word(occs, lstrip_punc(y))
          <span class="kw">end</span>
        <span class="kw">else</span>
          count_word(occs, lstrip_punc(w))
        <span class="kw">end</span>
      <span class="kw">end</span>
    <span class="kw">end</span>

    occs
  <span class="kw">end</span>

  <span class="co"># Add 1 to the hash for an existing key (word); otherwise, store a new</span>
  <span class="co"># instance of that word.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.count_word(hash, w)
    hash.key?(w) ? hash[w] += <span class="dv">1</span> : hash.store(w, <span class="dv">1</span>)
    hash
  <span class="kw">end</span>

  <span class="co"># Remove leading punctuation.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.lstrip_punc(w)
    w.match(<span class="ot">/\w.*/</span>)[<span class="dv">0</span>]
  <span class="kw">end</span>

  <span class="co"># Display the frequencies of letters and or words. For letters, we are only</span>
  <span class="co"># concerned about 26 different values, so we print all of them out. However</span>
  <span class="co"># for words, depending on the corpus there might be thousands, or even</span>
  <span class="co"># millions, of different words; thus, we only display the top 100 most common</span>
  <span class="co"># words.</span>
  <span class="kw">def</span> <span class="dt">TextFreq</span>.disp_freq(occs)
    <span class="kw">if</span> occs.is_a?(<span class="dt">Array</span>)
      sum = occs.inject(<span class="dv">0</span>, :+)
      occs.zip((<span class="st">&quot;a&quot;</span>..<span class="st">&quot;z&quot;</span>).to_a).sort.reverse.each <span class="kw">do</span> |cnt, c|
        puts <span class="st">&quot;</span><span class="ot">#{</span>c<span class="ot">}</span><span class="st"> = &quot;</span>\
          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\
          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span>
      <span class="kw">end</span>
    <span class="kw">else</span>
      sum = occs.values.inject(<span class="dv">0</span>, :+)
      occs.sort_by {|w, cnt| cnt}.reverse.take(<span class="dv">100</span>).each <span class="kw">do</span> |w, cnt|
        puts <span class="st">&quot;</span><span class="ot">#{</span>w<span class="ot">}</span><span class="st"> = &quot;</span>\
          + <span class="st">&quot;%.2f%%&quot;</span> % (cnt/sum.to_f * <span class="fl">100.0</span>)\
          + <span class="st">&quot; (</span><span class="ot">#{</span>cnt<span class="ot">}</span><span class="st"> occurrences)&quot;</span>
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/text_freq.rb"  mimetype=text/plain > text_freq.rb </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/analyze.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">#!/usr/bin/env ruby</span>

require_relative <span class="st">&#39;./text_freq&#39;</span>

fname = <span class="dt">ARGV</span>[<span class="dv">0</span>]
file = <span class="dt">File</span>.open(fname, <span class="st">&#39;r:utf-8&#39;</span>)
corpus = file.read

occs_l = <span class="dt">TextFreq</span>.freq_l(corpus)
<span class="dt">TextFreq</span>.disp_freq(occs_l)

puts <span class="st">&quot;-&quot;</span> * <span class="dv">80</span>

occs_w = <span class="dt">TextFreq</span>.freq_w(corpus)
<span class="dt">TextFreq</span>.disp_freq(occs_w)

file.close</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/analyze.rb"  mimetype=text/plain > analyze.rb </a>
</div>
</div>
<p>And here is the output (<code>pg2701.txt</code> is <em>Moby Dick</em>):</p>
<pre><code>$ ./analyze.rb ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.74% (14616 occurrences)
of = 3.10% (6708 occurrences)
and = 2.99% (6488 occurrences)
a = 2.20% (4760 occurrences)
to = 2.16% (4677 occurrences)
in = 1.95% (4223 occurrences)
that = 1.38% (2999 occurrences)
his = 1.17% (2530 occurrences)
it = 1.12% (2419 occurrences)
i = 0.92% (1988 occurrences)
but = 0.84% (1823 occurrences)
he = 0.82% (1777 occurrences)
with = 0.82% (1770 occurrences)
as = 0.81% (1751 occurrences)
is = 0.81% (1747 occurrences)
for = 0.76% (1645 occurrences)
was = 0.76% (1645 occurrences)
all = 0.70% (1523 occurrences)
this = 0.66% (1440 occurrences)
at = 0.62% (1334 occurrences)
by = 0.56% (1223 occurrences)
not = 0.54% (1169 occurrences)
from = 0.51% (1105 occurrences)
on = 0.49% (1069 occurrences)
him = 0.49% (1062 occurrences)
so = 0.49% (1061 occurrences)
be = 0.49% (1060 occurrences)
whale = 0.45% (972 occurrences)
you = 0.44% (944 occurrences)
one = 0.42% (906 occurrences)
or = 0.37% (797 occurrences)
there = 0.37% (792 occurrences)
now = 0.36% (779 occurrences)
had = 0.36% (779 occurrences)
have = 0.36% (772 occurrences)
were = 0.32% (683 occurrences)
they = 0.31% (664 occurrences)
which = 0.30% (655 occurrences)
then = 0.29% (628 occurrences)
me = 0.29% (621 occurrences)
their = 0.29% (620 occurrences)
are = 0.29% (619 occurrences)
some = 0.29% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.28% (600 occurrences)
no = 0.27% (594 occurrences)
my = 0.27% (589 occurrences)
like = 0.27% (581 occurrences)
upon = 0.26% (567 occurrences)
what = 0.26% (566 occurrences)
out = 0.24% (528 occurrences)
into = 0.24% (523 occurrences)
up = 0.24% (516 occurrences)
more = 0.23% (506 occurrences)
if = 0.23% (500 occurrences)
them = 0.22% (471 occurrences)
we = 0.21% (455 occurrences)
man = 0.21% (445 occurrences)
old = 0.20% (444 occurrences)
ahab = 0.20% (432 occurrences)
ye = 0.20% (428 occurrences)
would = 0.20% (428 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
these = 0.19% (405 occurrences)
over = 0.19% (403 occurrences)
will = 0.18% (396 occurrences)
ship = 0.18% (391 occurrences)
though = 0.18% (383 occurrences)
sea = 0.18% (382 occurrences)
its = 0.18% (382 occurrences)
only = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
down = 0.17% (367 occurrences)
any = 0.17% (363 occurrences)
who = 0.16% (345 occurrences)
yet = 0.16% (344 occurrences)
her = 0.15% (329 occurrences)
time = 0.15% (326 occurrences)
very = 0.15% (323 occurrences)
do = 0.15% (321 occurrences)
long = 0.15% (319 occurrences)
about = 0.15% (318 occurrences)
than = 0.14% (311 occurrences)
still = 0.14% (311 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (303 occurrences)
said = 0.14% (301 occurrences)
captain = 0.14% (300 occurrences)
before = 0.14% (300 occurrences)
here = 0.14% (299 occurrences)
has = 0.14% (294 occurrences)
must = 0.13% (292 occurrences)
two = 0.13% (288 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
last = 0.13% (276 occurrences)
head = 0.13% (275 occurrences)
see = 0.12% (268 occurrences)
thou = 0.12% (267 occurrences)</code></pre>
<p>. The file of course contains remarks and legalese from Project Gutenberg, so if you want more accuracy you would have to redact those parts before running this script.</p>
<h3 id="letter-frequency-1">Letter Frequency</h3>
<p>The <code>freq_l</code> method views letters in the limited US ASCII range and uses crude, C-like letter-to-integer equivalence via <code>char_to_idx</code>. We use a simple array of 26 integers, each one corresponding to a letter. But thanks to its stupidity, <code>freq_l</code> runs quite fast — chugging through Moby Dick in a few seconds on my Core i7-4770K 4GHz machine.</p>
<h3 id="word-frequency-1">Word Frequency</h3>
<p>The <code>freq_w</code> method relies almost entirely on a single regex, <code>/\W*\s\W*/</code>, to split the input into words. These words are further processed; we perform a basic sanity check with the <code>/\w/</code> regex to make sure we are not dealing with just numbers or punctuation, and we also take into account the em dash <code>--</code>. We use a basic hash structure to store the words as keys, and their counts as values.</p>
<h2 id="haskell-version">Haskell Version</h2>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/TextFreq.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">TextFreq</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>
<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Data.Ord</span> (comparing)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import qualified</span> <span class="dt">Text.Printf</span> <span class="kw">as</span> <span class="dt">TP</span>

<span class="kw">type</span> <span class="dt">LHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Char</span> <span class="dt">Word64</span>

<span class="kw">type</span> <span class="dt">WProto</span> <span class="fu">=</span> <span class="dt">T.Text</span>
<span class="kw">type</span> <span class="dt">WHash</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">WProto</span> <span class="dt">Word64</span>
<span class="kw">data</span> <span class="dt">WFSM</span>
	<span class="fu">=</span> <span class="dt">WordIn</span>
	<span class="fu">|</span> <span class="dt">WordOutMaybe</span>
	<span class="fu">|</span> <span class="dt">WordOut</span>
	<span class="kw">deriving</span> (<span class="dt">Eq</span>)
<span class="kw">data</span> <span class="dt">WBuild</span> <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WFSM</span> <span class="dt">WProto</span> <span class="dt">WHash</span>

<span class="ot">freqL ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">LHash</span>
freqL <span class="fu">=</span> T.foldl step occs
	<span class="kw">where</span>
	occs <span class="fu">=</span> M.empty
	step lhash c
		<span class="fu">|</span> isAlpha c <span class="fu">=</span> M.insertWith (<span class="fu">+</span>) (toLower c) <span class="dv">1</span> lhash
		<span class="fu">|</span> otherwise <span class="fu">=</span> lhash

<span class="ot">freqW ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">WHash</span>
freqW <span class="fu">=</span> (\(<span class="dt">WBuild</span> _ _ whash) <span class="ot">-&gt;</span> whash) <span class="fu">.</span> T.foldl step occs
	<span class="kw">where</span>
	<span class="co">-- Use WordOut as the initial state for WFSM, because we&#39;re starting from</span>
	<span class="co">-- nothing!</span>
<span class="ot">	occs ::</span> <span class="dt">WBuild</span>
	occs <span class="fu">=</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty M.empty
	step wb<span class="fu">@</span>(<span class="dt">WBuild</span> wfsm wproto whash) c
		<span class="co">-- Letter.</span>
		<span class="fu">|</span> isAlpha c <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- This is when we first encounter a letter.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.singleton c&#39;) whash
			_ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordIn</span> (T.snoc wproto c&#39;) whash
		<span class="co">-- Apostrophe. We ignore all leading apostrophes and only store</span>
		<span class="co">-- apostrophes at the end of a word, such as &quot;goin&#39;&quot;.</span>
		<span class="fu">|</span> c <span class="fu">==</span> <span class="ch">&#39;\&#39;&#39;</span> <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- This is when we encounter an apostrophe either at the middle or</span>
			<span class="co">-- end of a word.</span>
			<span class="dt">WordIn</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOutMaybe</span> (T.snoc wproto c&#39;) whash
			<span class="co">-- E.g., &quot;goin&#39;&#39;&quot; (a contracted &quot;goin&#39;&#39;&quot; ending with a nested inner</span>
			<span class="co">-- quote). We store it as &quot;goin&#39;&quot;.</span>
			<span class="dt">WordOutMaybe</span> <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty
				<span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash
			<span class="co">-- Already out of a word area, such as a space character. We do</span>
			<span class="co">-- nothing.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb
		<span class="co">-- If we&#39;re looking at neither a letter nor an apostrophe.</span>
		<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> wfsm <span class="kw">of</span>
			<span class="co">-- A series of nonsense chars; ignore.</span>
			<span class="dt">WordOut</span> <span class="ot">-&gt;</span> wb
			<span class="co">-- End of a word.</span>
			_ <span class="ot">-&gt;</span> <span class="dt">WBuild</span> <span class="dt">WordOut</span> T.empty
				<span class="fu">$</span> M.insertWith (<span class="fu">+</span>) wproto <span class="dv">1</span> whash
		<span class="kw">where</span>
		c&#39; <span class="fu">=</span> toLower c

<span class="ot">dispFreqL ::</span> <span class="dt">LHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dispFreqL lhash <span class="fu">=</span> mapM_ f <span class="fu">.</span> reverse <span class="fu">.</span> sortBy (comparing snd) <span class="fu">$</span> M.toList lhash
	<span class="kw">where</span>
<span class="ot">	total ::</span> <span class="dt">Word64</span>
	total <span class="fu">=</span> sum <span class="fu">$</span> M.elems lhash
<span class="ot">	f ::</span> (<span class="dt">Char</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
	f (c, n) <span class="fu">=</span> putStrLn <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3
		<span class="kw">where</span>
<span class="ot">		perc ::</span> <span class="dt">Double</span>
		perc
			<span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
			<span class="fu">|</span> otherwise <span class="fu">=</span> (fromIntegral n) <span class="fu">/</span> (fromIntegral total) <span class="fu">*</span> <span class="dv">100</span>
		msg1 <span class="fu">=</span> [c] <span class="fu">++</span> <span class="st">&quot; = &quot;</span>
		msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc
		msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span>

<span class="ot">dispFreqW ::</span> <span class="dt">WHash</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dispFreqW whash <span class="fu">=</span> mapM_ f <span class="fu">.</span> take <span class="dv">100</span> <span class="fu">.</span> reverse <span class="fu">.</span> sortBy (comparing snd) <span class="fu">$</span> M.toList whash
	<span class="kw">where</span>
<span class="ot">	total ::</span> <span class="dt">Word64</span>
	total <span class="fu">=</span> sum <span class="fu">$</span> M.elems whash
<span class="ot">	f ::</span> (<span class="dt">WProto</span>, <span class="dt">Word64</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
	f (w, n) <span class="fu">=</span> putStrLn <span class="fu">$</span> msg1 <span class="fu">++</span> msg2 <span class="fu">++</span> msg3
		<span class="kw">where</span>
<span class="ot">		perc ::</span> <span class="dt">Double</span>
		perc
			<span class="fu">|</span> total <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
			<span class="fu">|</span> otherwise <span class="fu">=</span> (fromIntegral n) <span class="fu">/</span> (fromIntegral total) <span class="fu">*</span> <span class="dv">100</span>
		msg1 <span class="fu">=</span> T.unpack w <span class="fu">++</span> <span class="st">&quot; = &quot;</span>
		msg2 <span class="fu">=</span> TP.printf <span class="st">&quot;%.2f%%&quot;</span> perc
		msg3 <span class="fu">=</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot; occurrences)&quot;</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/TextFreq.hs"  mimetype=text/plain > TextFreq.hs </a>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/text-freq/analyze.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">System.Environment</span>

<span class="kw">import </span><span class="dt">TextFreq</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
	args <span class="ot">&lt;-</span> getArgs
	src <span class="ot">&lt;-</span> T.readFile <span class="fu">$</span> args<span class="fu">!!</span><span class="dv">0</span>
	dispFreqL <span class="fu">$</span> freqL src
	putStrLn <span class="fu">$</span> replicate <span class="dv">80</span> <span class="ch">&#39;-&#39;</span>
	dispFreqW <span class="fu">$</span> freqW src</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/text-freq/analyze.hs"  mimetype=text/plain > analyze.hs </a>
</div>
</div>
<p>Here is the same run against our copy of <em>Moby Dick</em>:</p>
<pre><code>$ ./analyze ~/pg2701.txt
e = 12.29% (118967 occurrences)
t = 9.25% (89549 occurrences)
a = 8.16% (78959 occurrences)
o = 7.31% (70698 occurrences)
n = 6.89% (66670 occurrences)
i = 6.88% (66585 occurrences)
s = 6.72% (65012 occurrences)
h = 6.56% (63444 occurrences)
r = 5.51% (53342 occurrences)
l = 4.47% (43298 occurrences)
d = 4.01% (38769 occurrences)
u = 2.81% (27217 occurrences)
m = 2.44% (23655 occurrences)
c = 2.39% (23122 occurrences)
w = 2.33% (22500 occurrences)
g = 2.19% (21239 occurrences)
f = 2.19% (21228 occurrences)
p = 1.83% (17711 occurrences)
y = 1.78% (17209 occurrences)
b = 1.77% (17165 occurrences)
v = 0.90% (8721 occurrences)
k = 0.85% (8196 occurrences)
q = 0.16% (1567 occurrences)
j = 0.12% (1176 occurrences)
x = 0.11% (1062 occurrences)
z = 0.07% (636 occurrences)
--------------------------------------------------------------------------------
the = 6.67% (14620 occurrences)
of = 3.07% (6732 occurrences)
and = 2.97% (6502 occurrences)
a = 2.18% (4788 occurrences)
to = 2.15% (4706 occurrences)
in = 1.93% (4231 occurrences)
that = 1.37% (3005 occurrences)
his = 1.15% (2530 occurrences)
it = 1.11% (2434 occurrences)
i = 0.91% (1993 occurrences)
but = 0.83% (1823 occurrences)
he = 0.81% (1780 occurrences)
with = 0.81% (1770 occurrences)
as = 0.80% (1752 occurrences)
is = 0.80% (1748 occurrences)
was = 0.75% (1646 occurrences)
for = 0.75% (1646 occurrences)
all = 0.70% (1543 occurrences)
this = 0.66% (1443 occurrences)
at = 0.61% (1335 occurrences)
by = 0.56% (1226 occurrences)
not = 0.53% (1171 occurrences)
whale = 0.51% (1108 occurrences)
from = 0.50% (1105 occurrences)
on = 0.49% (1073 occurrences)
him = 0.49% (1067 occurrences)
so = 0.49% (1066 occurrences)
be = 0.49% (1064 occurrences)
you = 0.43% (946 occurrences)
one = 0.42% (914 occurrences)
there = 0.37% (805 occurrences)
or = 0.36% (797 occurrences)
now = 0.36% (783 occurrences)
had = 0.36% (779 occurrences)
have = 0.35% (773 occurrences)
were = 0.31% (683 occurrences)
they = 0.30% (664 occurrences)
which = 0.30% (655 occurrences)
like = 0.30% (647 occurrences)
me = 0.29% (632 occurrences)
then = 0.29% (630 occurrences)
their = 0.28% (620 occurrences)
some = 0.28% (619 occurrences)
are = 0.28% (619 occurrences)
when = 0.28% (607 occurrences)
an = 0.27% (600 occurrences)
no = 0.27% (596 occurrences)
my = 0.27% (589 occurrences)
upon = 0.26% (568 occurrences)
what = 0.26% (566 occurrences)
out = 0.25% (539 occurrences)
up = 0.24% (524 occurrences)
into = 0.24% (523 occurrences)
more = 0.23% (508 occurrences)
if = 0.23% (501 occurrences)
man = 0.22% (476 occurrences)
them = 0.22% (474 occurrences)
we = 0.21% (455 occurrences)
sea = 0.21% (454 occurrences)
old = 0.21% (452 occurrences)
ship = 0.20% (438 occurrences)
ahab = 0.20% (436 occurrences)
ye = 0.20% (431 occurrences)
would = 0.20% (430 occurrences)
other = 0.19% (416 occurrences)
been = 0.19% (415 occurrences)
over = 0.19% (409 occurrences)
these = 0.19% (406 occurrences)
will = 0.18% (398 occurrences)
though = 0.18% (384 occurrences)
its = 0.17% (382 occurrences)
only = 0.17% (378 occurrences)
down = 0.17% (378 occurrences)
such = 0.17% (376 occurrences)
any = 0.17% (364 occurrences)
who = 0.16% (347 occurrences)
yet = 0.16% (345 occurrences)
head = 0.16% (344 occurrences)
time = 0.15% (334 occurrences)
long = 0.15% (334 occurrences)
her = 0.15% (332 occurrences)
do = 0.15% (324 occurrences)
very = 0.15% (323 occurrences)
about = 0.15% (318 occurrences)
still = 0.14% (312 occurrences)
than = 0.14% (311 occurrences)
captain = 0.14% (308 occurrences)
those = 0.14% (307 occurrences)
great = 0.14% (306 occurrences)
said = 0.14% (305 occurrences)
here = 0.14% (302 occurrences)
before = 0.14% (301 occurrences)
two = 0.14% (298 occurrences)
boat = 0.14% (297 occurrences)
has = 0.13% (294 occurrences)
must = 0.13% (293 occurrences)
most = 0.13% (284 occurrences)
seemed = 0.13% (283 occurrences)
white = 0.13% (281 occurrences)
last = 0.13% (278 occurrences)</code></pre>
<p>.</p>
<h3 id="letter-frequency-2">Letter Frequency</h3>
<p><code>freqL</code> handles letter frequency, and it is a simple <code>foldl</code> operation over the input, while using the <code>Map</code> data structure from the <code>Data.Map</code> library (which acts as a simple hash structure with keys and values). The de facto Haskell compiler GHC comes with the <code>base</code> library which includes the <code>Data.Char</code> module; unlike Ruby, we can simply ask whether a character is a letter with <code>isAlpha</code>, and then use <code>toLower</code> on it to convert it to lowercase. <code>freqL</code> owes its brevity to these standard library functions.</p>
<p>Thanks to these standard library functions, we can easily keep track of more than just the basic 26 alphabetical letters (although in the case of <em>Moby Dick</em>, there does not seem to be any such characters).</p>
<h3 id="word-frequency-2">Word Frequency</h3>
<p>This is probably a convoluted way to keep track of words. I could have used the excellent Parsec library, but I just felt like rolling my own solution. <code>freqW</code> works by looking at just one character at a time, just like <code>freqL</code>. It also keeps track of the evaluation of the previously-looked-at character, with the <code>wfsm</code> variable (for <em>Word Finite State Machine</em>, a fancy but still pertinent name). <code>wfsm</code> can either say that the last character made us go <em>in</em> a word (<code>WordIn</code>), <em>out</em> of a word for sure (<code>WordOut</code>), or possibly out of a word (<code>WordOutMaybe</code>). Depending on the status of <code>wfsm</code> and the current character, <code>freqW</code> makes various choices.</p>
<p>Now, this mechanism isn’t without its warts. But still, I consider it somewhat elegant in its description of all possible states.</p>
<h2 id="a-diff">A Diff</h2>
<p>For fun, let’s look at the diff of the outputs of the Ruby and Haskell versions. Interestingly, the letter frequency outputs were identical. The word frequency outputs did have some significant changes, such as the word <em>whale</em> occurring 972 and 1108 times in the Ruby and Haskell versions, respectively. I’ve sorted the output by lines for saner diffing.</p>
<pre><code>$ diff -u routW houtW
--- routW	2015-04-22 22:01:59.061404962 -0700
+++ houtW	2015-04-22 22:02:57.679828155 -0700
@@ -1,100 +1,100 @@
-a = 2.20% (4760 occurrences)
+a = 2.18% (4788 occurrences)
 about = 0.15% (318 occurrences)
-ahab = 0.20% (432 occurrences)
-all = 0.70% (1523 occurrences)
-an = 0.28% (600 occurrences)
-and = 2.99% (6488 occurrences)
-any = 0.17% (363 occurrences)
-are = 0.29% (619 occurrences)
-as = 0.81% (1751 occurrences)
-at = 0.62% (1334 occurrences)
-be = 0.49% (1060 occurrences)
+ahab = 0.20% (436 occurrences)
+all = 0.70% (1543 occurrences)
+an = 0.27% (600 occurrences)
+and = 2.97% (6502 occurrences)
+any = 0.17% (364 occurrences)
+are = 0.28% (619 occurrences)
+as = 0.80% (1752 occurrences)
+at = 0.61% (1335 occurrences)
+be = 0.49% (1064 occurrences)
 been = 0.19% (415 occurrences)
-before = 0.14% (300 occurrences)
-but = 0.84% (1823 occurrences)
-by = 0.56% (1223 occurrences)
-captain = 0.14% (300 occurrences)
-do = 0.15% (321 occurrences)
-down = 0.17% (367 occurrences)
-for = 0.76% (1645 occurrences)
-from = 0.51% (1105 occurrences)
-great = 0.14% (303 occurrences)
+before = 0.14% (301 occurrences)
+boat = 0.14% (297 occurrences)
+but = 0.83% (1823 occurrences)
+by = 0.56% (1226 occurrences)
+captain = 0.14% (308 occurrences)
+do = 0.15% (324 occurrences)
+down = 0.17% (378 occurrences)
+for = 0.75% (1646 occurrences)
+from = 0.50% (1105 occurrences)
+great = 0.14% (306 occurrences)
 had = 0.36% (779 occurrences)
-has = 0.14% (294 occurrences)
-have = 0.36% (772 occurrences)
-he = 0.82% (1777 occurrences)
-head = 0.13% (275 occurrences)
-her = 0.15% (329 occurrences)
-here = 0.14% (299 occurrences)
-him = 0.49% (1062 occurrences)
-his = 1.17% (2530 occurrences)
-i = 0.92% (1988 occurrences)
-if = 0.23% (500 occurrences)
-in = 1.95% (4223 occurrences)
+has = 0.13% (294 occurrences)
+have = 0.35% (773 occurrences)
+he = 0.81% (1780 occurrences)
+head = 0.16% (344 occurrences)
+her = 0.15% (332 occurrences)
+here = 0.14% (302 occurrences)
+him = 0.49% (1067 occurrences)
+his = 1.15% (2530 occurrences)
+i = 0.91% (1993 occurrences)
+if = 0.23% (501 occurrences)
+in = 1.93% (4231 occurrences)
 into = 0.24% (523 occurrences)
-is = 0.81% (1747 occurrences)
-it = 1.12% (2419 occurrences)
-its = 0.18% (382 occurrences)
-last = 0.13% (276 occurrences)
-like = 0.27% (581 occurrences)
-long = 0.15% (319 occurrences)
-man = 0.21% (445 occurrences)
-me = 0.29% (621 occurrences)
-more = 0.23% (506 occurrences)
+is = 0.80% (1748 occurrences)
+it = 1.11% (2434 occurrences)
+its = 0.17% (382 occurrences)
+last = 0.13% (278 occurrences)
+like = 0.30% (647 occurrences)
+long = 0.15% (334 occurrences)
+man = 0.22% (476 occurrences)
+me = 0.29% (632 occurrences)
+more = 0.23% (508 occurrences)
 most = 0.13% (284 occurrences)
-must = 0.13% (292 occurrences)
+must = 0.13% (293 occurrences)
 my = 0.27% (589 occurrences)
-no = 0.27% (594 occurrences)
-not = 0.54% (1169 occurrences)
-now = 0.36% (779 occurrences)
-of = 3.10% (6708 occurrences)
-old = 0.20% (444 occurrences)
-on = 0.49% (1069 occurrences)
-one = 0.42% (906 occurrences)
+no = 0.27% (596 occurrences)
+not = 0.53% (1171 occurrences)
+now = 0.36% (783 occurrences)
+of = 3.07% (6732 occurrences)
+old = 0.21% (452 occurrences)
+on = 0.49% (1073 occurrences)
+one = 0.42% (914 occurrences)
 only = 0.17% (378 occurrences)
-or = 0.37% (797 occurrences)
+or = 0.36% (797 occurrences)
 other = 0.19% (416 occurrences)
-out = 0.24% (528 occurrences)
-over = 0.19% (403 occurrences)
-said = 0.14% (301 occurrences)
-sea = 0.18% (382 occurrences)
-see = 0.12% (268 occurrences)
+out = 0.25% (539 occurrences)
+over = 0.19% (409 occurrences)
+said = 0.14% (305 occurrences)
+sea = 0.21% (454 occurrences)
 seemed = 0.13% (283 occurrences)
-ship = 0.18% (391 occurrences)
-so = 0.49% (1061 occurrences)
-some = 0.29% (619 occurrences)
-still = 0.14% (311 occurrences)
+ship = 0.20% (438 occurrences)
+so = 0.49% (1066 occurrences)
+some = 0.28% (619 occurrences)
+still = 0.14% (312 occurrences)
 such = 0.17% (376 occurrences)
 than = 0.14% (311 occurrences)
-that = 1.38% (2999 occurrences)
-the = 6.74% (14616 occurrences)
-their = 0.29% (620 occurrences)
-them = 0.22% (471 occurrences)
-then = 0.29% (628 occurrences)
-there = 0.37% (792 occurrences)
-these = 0.19% (405 occurrences)
-they = 0.31% (664 occurrences)
-this = 0.66% (1440 occurrences)
+that = 1.37% (3005 occurrences)
+the = 6.67% (14620 occurrences)
+their = 0.28% (620 occurrences)
+them = 0.22% (474 occurrences)
+then = 0.29% (630 occurrences)
+there = 0.37% (805 occurrences)
+these = 0.19% (406 occurrences)
+they = 0.30% (664 occurrences)
+this = 0.66% (1443 occurrences)
 those = 0.14% (307 occurrences)
-thou = 0.12% (267 occurrences)
-though = 0.18% (383 occurrences)
-time = 0.15% (326 occurrences)
-to = 2.16% (4677 occurrences)
-two = 0.13% (288 occurrences)
-up = 0.24% (516 occurrences)
-upon = 0.26% (567 occurrences)
+though = 0.18% (384 occurrences)
+time = 0.15% (334 occurrences)
+to = 2.15% (4706 occurrences)
+two = 0.14% (298 occurrences)
+up = 0.24% (524 occurrences)
+upon = 0.26% (568 occurrences)
 very = 0.15% (323 occurrences)
-was = 0.76% (1645 occurrences)
+was = 0.75% (1646 occurrences)
 we = 0.21% (455 occurrences)
-were = 0.32% (683 occurrences)
-whale = 0.45% (972 occurrences)
+were = 0.31% (683 occurrences)
+whale = 0.51% (1108 occurrences)
 what = 0.26% (566 occurrences)
 when = 0.28% (607 occurrences)
 which = 0.30% (655 occurrences)
-who = 0.16% (345 occurrences)
-will = 0.18% (396 occurrences)
-with = 0.82% (1770 occurrences)
-would = 0.20% (428 occurrences)
-ye = 0.20% (428 occurrences)
-yet = 0.16% (344 occurrences)
-you = 0.44% (944 occurrences)
+white = 0.13% (281 occurrences)
+who = 0.16% (347 occurrences)
+will = 0.18% (398 occurrences)
+with = 0.81% (1770 occurrences)
+would = 0.20% (430 occurrences)
+ye = 0.20% (431 occurrences)
+yet = 0.16% (345 occurrences)
+you = 0.43% (946 occurrences)</code></pre>
<h2 id="french">French?</h2>
<p>Here is the Haskell version’s output on the first volume of <a href="http://www.gutenberg.org/cache/epub/17489/pg17489.txt"><em>Les Misérables</em></a> in the original French:</p>
<pre><code>e = 14.68% (77528 occurrences)
a = 8.12% (42892 occurrences)
i = 7.65% (40424 occurrences)
t = 7.62% (40270 occurrences)
s = 7.27% (38395 occurrences)
n = 6.76% (35704 occurrences)
r = 6.25% (32985 occurrences)
u = 6.16% (32553 occurrences)
l = 5.81% (30686 occurrences)
o = 5.17% (27315 occurrences)
d = 3.46% (18262 occurrences)
c = 3.06% (16150 occurrences)
m = 2.99% (15800 occurrences)
p = 2.61% (13784 occurrences)
v = 1.95% (10285 occurrences)
é = 1.87% (9852 occurrences)
q = 1.26% (6637 occurrences)
f = 1.18% (6245 occurrences)
h = 1.06% (5623 occurrences)
b = 0.99% (5244 occurrences)
g = 0.93% (4910 occurrences)
j = 0.56% (2973 occurrences)
à = 0.53% (2795 occurrences)
x = 0.40% (2102 occurrences)
y = 0.39% (2051 occurrences)
è = 0.32% (1702 occurrences)
ê = 0.30% (1584 occurrences)
z = 0.18% (964 occurrences)
â = 0.08% (410 occurrences)
ç = 0.07% (355 occurrences)
û = 0.06% (335 occurrences)
ô = 0.05% (290 occurrences)
ù = 0.05% (285 occurrences)
w = 0.05% (284 occurrences)
î = 0.05% (276 occurrences)
k = 0.03% (151 occurrences)
ï = 0.01% (47 occurrences)
ë = 0.00% (5 occurrences)
ü = 0.00% (2 occurrences)
ñ = 0.00% (2 occurrences)
--------------------------------------------------------------------------------
de = 3.89% (4472 occurrences)
la = 2.64% (3040 occurrences)
et = 2.57% (2949 occurrences)
il = 2.25% (2582 occurrences)
le = 2.22% (2548 occurrences)
à = 1.94% (2236 occurrences)
les = 1.34% (1538 occurrences)
un = 1.27% (1459 occurrences)
que = 1.17% (1350 occurrences)
qui = 1.11% (1278 occurrences)
dans = 0.99% (1134 occurrences)
une = 0.92% (1062 occurrences)
ce = 0.92% (1062 occurrences)
en = 0.90% (1036 occurrences)
des = 0.82% (948 occurrences)
pas = 0.76% (879 occurrences)
se = 0.75% (859 occurrences)
ne = 0.73% (843 occurrences)
était = 0.69% (792 occurrences)
vous = 0.68% (783 occurrences)
je = 0.67% (770 occurrences)
avait = 0.66% (760 occurrences)
lui = 0.63% (721 occurrences)
du = 0.62% (714 occurrences)
elle = 0.57% (660 occurrences)
sur = 0.56% (640 occurrences)
sa = 0.55% (635 occurrences)
pour = 0.54% (620 occurrences)
son = 0.53% (611 occurrences)
au = 0.50% (579 occurrences)
cette = 0.48% (556 occurrences)
on = 0.47% (537 occurrences)
est = 0.46% (533 occurrences)
qu&#39;il = 0.46% (528 occurrences)
a = 0.46% (524 occurrences)
tout = 0.45% (514 occurrences)
plus = 0.44% (508 occurrences)
comme = 0.44% (503 occurrences)
dit = 0.39% (446 occurrences)
avec = 0.38% (432 occurrences)
c&#39;est = 0.36% (416 occurrences)
y = 0.35% (404 occurrences)
par = 0.34% (392 occurrences)
mais = 0.30% (350 occurrences)
nous = 0.30% (340 occurrences)
ses = 0.28% (321 occurrences)
là = 0.27% (308 occurrences)
bien = 0.27% (305 occurrences)
deux = 0.26% (303 occurrences)
monsieur = 0.26% (296 occurrences)
même = 0.26% (295 occurrences)
cela = 0.26% (295 occurrences)
ces = 0.26% (294 occurrences)
si = 0.24% (273 occurrences)
où = 0.23% (269 occurrences)
m = 0.23% (266 occurrences)
me = 0.21% (238 occurrences)
l&#39;évêque = 0.21% (236 occurrences)
homme = 0.20% (234 occurrences)
sans = 0.20% (233 occurrences)
aux = 0.20% (232 occurrences)
fait = 0.20% (230 occurrences)
madeleine = 0.19% (214 occurrences)
qu&#39;on = 0.18% (210 occurrences)
jean = 0.18% (210 occurrences)
d&#39;un = 0.18% (208 occurrences)
c&#39;était = 0.17% (199 occurrences)
valjean = 0.17% (197 occurrences)
être = 0.17% (196 occurrences)
fantine = 0.17% (192 occurrences)
d&#39;une = 0.17% (190 occurrences)
javert = 0.15% (177 occurrences)
the = 0.15% (176 occurrences)
peu = 0.15% (173 occurrences)
cet = 0.15% (173 occurrences)
faire = 0.15% (172 occurrences)
puis = 0.15% (169 occurrences)
moi = 0.15% (168 occurrences)
j&#39;ai = 0.14% (164 occurrences)
chose = 0.14% (164 occurrences)
été = 0.14% (163 occurrences)
maire = 0.14% (162 occurrences)
dire = 0.14% (159 occurrences)
rien = 0.14% (158 occurrences)
quand = 0.14% (157 occurrences)
sont = 0.13% (153 occurrences)
quelque = 0.13% (153 occurrences)
tous = 0.13% (152 occurrences)
porte = 0.13% (150 occurrences)
ou = 0.13% (148 occurrences)
toute = 0.13% (147 occurrences)
chapitre = 0.13% (144 occurrences)
sous = 0.12% (142 occurrences)
peut = 0.12% (140 occurrences)
mon = 0.12% (138 occurrences)
moment = 0.12% (138 occurrences)
dieu = 0.12% (137 occurrences)
encore = 0.12% (134 occurrences)
l&#39;homme = 0.11% (130 occurrences)
eût = 0.11% (130 occurrences)</code></pre>
<p>. The most common French word in this book is <em>de</em>, meaning <em>of</em> in English. This is because the word for <em>the</em> is split into many different words, most notably <em>la</em> and <em>le</em>, not to mention <em>l’</em> as in <em>l’homme</em> (as you can see near the end of the list), due to the French language’s gender and vowel contraction rules (unlike English, contractions like <em>l’homme</em> in French are mandatory regardless of tone).</p>
<p>And, as a bit of trivia, it is interesting to note that <em>dieu</em> (God) edges out <em>’lhomme</em> (man) by 7 occurrences in this text.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope you’ve had some fun working on these letter and word frequency problems. The word frequency problem, if you really want to do it correctly, should be handled by a parser using a robust library. By writing these programs, I learned that the <em>input</em> of a program (Unicode? ASCII only?) is just as important as its output.</p>
<p>Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>After I receive it and assemble it, I will post a review about it.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Generating Random Numbers without Modulo Bias, Redux</title>
    <link href="http://listx.github.io/post/2015-02-27-removing-modulo-bias-redux.html" />
    <id>http://listx.github.io/post/2015-02-27-removing-modulo-bias-redux.html</id>
    <published>2015-02-27T00:00:00Z</published>
    <updated>2015-02-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-02-27</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-27-removing-modulo-bias-redux.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/rng.html">rng</a>, <a href="/tag/c.html">c</a>
</div>

<p>In an earlier post, I discussed <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">how to remove modulo bias from your C code</a>. I would like to add a different version of removing modulo bias, inspired by the code from the <a href="http://www.pcg-random.org/">PCG family</a> of random number generators.</p>
<h2 id="the-pcg-version">The PCG Version</h2>
<p>In the <a href="http://www.pcg-random.org/download.html">official minimal C implementation</a> of PCG, there is a function called <code>pcg32_boundedrand_r</code>, which takes a <code>bound</code> variable. The code for that function is as follows:</p>
<div class="sourceCode"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">uint32_t</span> pcg32_boundedrand_r(pcg32_random_t* rng, <span class="dt">uint32_t</span> bound)
{
	<span class="dt">uint32_t</span> threshold = -bound % bound;
	<span class="kw">for</span> (;;) {
		<span class="dt">uint32_t</span> r = pcg32_random_r(rng);
		<span class="kw">if</span> (r &gt;= threshold)
			<span class="kw">return</span> r % bound;
	}
}</code></pre></td></tr></table></div>
<p>. If <code>bound</code> is 5, then the function will return a uniform range from 0 to 4. I.e., the return value <code>r</code> is such that <span class="math">\(0 \leq r &lt; bound\)</span>.</p>
<h2 id="explanation-of-the-pcg-version">Explanation of the PCG Version</h2>
<p>Although I generally prefer to explain code in the order they appear, top to bottom, for this case I would like to explain the <code>pcg32_boundedrand_r()</code> function by talking about the usual broken version found in the wild.</p>
<h3 id="broken-version">Broken Version</h3>
<p>The broken version is like this:</p>
<pre><code>r = some_rng();
return r % bound;</code></pre>
<p>. Unless <code>r</code> is a multiple of <code>bound</code>, we will incur the wrath of modulo bias in the above code. Why is this? Well, consider what the modulo operator does. All it does is chop off any excess range of values that is not a multiple of <code>bound</code>. Consider the following ASCII diagram, where the maximum value returned by our <code>some_rng()</code> function is just 11:</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 10 11</code></pre>
<p>. So, <code>some_rng()</code> has 12 possible unique values, 0 through 11. If our bound was <code>4</code>, then doing <code>r % bound</code> is perfectly fine, because we can chop the RNG range into three equal parts of length 4 each, like this:</p>
<pre><code>0 1 2 3 | 4 5 6 7 | 8 9 10 11</code></pre>
<p>. If each of the 12 values 0 through 11 occurs uniformly<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, then we can assume that each of the values occurs <span class="math">\(\frac{1}{12}\)</span> times. If we apply <code>% 4</code> to the values, then our output range looks like this:</p>
<pre><code>0 1 2 3 | 0 1 2 3 | 0 1 2 3</code></pre>
<p>. Can you see how the three subparts are the same? What’s more, 0 will occur <span class="math">\(\frac{3}{12} = \frac{1}{4}\)</span> times. The same goes for <code>1</code>, <code>2</code>, and <code>3</code>. Because all 4 possible values, 0 through 4, occur an equal <span class="math">\(\frac{1}{4}\)</span> times, there is <em>no modulo bias here</em>!</p>
<h4 id="what-if-the-modulus-is-not-a-nice-number-with-respect-to-rand_max">What if the modulus is not a nice number with respect to <code>RAND_MAX</code>?</h4>
<p>This is where the problem occurs. <code>RAND_MAX</code> is the highest value returned by our RNG, and thus defines the range of the possible values output by the RNG.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> Continuing with our example above, if instead of <code>bound = 4</code>, we used another value like 5, we will get this instead:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11</code></pre>
<p>— or essentially, these values are output if we just naively use <code>r % bound</code>:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>. Can you see how <code>0</code> and <code>1</code> will occur <span class="math">\(\frac{3}{12}\)</span> times, but <code>2</code>, <code>3</code>, and <code>4</code> will occur only <span class="math">\(\frac{2}{12}\)</span> times?</p>
<h4 id="the-fix-adjust-the-range">The fix — adjust the range!</h4>
<p>Now, we can fix the above example by simply throwing out certain values. The approach I used in the <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">old blog post</a> was to discard the right hand side values. So, in our example with <code>bound = 5</code>, where we have</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>, the old example tried to discard the last 2 values, like this:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | x x</code></pre>
<p>. In other words, if <code>r</code> fell within the range 10 through 11, then we’d simply discard it and call <code>some_rand()</code> again.</p>
<p>But it doesn’t have to be this way. Instead of throwing out the values on the right, we can throw out the values on the left! So, instead of</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | x x</code></pre>
<p>we can instead do</p>
<pre><code>x x 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>. Can you see how all of the values 0 through 4 occur exactly 2 times? No more bias!</p>
<h3 id="pcgs-approach">PCG’s approach</h3>
<p>The approach in PCG is the same; here is the code again:</p>
<div class="sourceCode"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">uint32_t</span> pcg32_boundedrand_r(pcg32_random_t* rng, <span class="dt">uint32_t</span> bound)
{
	<span class="dt">uint32_t</span> threshold = -bound % bound;
	<span class="kw">for</span> (;;) {
		<span class="dt">uint32_t</span> r = pcg32_random_r(rng);
		<span class="kw">if</span> (r &gt;= threshold)
			<span class="kw">return</span> r % bound;
	}
}</code></pre></td></tr></table></div>
<p>. The <code>threshold</code> value is the initial range that must be discarded. So we can visualize it like this:</p>
<pre><code>x x 2 3 4 | 0 1 2 3 4 | 0 1

// The `x x` here is the initial threshold range, that must be discarded.</code></pre>
<p>On line 3, we determine the value of <code>threshold</code>, and then on line 4 we enter a <code>for</code> loop that repeatedly calls the RNG until we get a value outside of this threshold range (well, technically, <em>greater-than-or-equal-to</em> the threshold value). If we do get such a value, then we return the modulo of it. If we visualize it, it’s like this:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11

- Discard 0 and 1 (the threshold area).

x x 2 3 4 | 5 6 7 8 9 | 10 11

- Return (r % bound).

x x 2 3 4 | 0 1 2 3 4 | 0 1</code></pre>
<p>.</p>
<h4 id="how-is-threshold-calculated">How is <code>threshold</code> calculated?</h4>
<p>The above high-level explanation should be sufficient for you, dear reader. But if you want to go down to the innards of C, to see how <code>pcg32_boundedrand_r</code> works, read on.</p>
<p>The cornerstone of the PCG approach is to use a variable called <code>threshold</code>. The code to calculate <code>threshold</code> is somewhat complicated:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> threshold = -bound % bound;</code></pre></div>
<p>. Now, let’s remind ourselves that the whole point of <code>threshold</code> is to be a minimum value that sets a cutoff of values to be discarded — if the generated value <code>r</code> is too low (lower than our threshold), then we discard it.</p>
<p>Consider the following diagram, with <code>RAND_MAX</code> set to <code>11</code>, and <code>bound</code> set to 5:</p>
<pre><code>0 1 2 3 4 | 5 6 7 8 9 | 10 11</code></pre>
<p>. We can visualze the above like this instead:</p>
<pre><code>R R R R R | _ _ R R R | R R</code></pre>
<p>. The underscores represent the values that must be <em>skipped</em> over, in order to eliminate modulo bias. The question then, is to figure out how to count the number of underscores. In our case, it is 2, and so as long as we skip the first two values 0 and 1, we should be fine.</p>
<p>The first step is to count backwards from the right-hand edge:</p>
<pre><code>                |&lt;---count|
R R R R R | _ _ R R R | R R
                t         |
                          \-&gt; RAND_MAX</code></pre>
<p>. We end up where <code>t</code> is on the diagram above, by counting backwards from <code>RAND_MAX</code>. If we then take the modulo of this by <code>count</code> itself, then we end up with <code>t</code> being the value we want — the number of underscores. This is the essence of <code>-bound % bound</code> — we first take <code>-bound</code> which is obtained by counting backwards from <code>RAND_MAX</code>, and then we take the modulo of this number by <code>bound</code> itself, to get what we need. Using the ASCII diagram again, we get</p>
<pre><code>                |&lt;-----count|
0 1 2 3 4 | 5 6 7 8 9 | 10 11
                t          |
                           \-&gt; RAND_MAX
</code></pre>
<p>where <code>t</code> is 7, and now applying % 5, we get:</p>
<pre><code>0 1 2 3 4 | 0 1 2 3 4 | 0 1
                t</code></pre>
<p><code>t = 2</code>, the correct answer! You can try out different values for <code>RAND_MAX</code> and <code>bound</code>, but you will get the right answer each time using <code>threshold = -bound % bound</code>.</p>
<h5 id="but-why-is--bound-the-way-it-is">But why is <code>-bound</code> the way it is?</h5>
<p>The <a href="http://stackoverflow.com/questions/2711522/what-happens-if-i-assign-a-negative-value-to-an-unsigned-variable">C standard</a> says that a negative unsigned value is stored as a positive value. Without getting too technical, here are the values of <code>bound</code> as it becomes “negative”:</p>
<pre><code>Bound | Actual value
------+-------------
2     | 2
1     | 1
0     | 0
-1    | (2^32) - 1 (same as RAND_MAX)
-2    | (2^32) - 2 (same as RAND_MAX - 1)
-3    | (2^32) - 3 (same as RAND_MAX - 2)
... and so on</code></pre>
<p>. In our case, if our <code>RAND_MAX</code> is 11, and <code>bound</code> is 5, then <code>-bound</code> is indeed 7.</p>
<pre><code>Bound | Actual value
------+-------------
0     | 0
-1    | 11 - 0 (same as RAND_MAX)
-2    | 11 - 1 (same as RAND_MAX - 1)
-3    | 11 - 2 (same as RAND_MAX - 2)
-4    | 11 - 3 (same as RAND_MAX - 3)
-5    | 11 - 4 (same as RAND_MAX - 4) = 7
... and so on</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>I thoroughly enjoyed looking at the source code in PCG, only to discover an elegant solution around removing modulo bias. Unfortunately, I do not know the true origin of this approach; it is possible that the authors of the PCG code invented it, but I find this improbable. Meanwhile, I strongly recommend the following code for anyone using a low-level generator that does not come with a bounded version:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/rng/pcg-style.c"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Uniformly return an integer from 0 to (bound - 1). We assume that rand()</span>
<span class="co"> * returns a 32-bit unsigned integer, so we use uint32_t.</span>
<span class="co"> */</span>
<span class="dt">uint32_t</span> bound = some_arbitrary_bound;
<span class="dt">uint32_t</span> r;
<span class="dt">uint32_t</span> threshold = -bound % bound;
<span class="kw">while</span> (r = rand() &lt; threshold) {};
<span class="kw">return</span> r % bound;</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/rng/pcg-style.c"  mimetype=text/plain > pcg-style.c </a>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Any RNG worth their salt will return a uniformly distributed value, typically from 0 to <code>RAND_MAX</code>. In the example here, our <code>RAND_MAX</code> is 11.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>For a 32-bit unsigned integer RNG, <span class="math">\(2^{32} - 1\)</span> (all 1 bits set) is the highest value that can be returned. That is, our RNG returns a value from 0 (no bits set) to <code>RAND_MAX</code> (all bits set). This means that our RNG generates everything from all 0s to all 1s and everything in between.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Programming Puzzle: Game Button Sequence Recognizer</title>
    <link href="http://listx.github.io/post/2015-02-24-puzzle-game-button-recognizer.html" />
    <id>http://listx.github.io/post/2015-02-24-puzzle-game-button-recognizer.html</id>
    <published>2015-02-24T00:00:00Z</published>
    <updated>2015-02-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-02-24</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-24-puzzle-game-button-recognizer.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/ruby.html">ruby</a>
</div>

<p>So just yesterday, I did a live coding interview. Looking back, the problem I was presented with was very simple, but true to my usual nervous self, I over-analzyed the problem — completely missing the point and needlessly complicating things. In an effort to redeem myself, I thought about the problem again and even went out as to write tests for it, in both Ruby and Haskell. If you want to have a crack at the problem yourself, be conservative about scrolling down the page! Without further ado, I present the problem to you.</p>
<h2 id="the-problem">The Problem</h2>
<p>You are a game engine API writer. You need to implement a mechanism that allows your developers to store and retrieve game moves based on the input to the game engine. The two functions for this mechanism should be named <code>register()</code> and <code>on_button()</code>.</p>
<p><code>register()</code> should take a named button sequence, and store it into the database of all named sequences. A single named sequence might look like this: <code>([&quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;], &quot;hadoken&quot;)</code>.</p>
<p><code>on_button()</code> should take a single key, and then return all named sequences that match the ones in the database. E.g., <code>on_button(&quot;punch&quot;)</code> should return <code>&quot;hadoken&quot;</code> if the previous two inputs were <code>&quot;down&quot;</code> and <code>&quot;forward&quot;</code>.</p>
<h3 id="some-constraints">Some Constraints</h3>
<h4 id="multiple-sequences">Multiple Sequences</h4>
<p>Because our API is flexible, we allow <em>multiple</em> named sequences with the <em>same sequence</em>. Thus, you can expect something like this:</p>
<pre><code>register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut&quot;)
register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut_2&quot;)
on_button(&quot;up&quot;)        # no result
on_button(&quot;punch&quot;)     # [&quot;uppercut&quot;, &quot;uppercut_2&quot;]</code></pre>
<p>. You don’t have to worry about multiple named sequences with the same sequence and also the same name — we will worry about this “exact duplicate” situation in a later version of our API.</p>
<h4 id="input-history">Input History</h4>
<p>You might have noticed that <code>on_button()</code> depends on the input history of whatever buttons were <em>previously</em> entered into the game. Because of this, you can alternatively write an <code>on_buttons()</code> function (plural with an “s”) that takes the history of buttons as input; this way you don’t have to silently depend on the global state of input history.</p>
<h2 id="my-nervous-wreck-solution">My Nervous-Wreck Solution</h2>
<p>I decided to use pure Haskell code in the actual interview. The code I wrote had the general idea, but it was a big failure because it performed a naive, custom search without any thought given to data structures. I actually went back and revised the code to make it compile and work <em>after</em> the interview was over; here it is in all its glory:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/interview_ver.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="fu">=</span> [(<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>)]
<span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="fu">=</span> [<span class="dt">String</span>]
<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="co">-- Default DB of button sequences.</span>
<span class="ot">buttonSeqDB ::</span> <span class="dt">ButtonSeqDB</span>
buttonSeqDB <span class="fu">=</span>
	[ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;hadoken&quot;</span>)
	, ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;charger&quot;</span>)
	, ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut&quot;</span>)
	]

<span class="ot">register ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span>
register sequence name db
	<span class="fu">|</span> null sequence <span class="fu">=</span> db
	<span class="fu">|</span> alreadyExists <span class="fu">=</span> db
	<span class="fu">|</span> otherwise <span class="fu">=</span> (sequence, name) <span class="fu">:</span> db
	<span class="kw">where</span>
	alreadyExists <span class="fu">=</span> elem (sequence, name) db

<span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons buttonHist db <span class="fu">=</span> map snd
	<span class="fu">.</span> fst
	<span class="fu">.</span> foldl step ([], db)
	<span class="fu">$</span> reverse buttonHist
	<span class="kw">where</span>
	step acc<span class="fu">@</span>(foundSoFar, dbRem) button
		<span class="fu">|</span> null remaining <span class="fu">=</span> acc
		<span class="fu">|</span> otherwise <span class="fu">=</span>
			( foundSoFar <span class="fu">++</span> entriesComplete
			, dbRem&#39;
			)
		<span class="kw">where</span>
		remaining <span class="fu">=</span> filter ((<span class="fu">==</span>button) <span class="fu">.</span> last <span class="fu">.</span> fst)
			<span class="fu">$</span> filter (not <span class="fu">.</span> null <span class="fu">.</span> fst) dbRem
		dbRem&#39; <span class="fu">=</span> map (\(a, b) <span class="ot">-&gt;</span> (init a, b)) remaining
		entriesComplete <span class="fu">=</span> filter (null <span class="fu">.</span> fst) dbRem&#39;</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/interview_ver.hs"  mimetype=text/plain > interview_ver.hs </a>
</div>
</div>
<p>. I have to admit, the <code>step</code> function in <code>onButtons</code> is essentially unreadable. But it does work:</p>
<pre><code>$ ghci code/toy/game-button-seq/interview_ver.hs
GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( code/toy/game-button-seq/interview_ver.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; onButtons [&quot;down&quot;, &quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;] buttonSeqDB
[&quot;charger&quot;,&quot;hadoken&quot;]</code></pre>
<p>.</p>
<p>Anyway, I will explain the behavior of the code. The first thing to notice is that we feed into <code>step</code> the <em>reversed</em> list of <code>buttonHist</code>, so that we examine the button press history, from newest to oldest. So we look at the just-pressed-button, then the one before that, and the one before, etc, backwards up the history.</p>
<p>As we look at each <code>button</code>, we use it to filter out all known sequences. This filtering is done in <code>remaining</code>, where we check the last button of every known sequence, and see if that matches the current button. That’s what the line <code>filter ((==button) . last . fst)</code> does; the sister line <code>filter (not . null . fst) dbRem</code> is just there to prevent calling <code>last</code> on an empty list.</p>
<p>After we’re done checking, we modify the entire sequence database <code>db</code>, such that we only care about the first <span class="math">\(N - 1\)</span> buttons in the sequence. This way, on the next iteration, we can rest assured that checking against the “last” button in a sequence is not always the same button. In subsequent runs of <code>step</code>, we have <code>dbRem</code>‘s sequences slowly get reduced down to nothing as we keep chopping off all sequences’ last button. Keep in mind that we feed the filtered, matching entries of <code>db</code> back into subsequent runs of <code>step</code>, so that effectively we’re only working with matching sequences. Once we reach down to no buttons, we label these named sequences as <code>entriesComplete</code>, and append it into <code>foundSoFar</code>.</p>
<h3 id="analysis">Analysis</h3>
<p>Obviously, this code has many problems. First, it is virtually unreadable. Readability is important, and the code feels very counter-intuitive — it is marvelously complex when the problem statement sounds so simple.</p>
<p>Second, the fact that we have to bring in and mutate <code>dbRem</code>, which is a copy of the original given <code>ButtonSeqDB</code> type, seems wasteful. We’re wasting a lot of CPU cycles here.</p>
<h2 id="ruby-solution-using-hashes">Ruby Solution Using Hashes</h2>
<p>So on the day after (that is, <em>today</em> as of the time of this writing), I thought about the problem again and realized we can use hashes. It is a very simple approach, with far less lines of code. I even wrote some tests for it. Here is the implementation below.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/hash_ver.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">GameButtonSeq</span>
  <span class="co"># button_seq = [&quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;]</span>
  <span class="co"># name = &quot;hadoken&quot;</span>
  <span class="co"># button_seq_db = a hash of {sequence =&gt; name}, but a sequence can have</span>
  <span class="co"># multiple names if that sequence already exists.</span>
  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.register(button_seq, name, button_seq_db)
    <span class="co"># If the sequence already exists, simply add the new name to the old name,</span>
    <span class="co"># and store it as a list of names.</span>
    <span class="kw">if</span> button_seq_db.key?(button_seq)
      button_seq_db[button_seq] = [name] + button_seq_db[button_seq]
    <span class="kw">else</span>
      button_seq_db[button_seq] = [name]
    <span class="kw">end</span>

    button_seq_db
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.on_buttons(button_seq, button_seq_db)
    found = []
    <span class="co"># We search the entire button_seq_db hash for the full length of N buttons</span>
    <span class="co"># first, then N - 1 buttons, then N - 2 buttons, until the search input</span>
    <span class="co"># becomes 0. Meanwhile, we collect any and all matches that come our way.</span>
    <span class="co"># The point is to search based on the *last* input button, as this is the</span>
    <span class="co"># &quot;current&quot; button that should &quot;finish&quot; whatever combination/move we were</span>
    <span class="co"># trying to do.</span>
    <span class="kw">while</span> button_seq.size &gt; <span class="dv">0</span>
      <span class="kw">if</span> button_seq_db.key?(button_seq)
        found &lt;&lt; button_seq_db[button_seq]
      <span class="kw">end</span>
      <span class="co"># Discard oldest button press, and search again. Even if we have a match,</span>
      <span class="co"># it&#39;s important to search for other matches, too.</span>
      button_seq.shift
    <span class="kw">end</span>

    <span class="co"># Clean up, so that we get [&quot;foo&quot;, &quot;bar&quot;] instead of [[&quot;foo&quot;], [&quot;bar&quot;]].</span>
    found.flatten
  <span class="kw">end</span>

  <span class="kw">def</span> <span class="dt">GameButtonSeq</span>.add_hist(button_hist, button_name)
    button_hist + [button_name]
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/hash_ver.rb"  mimetype=text/plain > hash_ver.rb </a>
</div>
</div>
<p>And here is the test suite for it. You can run it with <code>ruby test_hash_ver.rb</code>.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/test_hash_ver.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby">require <span class="st">&#39;minitest/autorun&#39;</span>
require_relative <span class="st">&#39;./hash_ver.rb&#39;</span>

<span class="kw">class</span> <span class="dt">TestPuz</span> &lt; <span class="dt">Minitest</span>::<span class="dt">Test</span>

  <span class="kw">def</span> setup
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;hadoken&quot;</span>, {})
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;charger&quot;</span>, <span class="ot">@db</span>)
    <span class="ot">@db</span> = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut&quot;</span>, <span class="ot">@db</span>)

    <span class="co"># Aside: We can easily limit the size of button_hist[] by forcefully always</span>
    <span class="co"># saving only the last N key presses, with N determined by the longest</span>
    <span class="co"># button sequence.</span>
    <span class="ot">@button_hist</span> = []

    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;forward&quot;</span>)
    <span class="ot">@button_hist</span> = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;punch&quot;</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_multiple_names_entered
    db2 = <span class="dt">GameButtonSeq</span>.register([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut_2&quot;</span>, <span class="ot">@db</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(button_hist2, <span class="st">&quot;punch&quot;</span>)
    assert_equal [<span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, db2)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_no_sequence_found
    <span class="co"># Add an unrecognized button.</span>
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;back&quot;</span>)
    assert_equal [],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, <span class="ot">@db</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_one_sequence_found
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)
    button_hist2 = <span class="dt">GameButtonSeq</span>.add_hist(button_hist2, <span class="st">&quot;punch&quot;</span>)
    assert_equal [<span class="st">&quot;uppercut&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(button_hist2, <span class="ot">@db</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> test_button_seq_multiple_sequences_found
    assert_equal [<span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span>],
      <span class="dt">GameButtonSeq</span>.on_buttons(<span class="ot">@button_hist</span>, <span class="ot">@db</span>)
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/test_hash_ver.rb"  mimetype=text/plain > test_hash_ver.rb </a>
</div>
</div>
<h3 id="analysis-1">Analysis</h3>
<p>The key insight was when I realized that you could indeed use a hash even though we have the requirement that multiple, identical button sequences can have different names. The trick is to simply store the value as not a single name, but an array of possible names. This is reflected in the <code>GameButtonSeq.register</code> method.</p>
<p>The heart of <code>on_buttons()</code> is a single <code>while</code> loop that checks the given button history against the database; we reduce the button sequence by 1 button on each iteration to check against shorter matches as well. That’s what the <code>button_seq.shift</code> is for.</p>
<h2 id="haskell-solution-using-hashes">Haskell Solution Using Hashes</h2>
<p>Inspired by the Ruby solution, I rewrote a Haskell version — with tests to boot! Here is the implementation.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/GameButtonSeq.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">GameButtonSeq</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="co">-- The database stores a list of Name values, because multiple sequences can</span>
<span class="co">-- have the same name, in which case we store just one instance of the sequence,</span>
<span class="co">-- but a list of multiple Name values.</span>
<span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]
<span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="fu">=</span> [<span class="dt">String</span>]
<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="co">-- If a button sequence is already given some set of names, add the current</span>
<span class="co">-- given name into that list of names..</span>
<span class="ot">register ::</span> (<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>) <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span>
register (buttonSeq, name) db <span class="fu">=</span> <span class="kw">case</span> M.lookup buttonSeq db <span class="kw">of</span>
	<span class="dt">Just</span> names <span class="ot">-&gt;</span> M.insert buttonSeq (name<span class="fu">:</span>names) db
	<span class="dt">Nothing</span> <span class="ot">-&gt;</span> M.insert buttonSeq [name] db

<span class="co">-- Input `buttonSeq` is a list of buttons pressed, from oldest to newest, so</span>
<span class="co">-- that the head of the list contains the oldest button.</span>
<span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons buttonHist db <span class="fu">=</span> concatMap extractNames buttonHists
	<span class="kw">where</span>
	buttonHists <span class="fu">=</span> take (length buttonHist) <span class="fu">$</span> iterate tail buttonHist
	extractNames bHist <span class="fu">=</span> <span class="kw">case</span> M.lookup bHist db <span class="kw">of</span>
		<span class="dt">Just</span> names <span class="ot">-&gt;</span> names
		<span class="dt">Nothing</span> <span class="ot">-&gt;</span> []

<span class="ot">onButtons2 ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
onButtons2 buttonHist db <span class="fu">=</span> concat <span class="fu">$</span> mapMaybe (flip M.lookup db) buttonHists
	<span class="kw">where</span>
	buttonHists <span class="fu">=</span> take (length buttonHist) <span class="fu">$</span> iterate tail buttonHist</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/GameButtonSeq.hs"  mimetype=text/plain > GameButtonSeq.hs </a>
</div>
</div>
<p>The file is named <code>GameButtonSeq</code> because of Haskell naming conventions for files containing module code. And here is the test for it.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/game-button-seq/test_hash_ver.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span>

<span class="kw">import </span><span class="dt">GameButtonSeq</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain tests

<span class="ot">tests ::</span> <span class="dt">TestTree</span>
tests <span class="fu">=</span> testGroup <span class="st">&quot;Tests&quot;</span> [qcProps, unitTests]

<span class="ot">qcProps ::</span> <span class="dt">TestTree</span>
qcProps <span class="fu">=</span> testGroup <span class="st">&quot;(checked by QuickCheck)&quot;</span>
	[ QC.testProperty <span class="st">&quot;GameButtonSeq (empty DB cannot produce matches)&quot;</span> <span class="fu">$</span>
		\buttonHist <span class="ot">-&gt;</span> onButtons (<span class="ot">buttonHist ::</span> <span class="dt">ButtonSeq</span>) M.empty <span class="fu">==</span> []
	]

<span class="ot">unitTests ::</span> <span class="dt">TestTree</span>
unitTests <span class="fu">=</span> testGroup <span class="st">&quot;Unit tests&quot;</span>
	[ testCase <span class="st">&quot;GameButtonSeq (entry of multiple sequences with same name)&quot;</span> <span class="fu">$</span>
		(onButtons [<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]
		<span class="fu">$</span> register ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut_2&quot;</span>) buttonSeqDB)
			<span class="fu">@?=</span>
			[<span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span>]
	, testCase <span class="st">&quot;GameButtonSeq (no sequence found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>, <span class="st">&quot;down&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[]
	, testCase <span class="st">&quot;GameButtonSeq (one sequences found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[<span class="st">&quot;uppercut&quot;</span>]
	, testCase <span class="st">&quot;GameButtonSeq (multiple sequences found)&quot;</span> <span class="fu">$</span>
		onButtons
			[<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>]
			buttonSeqDB
			<span class="fu">@?=</span>
			[<span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span>]
	]
	<span class="kw">where</span>
	<span class="co">-- Default DB of button sequences.</span>
<span class="ot">	buttonSeqDB ::</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]
	buttonSeqDB <span class="fu">=</span> M.fromList
		[ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;hadoken&quot;</span>])
		, ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;charger&quot;</span>])
		, ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;uppercut&quot;</span>])
		]</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/game-button-seq/test_hash_ver.hs"  mimetype=text/plain > test_hash_ver.hs </a>
</div>
</div>
<h3 id="analysis-2">Analysis</h3>
<p>This Haskell version uses the standard <code>Data.Map</code> module, which provides an efficient, basic hash data structure. What we first do is expand <code>buttonHist</code> to all of the cases we are interested in — namely, all of the subsequences of concern. E.g., given a list like <code>[&quot;up&quot;, &quot;down&quot;, &quot;right&quot;, &quot;left&quot;]</code>, <code>buttonHists</code> becomes:</p>
<pre><code>[ [&quot;up&quot;, &quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,       [&quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,               [&quot;right&quot;, &quot;left&quot;]
,                        [&quot;left&quot;]
]</code></pre>
<p>(spaces added for readability). What we do is reduce the initial input list into all of the “sublist” combinations of <span class="math">\(N\)</span> buttons, <span class="math">\(N - 1\)</span> buttons, <span class="math">\(N - 2\)</span> buttons, etc.</p>
<p>The next step is to simply look at each sublist with <code>concatMap</code>, calling <code>extractNames</code>; we treat each sublist as a key, and look for it in our <code>db</code> hash. We then simply concatenate the results.</p>
<p>The <code>onButtons2</code> is an alternate version which uses <code>mapMaybe</code> to reduce it down to just two lines of code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I cringe as I look back at the half-baked code I wrote during the interview. Even the working, compilable version that I wrote after the interview remains ugly and hard to reason about. I can picture my interviewer being grossed out by my ugly, hacky version wondering if I even know what hashes are…</p>
<p>The moral of the story is to think carefully about the most obvious data structure to use, before embarking on writing a solution — no matter how trivial it seems. For myself, I was nervous and did not realize how simple the problem actually was until the day after when I rewrote the solution in Ruby. It was so simple and straightforward that I even wrote some test cases for it<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>I hope you had some fun writing out your own solutions. Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You can test the Haskell hash version in this blog post if you clone this blog’s repo and then build it with Cabal (I’ve listed the program as an executable with all the constraints in the <code>blog.cabal</code> file in the repo root folder). For the Ruby version, simply do <code>ruby path/to/test_hash_ver.rb</code> and Ruby will run the tests inside.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Using the Nix Package Manager for Haskell Development from Arch Linux</title>
    <link href="http://listx.github.io/post/2015-02-10-using-nix-from-arch.html" />
    <id>http://listx.github.io/post/2015-02-10-using-nix-from-arch.html</id>
    <published>2015-02-10T00:00:00Z</published>
    <updated>2015-02-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2015-02-10</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-10-using-nix-from-arch.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/haskell.html">haskell</a>, <a href="/tag/arch.html">arch</a>, <a href="/tag/linux.html">linux</a>, <a href="/tag/nix.html">nix</a>
</div>

<p>I recently installed and configured NixOS on a laptop and had to learn how to develop Haskell on it. The Nix community uses something called <code>cabal2nix</code> (version 2.0 and up!) and <code>nix-shell</code> to get the job done. While things work quite smoothly right now in NixOS, I was wondering if I could do the same on my desktop Arch Linux box.</p>
<p>The answer is yes — you can easily use Nix to create a ‘system sandbox’ of sorts (the Nix store) that is completely isolated from Arch’s own Haskell packages/GHC. To be clear, what we are trying to do is install the Nix package manager (which is composed of many satellite programs like <code>nix-env</code>, <code>nix-shell</code>, etc.) so that we can develop Haskell programs with all the advantages that come with it.</p>
<p>For myself, I have several different Haskell projects, and I wanted to avoid redownloading and recompiling the same packages for each project’s Cabal sandbox environment. Using Nix, I still have the same Cabal sandboxes (one for each project root), but Nix allows all the different sandboxes to share the same packages if the versions and dependencies are the same. And plus, because the Nix store (where Nix stores everything — <code>/nix/store</code>) is independent of Arch’s <code>pacman</code> tool, there is no fear of conflict or things breaking whenever you upgrade Arch Linux’s own Haskell packages.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h1 id="use-the-nix-manual-to-install-nix">Use the Nix Manual to install Nix</h1>
<p>The <a href="http://nixos.org/nix/manual/">Nix manual</a> has up-to-date documentation on how to get Nix. When we say <em>Nix</em>, we are talking about the collection of console programs (with a <code>nix-</code> prefix in their names) that make up to form the Nix package management system — much like how <em>Git</em> is made up of smaller programs that work as a team. There is a <code>nix</code> package on the AUR, but I suggest simply following this guide.</p>
<p>The first step is to run the install script from the NixOS site (which hosts Nix and other related programs) as a normal user:</p>
<pre><code>$ bash &lt;(curl https://nixos.org/nix/install)</code></pre>
<p>. You will now have a directory called <code>/nix</code> in your system. This is where everything related to Nix will be stored. In addition, the script will create some hidden files under your user’s home directory with the <code>.nix-</code> prefix. The most important file for now is <code>~/.nix-profile</code>, because it links to a shell script that initializes the Nix environment (to bring in <code>nix-*</code> utilities into the current shell’s scope). You will get a message from the shell script to source this file, like this:</p>
<pre><code>$ . /home/l/.nix-profile/etc/profile.d/nix.sh</code></pre>
<p>. For me, I put the whole thing into an alias for my shell called <code>nix</code>, like this:</p>
<pre><code># somewhere in my ~/.zshrc
alias nix=&#39;. /home/l/.nix-profile/etc/profile.d/nix.sh&#39;</code></pre>
<p>.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> So, whenever I want access to Nix utilities, I just type in <code>nix</code> and go on my merry way.</p>
<h1 id="install-cabal2nix-and-cabal">Install <code>cabal2nix</code> and <code>cabal</code></h1>
<p>Now, use your alias to enable Nix.</p>
<pre><code>$ nix</code></pre>
<p>You now have access to all the <code>nix-*</code> utilities that make up to provide the Nix package management system. You can list all Nix-packaged packages with <code>nix-env -qaP</code>. For us, we’re interested in the <code>cabal2nix</code> package. As of the time of this writing, it is called <code>nixpkgs.haskellPackages.cabal2nix</code>. However, the <code>haskellPackages</code> prefix refers to the old system that has been more or less deprecated as of <a href="http://article.gmane.org/gmane.linux.distributions.nixos/15513">January 2015</a>. We need to use the <code>haskellngPackages</code> (note the <code>ng</code>) prefix instead. I know that <code>nixpkgs.haskellngPackages.cabal2nix</code> isn’t listed with the <code>nix-env -qaP</code> command, but I believe that’s for legacy reasons. You can still install it! Let’s do that now:</p>
<pre><code>$ nix-env -iA nixpkgs.haskellngPackages.cabal2nix</code></pre>
<p>. This will give you the very useful <code>cabal2nix</code> binary which you can use to convert any <code>.cabal</code> file into something that Nix can understand! Let’s also install <code>cabal</code> for Nix:</p>
<pre><code>$ nix-env -iA nixpkgs.haskellngPackages.cabal-install</code></pre>
<p>. This will install <code>cabal</code> to <code>~/.nix-profile/bin/cabal</code>. This step is not really necessary if you have <code>cabal-install</code> already installed on the Arch Linux side with <code>pacman</code>. However, I still recommend it because</p>
<ol style="list-style-type: decimal">
<li>if you’re using Nix for Haskell development, there is no longer a need to use <code>cabal</code> outside of the Haskell/Nix development process;</li>
<li>it just makes sense to use the <code>cabal</code> package that comes from the same source tree as <code>cabal2nix</code> (i.e., from the same <code>haskellngPackages</code> set<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>); and</li>
<li>as of the time of this writing the <code>cabal-install</code> version from Nix packages set is newer than the Arch version.</li>
</ol>
<p>At the end of the day, your <code>cabal</code> binary should be writing to <code>~/.cabal</code> so take care to use one version and stick with it.</p>
<h1 id="nixify-your-project">Nixify your project</h1>
<h2 id="create-a-.cabal-file">Create a <code>.cabal</code> file</h2>
<p>If you haven’t done so already, create a Cabal file <code>your_project.cabal</code> in your project’s root folder to describe the dependencies in the traditional Haskell way. This step is mandatory!</p>
<h2 id="create-a-shell.nix-file">Create a <code>shell.nix</code> file</h2>
<p>Go to your project’s root folder that contains <code>your_project.cabal</code>, and do</p>
<pre><code>$ cabal2nix --shell . &gt; shell.nix</code></pre>
<p>. The actual syntax is <code>cabal2nix --shell path/to/cabal/file</code>, which prints out the contents of the <code>.nix</code> file to STDOUT. In the case above, we redirect it to a file named <code>shell.nix</code>. The name of this file is important because it is what <code>nix-shell</code> expects.</p>
<p>Now just invoke</p>
<pre><code>$ nix-shell</code></pre>
<p>and you’re set. You will be dropped into a <code>bash</code> instance that has knowledge of the Nix store. The first time you run <code>nix-shell</code>, Nix will identify any missing dependencies and install them for you. Because your project’s <code>shell.nix</code> file describes a Haskell project, <code>nix-shell</code> will install GHC along the way. So when it’s ready, you can start <code>ghci</code>. Because you installed <code>cabal2nix</code> earlier, you have access to <code>cabal</code> (i.e., <code>cabal</code> is a dependency of <code>cabal2nix</code>).</p>
<p>To build your binary just do <code>cabal build</code>! Personally I like to instantiate a Cabal sandbox with <code>cabal sandbox init</code> first, and then do <code>cabal configure</code>, <code>cabal repl</code>, <code>cabal build</code>, etc.</p>
<h1 id="local-dependencies">Local dependencies</h1>
<p>If you’re like me, you might have a Haskell library you wrote for yourself (let’s call it “Private Project X” (PPX)) which is not on Hackage. If you just want to build PPX on its own, you can use the same steps outlined above. But what if your other project depends on PPX?</p>
<p>The trick is to use <code>cabal2nix</code>, and to set up your <code>~/.nixpkgs</code> folder. You should already have <code>~/.nixpkgs</code> created by now as a result of installing Nix. Make a folder called <code>~/.nixpkgs/my-local-hs</code>. Now do</p>
<pre><code>$ cabal2nix path/to/ppx &gt; ~/.nixpkgs/my-local-hs/ppx.nix</code></pre>
<p>. This will create a Nix expression that can be used to build PPX with Nix. It’s like creating a PKGBUILD file. The next step is to create a <code>~/.nixpkgs/config.nix</code> file, as follows:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/config.nix"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="sourceCode"><pre><code class="sourceCode"># Taken from
# http://lists.science.uu.nl/pipermail/nix-dev/2015-January/015601.html.
{
  packageOverrides = super: let self = super.pkgs; in
  {
    haskellngPackages = super.haskellngPackages.override {
      overrides = self: super: {

        # Enable profiling. Taken from
        # http://lists.science.uu.nl/pipermail/nix-dev/2015-January/015620.html.
        # Comment out this line if you do not want to enable profiling!
        mkDerivation = expr: super.mkDerivation (expr // {
          enableLibraryProfiling = true; });

        # Private package
        ztile = self.callPackage ./my-local-hs/ppx.nix {};
      };
    };
  };
}</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/config.nix"  mimetype=text/plain > config.nix </a>
</div>
</div>
<p>. Now, invoke <code>cabal2nix --shell</code> for your other project that depends on PPX. When you invoke <code>nix-shell</code> for this other project, Nix should be able to resolve the dependency, based on the information you gave it in <code>~/.nixpkgs/config.nix</code>. That’s it!</p>
<h1 id="conclusion">Conclusion</h1>
<p>I recommend trying Nix out for Haskell development, or just as a secondary package manager in general. Right now, everything “Just Works” and it’s a pleasure to see different Haskell projects re-use the same packages, even when they are Cabal-sandboxed, as long as you are doing everything within <code>nix-shell</code>.</p>
<p>Even though the title of this post suggests that this is an Arch Linux guide to Nix, there is nothing Arch-specific about it. You should be able to use the steps in this post for any Linux distribution.</p>
<p>Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>That being said, if you’re using Nix then there is little reason to continue to use the Arch packages. I say this with some reluctance, as I am the author of the <a href="https://github.com/listx/cabal2pkgbuild">cabal2pkgbuild utility</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>There are no Nix utilities with <code>nix</code> as its name, so there’s no concern about name clashing.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>To figure out what Nix packages set, a.k.a. <em>channel</em> you are using, do <code>nix-channel --list</code>.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Implementing Binary Search</title>
    <link href="http://listx.github.io/post/2014-12-13-implementing-binary-search.html" />
    <id>http://listx.github.io/post/2014-12-13-implementing-binary-search.html</id>
    <published>2014-12-13T00:00:00Z</published>
    <updated>2014-12-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2014-12-13</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-12-13-implementing-binary-search.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/c.html">c</a>, <a href="/tag/ruby.html">ruby</a>, <a href="/tag/haskell.html">haskell</a>
</div>

<p>If you are a programmer, I’m sure you’ve encountered the term <em>binary search</em> at some point in time. I know what binary search is, but I’m writing this post to solidify my understanding of it. I also want to compare how it might be naively implemented across my 3 favorite languages C, Ruby, and Haskell — because naive code is the best code (to learn from)!</p>
<h2 id="binary-subdivision">Binary Subdivision</h2>
<p>You can skip this section if you want — I merely want to write how I first met and fell in love with the concept of <em>binary subdivision</em>. I first discovered binary division when I was in high school. It was a very pleasant realization, and at the time I did not fully realize what I had accidentally encountered.</p>
<p>The situation was so: my Biology teacher, Mr. Kennedy, told everyone to draw an even 4x4 square grid on the palms of our hands. Everyone was supposed to draw their own 4x4 grid — but this was when I asked myself, “how can I draw the most even-looking grid without using a ruler?” You see, I could not use a ruler because I was using my right hand to draw onto my left hand — and to hold a ruler properly I would need a third hand! So there was the problem.</p>
<p>On the one hand, I could not simply draw the four horizontal and four vertical lines one after the other, left to right, top to bottom, because I knew that I would introduce a great deal of additive error.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> I did not want to draw an ugly, lopsided square.</p>
<p>It took me a few seconds, but I came up with a plan. I first drew a single large square. Then knowing that I could easily eyeball with good accuracy where the <em>middle point of that square</em> was horizontally, I drew a vertical line down the <em>middle</em>. I then did the same thing in the other axis vertically. I repeated this procedure a few more times, <em>recursively subdividing</em> each smaller rectangular shape into halves, finally ending up with a nice-looking grid. I glanced around the room, and later looked at other students’ palms to see if they had discovered this “divide by <span class="math">\(\frac{1}{2}\)</span>” trick, but to my dismay no one had done it; I knew this was the case because everybody else’s square was sloppy.</p>
<p>I cannot honestly say if this was the very first time I realized the underlying geometric concepts at play here, but I can affirmatively say that it really was the first time I systematically applied such an elegant solution to a given problem. I wonder if most people who draw grids even bother to think of it as a problem.</p>
<p>To me, binary subdivision is the underpinning principle behind binary search. Continued subdvision by halves is like exponentiation in reverse; pretty soon, you end up with extremely tiny numbers. This is where the power of binary search comes from! Simply put, binary search is like binary subdivision, but you get to subdivide <em>toward</em> the location of whatever you’re looking for. Isn’t that cool?</p>
<h2 id="the-problem">The Problem</h2>
<p>The problem is simple — given a <strong>sorted</strong> list <code>KEYS</code> of items (for simplicity’s sake, positive integers), determine if <code>key</code> is in it, and also, the position of <code>key</code> in the list if it is indeed in the list. The catch is that you have no idea as to the contents of <code>KEYS</code> — only that it is sorted from smallest to largest.</p>
<h2 id="naive-approach-linear-search">Naive Approach — Linear Search</h2>
<p>The simplest way of doing this is by linear search. It is probably the novice programmer’s first reaction. You just start from the first item in <code>KEYS</code>, and run a <strong>for</strong>-loop all the way across the list, looking at every single item. There are now two possibilities — either (1) you indeed discover <code>key</code>, and report back your position (aka the “index”, usually in the form of the familiar <code>i</code> variable in C/C++/Java code), or (2) you find nothing. If you are clever, you can optimize the search in the second situation by breaking out of the <strong>for</strong>-loop if the items you are comparing are larger than <code>key</code>; after all, <code>KEYS</code> is sorted, so we know for a fact that the later numbers are only going to get bigger, so there is no point in trying to find <code>key</code> in that crowd of numbers.</p>
<p>But think of the consequences — what’s the worst case scenario? Imagine you have 1 trillion items, and that <code>key</code> is not in it, because let’s say <code>key</code> is a much bigger number than the biggest number in <code>KEYS</code> — but of course you haven’t run the linear search yet, so you don’t know that. Given this situation, you would have to search the <em>entire</em> list of all numbers in <code>KEYS</code> before reaching condition (2) described above.</p>
<p>If you wanted to get a little more clever to avoid this problem of searching all 1 trillion items, you could tell the algorithm to refuse to enter the <strong>for</strong>-loop if <code>key</code> lies outside the <em>bounds</em> of <code>KEYS</code>. Checking the bounds is easy and takes constant time, as you merely check for the first and last item’s size (again, as <code>KEYS</code> is sorted), and those are your bounds. This way, if <code>key</code> lies outside the bounds, you can <em>guarantee</em> that it is not in <code>KEYS</code>, no matter how many items <code>KEYS</code> has.</p>
<p>And, this is it. There is nothing more to optimize using this method (let’s not get into parallelization). What else can you do, really, when searching linearly, looping through every item from the beginning to the next?</p>
<h2 id="inverted-bounds-checking-aka-binary-search">Inverted Bounds-Checking, aka Binary Search</h2>
<p>The heading of this subsection might have already given you a hint as to what binary search entails. (Although, if you’ve read the <em>Binary Subdivision</em> section, you should have had a good idea anyhow.) Binary search takes the concept of bounds-checking, and applies it repeatedly, recursively, against <code>KEYS</code>. The only difference when I say “bounds-checking” in the context of binary search is that we do <em>not</em> care about the values of those bounds, but merely that they <em>are</em> the bounds. This is because we only concern ourselves with dividing the list of sorted numbers by <span class="math">\(\frac{1}{2}\)</span> every time and take the <em>middle</em> index <code>middle_index</code>, which is located as close as possible to the middle element (halfway between the two bounds). Indeed, the only way to get a valid <code>middle_index</code> value is if we know the bounds (the size of the list). We keep doing this recursively until <code>KEYS[mid] == key</code>.</p>
<p>The following is the pseudocode.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search-pseudo-0.txt"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode">KEYS = some random list of numbers
key = the number we&#39;re looking for in KEYS

binary_search(KEYS, key):
	middle_index = get_middle_index_index(length of KEYS)
	lower_KEYS = get_below(middle_index, KEYS)
	upper_KEYS = get_above(middle_index, KEYS)
	if key &lt; KEYS[middle_index]
		binary_search(lower_KEYS, key)
	else if key &gt; KEYS[middle_index]
		binary_search(upper_KEYS, key)
	else
		return middle_index
	end</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search-pseudo-0.txt"  mimetype=text/plain > binary-search-pseudo-0.txt </a>
</div>
</div>
<p>There are some obvious holes in the code above.</p>
<p>First, we always assume that <code>KEYS</code> is made up of multiple elements, and that its halves <code>lower_keys</code> and <code>upper_keys</code> also have multiple elements in them. In the extreme case, <code>KEYS</code> might be an empty list, which would make the whole thing explode.</p>
<p>Second, the <code>get_middle_index()</code>, <code>get_below_mid()</code>, and <code>get_above_mid()</code> functions remain undefined.</p>
<p>Aside: You might be wondering about lines 12-14. We could write</p>
<pre><code>else if key == KEYS[mid]</code></pre>
<p>instead of just <code>else</code> on line 12, but that is redundant. This is because we already test for the two other conditions of <code>key</code> being <em>lesser</em> or <em>greater</em> than <code>middle_index</code>. Therefore, we’ve excluded the two other conditions and are already only left with the third condition of <code>key == KEYS[mid]</code> evaluating to TRUE — hence we write just <code>else</code> on line 12.</p>
<p>Addressing the holes above, we get the next version.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search-pseudo-1.txt"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="sourceCode"><pre><code class="sourceCode">KEYS = some random list of numbers
first_index = 0
last_index = 999 (our KEYS is 1000 elements big)
key = the number we&#39;re looking for in KEYS

binary_search(KEYS, key, first_index, last_index):
	list_size = (last_index - first_index) + 1
	if list_size == 0
		return KEY_NOT_FOUND
	end

	middle_index = list_size / 2 + first_index

	if key &lt; KEYS[middle_index]
		binary_search(KEYS, key, first_index, middle_index - 1)
	else if key &gt; KEYS[middle_index]
		binary_search(KEYS, key, middle_index + 1, last_index)
	else
		return middle_index
	end</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search-pseudo-1.txt"  mimetype=text/plain > binary-search-pseudo-1.txt </a>
</div>
</div>
<p>There are some obvious differences — mainly the fact that we concern ourselves primarily with the first and last index numbers of the list, and work with these indices instead of working with the entire list <code>KEYS</code> itself. The <code>get_below()</code> and <code>get_above()</code> functions are gone and have been replaced with the index bounds <code>first_index, middle_index</code> and <code>middle_index + 1, last_index</code>, respectively. As you can see, working with these index numbers directly avoids a lot of abstraction. Actually, the <code>list_size</code> abstraction can be further reduced in terms of indices, so that <code>list_size == 0</code> can be rewritten as <code>first_index &gt; last_index</code>.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<h2 id="theoretical-performance">Theoretical Performance</h2>
<p>You can probably see why binary search is so powerful. It repeatedly divides the search region into <span class="math">\(\frac{1}{2}\)</span> of its original size. It’s sort of like <a href="http://en.wikipedia.org/wiki/Zeno%27s_paradoxes">Zeno’s Dichotomy Paradox</a>, except that it uses the “absurdity” of Zeno’s argument, and uses that to its advantage. To me, these somewhat related, even tangential, connections make binary search that much more elegant.</p>
<p>Consider this: a list that has 100,000 elements will only take, in the worst case, around 16 calls. Compare that to linear search, which will take at most 100,000 calls or iterations (if our item happens to be at the very last index).<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> The time complexity of binary search for a list of <span class="math">\(\mathit{KEYS\_TOTAL}\)</span> elements is defined to be <span class="math">\(\lfloor\log_2\mathit{KEYS\_TOTAL}\rfloor\)</span>. Because this defines an exponential relationship, we can rest assured that we can <em>cut down</em> a very large list quickly.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<h2 id="naive-implementations">Naive Implementations</h2>
<h3 id="preliminary-details">Preliminary Details</h3>
<p>I said at the beginning of the post that I would show a naive implementation in C, Ruby, and Haskell. I could have simply written a <code>binary_search()</code> function (and only that function) for all three languages — but instead I chose to write full standalone programs for all three that print out the same results. Because they are all standalone programs, you can easily tweak some settings (namely, the <code>KEYS_TOTAL</code> value), and see how it scales.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> All versions use the new <a href="http://www.pcg-random.org">PCG family</a> of pseudorandom number generators (RNGs), which have been created by Prof. Melissa E. O’Neill, author of the great paper <em>The Genuine Sieve of Eratosthenes</em>.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<h3 id="c-version-linux">C Version (Linux)</h3>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search.c"><table class="sourceCode numberLines c"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * LICENSE: PUBLIC DOMAIN</span>
<span class="co"> *</span>
<span class="co"> * Compile with `gcc -o binary-search-c -Wall -Wextra -Wpedantic --std=gnu11 -O2</span>
<span class="co"> * binary-search.c&#39;. Check via valgrind with `valgrind --leak-check=full</span>
<span class="co"> * --show-leak-kinds=all -v path/to/binary&#39;.</span>
<span class="co"> *</span>
<span class="co"> * Usage: just execute the binary as-is without any arguments. To test the RNG,</span>
<span class="co"> * call with the argument &quot;rng&quot;.</span>
<span class="co"> */</span>

<span class="ot">#include &lt;stdbool.h&gt; </span><span class="co">/* bool */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdint.h&gt; </span><span class="co">/* UINT32_MAX */</span>
<span class="ot">#include &lt;stdlib.h&gt; </span><span class="co">/* malloc() */</span>
<span class="ot">#include &lt;string.h&gt; </span><span class="co">/* strcmp() */</span>
<span class="ot">#include &lt;inttypes.h&gt; </span><span class="co">/* uint32_t */</span>

<span class="kw">typedef</span> <span class="dt">uint32_t</span> u32;
<span class="kw">typedef</span> <span class="dt">uint64_t</span> u64;

<span class="co">/*</span>
<span class="co"> * &quot;-1&quot; is an invalid value to be used as an index for an array (the index</span>
<span class="co"> * number is what binary_search() looks for.)</span>
<span class="co"> */</span>
<span class="kw">enum</span> {KEY_NOT_FOUND = -<span class="dv">1</span>};
<span class="dt">const</span> <span class="dt">int</span> KEYS_TOTAL = <span class="dv">1000000</span>;

<span class="co">// *Really* minimal PCG32 code / (c) 2014 M.E. O&#39;Neill / pcg-random.org</span>
<span class="co">// Licensed under Apache License 2.0 (NO WARRANTY, etc. see website)</span>

<span class="kw">typedef</span> <span class="kw">struct</span> { u64 state;  <span class="dt">uint64_t</span> inc; } pcg32_random_t;

u32 pcg32_random_r(pcg32_random_t *rng)
{
	u64 oldstate = rng-&gt;state;
	rng-&gt;state = oldstate * 6364136223846793005ULL + (rng-&gt;inc|<span class="dv">1</span>);
	u32 xorshifted = ((oldstate &gt;&gt; 18u) ^ oldstate) &gt;&gt; 27u;
	u32 rot = oldstate &gt;&gt; 59u;
	<span class="kw">return</span> (xorshifted &gt;&gt; rot) | (xorshifted &lt;&lt; ((-rot) &amp; <span class="dv">31</span>));
}

u32 uniform32(<span class="dt">int</span> range, pcg32_random_t *rng)
{
	<span class="dt">unsigned</span> rand_limit, rand_excess;
	u32 x;
	rand_excess = ((UINT32_MAX % range) + <span class="dv">1</span>) % range;
	rand_limit = UINT32_MAX - rand_excess;
	<span class="kw">while</span> ((x = pcg32_random_r(rng)) &gt; rand_limit) {};
	<span class="kw">return</span> x % range;
}

<span class="co">/* Populate an array with increasing numbers; we randomly choose whether to skip</span>
<span class="co"> * to the next number by an increment of 1 or 2, so as to initialize the array</span>
<span class="co"> * slightly differently each time this function is called.</span>
<span class="co"> */</span>
u32 init_array(u32 *keys, bool has_key, pcg32_random_t *rng)
{
	<span class="dt">int</span> i, j;
	<span class="kw">for</span> (i = <span class="dv">0</span>, j = <span class="dv">0</span>; i &lt; KEYS_TOTAL; i++) {
		j += uniform32(<span class="dv">2</span>, rng);
		keys[i] = i + j;
	}

	<span class="co">/*</span>
<span class="co">	 * If we want to choose a key, randomly choose one from one of the</span>
<span class="co">	 * existing elements; otherwise, return an impossible key (where</span>
<span class="co">	 * &quot;impossible&quot; means a key whose value lies outside the range of values</span>
<span class="co">	 * that exist in the array).</span>
<span class="co">	 */</span>
	<span class="kw">if</span> (has_key)
		<span class="kw">return</span> keys[uniform32(KEYS_TOTAL, rng)];
	<span class="kw">else</span>
		<span class="co">/* Impossible key = biggest key + 1 */</span>
		<span class="kw">return</span> keys[KEYS_TOTAL - <span class="dv">1</span>] + <span class="dv">1</span>;
}

<span class="dt">int</span> binary_search(u32 *keys, u32 key, <span class="dt">int</span> min, <span class="dt">int</span> max)
{
	<span class="dt">int</span> list_size;
	<span class="dt">int</span> mid;

	list_size = (max - min) + <span class="dv">1</span>;
	<span class="kw">if</span> (list_size == <span class="dv">0</span>)
		<span class="kw">return</span> KEY_NOT_FOUND;

	mid = (list_size / <span class="dv">2</span>) + min;

	<span class="kw">if</span> (key &lt; keys[mid]) {
		<span class="kw">return</span> binary_search(keys, key, min, mid - <span class="dv">1</span>);
	} <span class="kw">else</span> <span class="kw">if</span> (key &gt; keys[mid]) {
		<span class="kw">return</span> binary_search(keys, key, mid + <span class="dv">1</span>, max);
	} <span class="kw">else</span> {
		<span class="kw">return</span> mid;
	}
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv)
{
	<span class="dt">int</span> i, min, max;
	<span class="dt">int</span> mid;
	bool has_key;
	u32 *keys;
	u32 key;
	pcg32_random_t rng = {0x1234567890abcdefULL, 0x1234567890abcdefULL};

	<span class="co">/* RNG self-test. */</span>
	<span class="kw">if</span> (argc &gt; <span class="dv">1</span> &amp;&amp; strcmp(argv[<span class="dv">1</span>], <span class="st">&quot;rng&quot;</span>) == <span class="dv">0</span>) {
		printf(<span class="st">&quot;Running RNG self-test.</span><span class="ch">\n</span><span class="st">&quot;</span>);
		printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, pcg32_random_r(&amp;rng));
		<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">1000000</span>; i++) {
			pcg32_random_r(&amp;rng);
		}
		printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, pcg32_random_r(&amp;rng));
		<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">100</span>; i++) {
			printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>,
				uniform32((UINT32_MAX / <span class="dv">2</span>) + (UINT32_MAX / <span class="dv">3</span>),
				&amp;rng));
		}
		keys = malloc(KEYS_TOTAL * <span class="kw">sizeof</span>(u32));
		<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++) {
			has_key = (bool)uniform32(<span class="dv">2</span>, &amp;rng);
			key = init_array(keys, has_key, &amp;rng);
			printf(<span class="st">&quot;last number in array %d for key %&quot;</span>PRIu32<span class="st">&quot;: &quot;</span>,
				i, key);
			printf(<span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, keys[KEYS_TOTAL - <span class="dv">1</span>]);
		}
		printf(<span class="st">&quot;Done.</span><span class="ch">\n</span><span class="st">&quot;</span>);
		printf(<span class="st">&quot;END C VERSION</span><span class="ch">\n</span><span class="st">&quot;</span>);
		free(keys);
		<span class="kw">return</span> <span class="dv">0</span>;
	}

	<span class="co">/*</span>
<span class="co">	 * Allocate space for our big array of keys, as well as our</span>
<span class="co">	 * in-place-modified &quot;mid&quot; value.</span>
<span class="co">	 */</span>
	keys = malloc(KEYS_TOTAL * <span class="kw">sizeof</span>(u32));

	<span class="co">/* Stress-test binary_search(). */</span>
	<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">20</span>; i++) {
		has_key = (bool)uniform32(<span class="dv">2</span>, &amp;rng);
		key = init_array(keys, has_key, &amp;rng);
		min = <span class="dv">0</span>;
		max = KEYS_TOTAL - <span class="dv">1</span>;
		mid = binary_search(keys, key, min, max);
		printf(<span class="st">&quot;%02d - &quot;</span>, i + <span class="dv">1</span>);
		<span class="kw">if</span> (mid == KEY_NOT_FOUND) {
			printf(<span class="st">&quot;key `%&quot;</span>PRIu32<span class="st">&quot;&#39; not found.</span><span class="ch">\n</span><span class="st">&quot;</span>, key);
		} <span class="kw">else</span> {
			printf(<span class="st">&quot;key `%&quot;</span>PRIu32<span class="st">&quot;&#39; found at keys[%d].</span><span class="ch">\n</span><span class="st">&quot;</span>,
				key, mid);
		}
	}

	printf(<span class="st">&quot;END C VERSION</span><span class="ch">\n</span><span class="st">&quot;</span>);
	free(keys);
	<span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search.c"  mimetype=text/plain > binary-search.c </a>
</div>
</div>
<p>Overview:</p>
<code>pcg32_random_r()</code> is PCG’s minimal implementation version. This is RNG we depend on to get identical randomly-generated data in the other Ruby and Haskell versions.
<code>uniform32()</code> tames all raw RNG’s like <code>pcg32_random_r()</code>; it <a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">removes any bias</a> that might be introduced if we were to use a simple modulo operation. Hence, we use <code>uniform32()</code> for all our RNG needs.
<code>init_array()</code> takes an empty array of fixed size, and populates it with semi-random numbers. I say <em>semi-random</em> because the number chosen to populate the array, in sequence, is steadily bumped up with the <code>j</code> variable, <strong>eliminating the need for sorting it afterwards</strong> in preparation for passing it to <code>binary_search()</code>.
Finally, we have <code>binary_search()</code> itself, written in a way to closely match the pseudocode presented above.
<p>I’ve tried to keep the code simple. You may find it disturbing that we use the same type for <code>KEY_NOT_FOUND</code> as the actual valid key value (<code>mid</code>) itself. This kind of type overloading is common in C, and is what gives C its bare metal speed — at the cost of (probable) disaster, of course.</p>
<h3 id="ruby-version">Ruby Version</h3>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="co"># LICENSE: PUBLIC DOMAIN</span>

<span class="co"># Interact with `irb -I . -r path/to/this/file&#39;.</span>

<span class="co"># Usage: just execute the binary as-is without any arguments. To test the RNG,</span>
<span class="co"># call with the argument &quot;rng&quot;.</span>

<span class="dt">U32_MAX</span> = <span class="bn">0xffffffff</span>
<span class="dt">U64_MAX</span> = <span class="bn">0xffffffffffffffff</span>
<span class="dt">U32_MOD</span> = <span class="dt">U32_MAX</span> + <span class="dv">1</span>
<span class="dt">U64_MOD</span> = <span class="dt">U64_MAX</span> + <span class="dv">1</span>

<span class="dt">KEYS_TOTAL</span> = <span class="dv">1000000</span>

<span class="kw">class</span> <span class="dt">PCG32</span>
	<span class="ot">@state</span>
	<span class="ot">@inc</span>

	<span class="kw">def</span> initialize(state, inc)
		<span class="ot">@state</span> = state
		<span class="ot">@inc</span> = inc
	<span class="kw">end</span>

	<span class="kw">def</span> pcg32_random_r
		oldstate = <span class="ot">@state</span>
		<span class="ot">@state</span> = (((oldstate * <span class="dv">6364136223846793005</span>) % <span class="dt">U64_MOD</span>) +
			(<span class="ot">@inc</span> | <span class="dv">1</span>)) % <span class="dt">U64_MOD</span>
		xorshifted = (((oldstate &gt;&gt; <span class="dv">18</span>) ^ oldstate) &gt;&gt; <span class="dv">27</span>) % <span class="dt">U32_MOD</span>
		rot = oldstate &gt;&gt; <span class="dv">59</span>
		(xorshifted &gt;&gt; rot) | ((xorshifted &lt;&lt; ((-rot) &amp; <span class="dv">31</span>)) % <span class="dt">U32_MOD</span>)
	<span class="kw">end</span>

	<span class="kw">def</span> uniform32(range)
		rand_excess = ((<span class="dt">U32_MAX</span> % range) + <span class="dv">1</span>) % range
		rand_limit = <span class="dt">U32_MAX</span> - rand_excess
		<span class="kw">while</span> ((x = <span class="dv">self</span>.pcg32_random_r) &gt; rand_limit)
		<span class="kw">end</span>
		x % range
	<span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> init_array(keys, has_key, rng)
	j = <span class="dv">0</span>
	<span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0</span>..(<span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>)
		j += rng.uniform32(<span class="dv">2</span>)
		keys[i] = i + j
	<span class="kw">end</span>

	<span class="kw">if</span> has_key
		keys[rng.uniform32(<span class="dt">KEYS_TOTAL</span>)]
	<span class="kw">else</span>
		keys[<span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>] + <span class="dv">1</span>
	<span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">def</span> binary_search(keys, key, min, max)
	list_size = (max - min) + <span class="dv">1</span>
	<span class="kw">if</span> (list_size == <span class="dv">0</span>)
		<span class="kw">return</span> <span class="dv">nil</span>
	<span class="kw">end</span>

	mid = (list_size / <span class="dv">2</span>) + min

	<span class="kw">if</span> (key &lt; keys[mid])
		binary_search(keys, key, min, mid - <span class="dv">1</span>)
	<span class="kw">elsif</span> (key &gt; keys[mid])
		binary_search(keys, key, mid + <span class="dv">1</span>, max)
	<span class="kw">else</span>
		mid
	<span class="kw">end</span>
<span class="kw">end</span>

<span class="co"># Begin program</span>

rng = <span class="dt">PCG32</span>.new(<span class="bn">0x1234567890abcdef</span>, <span class="bn">0x1234567890abcdef</span>)

<span class="co"># RNG self-test.</span>
<span class="kw">if</span> (<span class="dt">ARGV</span> == [<span class="st">&quot;rng&quot;</span>])
	puts <span class="st">&quot;Running RNG self-test.&quot;</span>
	puts rng.pcg32_random_r
	<span class="kw">for</span> n <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">999999</span>
		rng.pcg32_random_r
	<span class="kw">end</span>
	puts rng.pcg32_random_r
	<span class="kw">for</span> n <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">99</span>
		puts rng.uniform32((<span class="dt">U32_MAX</span> / <span class="dv">2</span>) + (<span class="dt">U32_MAX</span> / <span class="dv">3</span>))
	<span class="kw">end</span>
	<span class="kw">for</span> n <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">9</span>
		has_key = rng.uniform32(<span class="dv">2</span>) == <span class="dv">1</span>
		keys = []
		key = init_array(keys, has_key, rng)
		puts <span class="st">&quot;last number in array </span><span class="ot">#{</span>n<span class="ot">}</span><span class="st"> for key </span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">: </span><span class="ot">#{</span>keys[<span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>]<span class="ot">}</span><span class="st">&quot;</span>
	<span class="kw">end</span>
	puts <span class="st">&quot;Done.&quot;</span>
	puts <span class="st">&quot;END RUBY VERSION&quot;</span>
	exit
<span class="kw">end</span>

keys = []

<span class="co"># Stress-test &#39;binary_search&#39; method.</span>
<span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0</span>..<span class="dv">19</span>
	has_key = rng.uniform32(<span class="dv">2</span>) == <span class="dv">1</span>
	key = init_array(keys, has_key, rng)
	min = <span class="dv">0</span>
	max = <span class="dt">KEYS_TOTAL</span> - <span class="dv">1</span>
	mid = binary_search(keys, key, min, max)
	printf(<span class="st">&quot;%02d - &quot;</span>, i + <span class="dv">1</span>)
	<span class="kw">if</span> mid.nil?
		puts <span class="st">&quot;key `</span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">&#39; not found.&quot;</span>
	<span class="kw">else</span>
		puts <span class="st">&quot;key `</span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">&#39; found at keys[</span><span class="ot">#{</span>mid<span class="ot">}</span><span class="st">].&quot;</span>
	<span class="kw">end</span>
<span class="kw">end</span>
puts <span class="st">&quot;END RUBY VERSION&quot;</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search.rb"  mimetype=text/plain > binary-search.rb </a>
</div>
</div>
<p>This version, like the Haskell version, tries to follow the C version as much as possible. One drawback of this version is that because Ruby does not support fixed-width integers, we have to make liberal use of the modulo operator <code>%</code> to emulate integer overflow. We could just do a bitwise AND (<code>&amp;</code>) with a mask, but that would risk increased verbosity.</p>
<h3 id="haskell-version">Haskell Version</h3>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/binary-search.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span>

<span class="co">-- LICENSE: PUBLIC DOMAIN</span>
<span class="fu">--</span>
<span class="co">-- Compile with `ghc --make -Wall -Werror -O2 -dynamic -o binary-search-hs</span>
<span class="co">-- binary-search.hs&#39;. For better conformance with the C and Ruby versions, we</span>
<span class="co">-- use snake_case instead of camelCase wherever there is a direct parallel.</span>
<span class="fu">--</span>
<span class="co">-- Interact with `ghci path/to/this/file`.</span>
<span class="fu">--</span>
<span class="co">-- Usage: just execute the binary as-is without any arguments. To test the RNG,</span>
<span class="co">-- call with the argument &quot;rng&quot;.</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Bits</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">System.Environment</span>
<span class="kw">import </span><span class="dt">System.Exit</span>
<span class="kw">import </span><span class="dt">Text.Printf</span>

<span class="ot">u32_max ::</span> <span class="dt">Word32</span>
u32_max <span class="fu">=</span> <span class="bn">0xffffffff</span>

<span class="ot">keys_total ::</span> <span class="dt">Int</span>
keys_total <span class="fu">=</span> <span class="dv">1000000</span>

<span class="kw">data</span> <span class="dt">PCG32</span> <span class="fu">=</span> <span class="dt">PCG32</span>
	{<span class="ot"> state ::</span> <span class="dt">Word64</span>
	,<span class="ot"> inc ::</span> <span class="dt">Word64</span>
	}

<span class="ot">pcg32_random_r ::</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> (<span class="dt">Word32</span>, <span class="dt">PCG32</span>)
pcg32_random_r rng<span class="fu">@</span><span class="dt">PCG32</span>{<span class="fu">..</span>} <span class="fu">=</span> (result, rng {state <span class="fu">=</span> state&#39;})
	<span class="kw">where</span>
<span class="ot">	state&#39; ::</span> <span class="dt">Word64</span>
	state&#39; <span class="fu">=</span> state <span class="fu">*</span> <span class="dv">6364136223846793005</span> <span class="fu">+</span> (inc <span class="fu">.|.</span> <span class="dv">1</span>)
<span class="ot">	xorshifted ::</span> <span class="dt">Word32</span>
	xorshifted <span class="fu">=</span> fromIntegral <span class="fu">$</span> shiftR (xor (shiftR state <span class="dv">18</span>) state) <span class="dv">27</span>
<span class="ot">	rot ::</span> <span class="dt">Word32</span>
	rot <span class="fu">=</span> fromIntegral <span class="fu">$</span> shiftR state <span class="dv">59</span>
<span class="ot">	result ::</span> <span class="dt">Word32</span>
	result <span class="fu">=</span> fromIntegral
		<span class="fu">$</span> (shiftR xorshifted <span class="fu">$</span> fromIntegral rot)
			<span class="fu">.|.</span> (shiftL xorshifted <span class="fu">$</span> fromIntegral ((<span class="fu">-</span>rot) <span class="fu">.&amp;.</span> <span class="dv">31</span>))

<span class="ot">uniform32 ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> (<span class="dt">Word32</span>, <span class="dt">PCG32</span>)
uniform32 range rng <span class="fu">=</span> find_within_range rng
	<span class="kw">where</span>
<span class="ot">	rand_excess ::</span> <span class="dt">Word32</span>
	rand_excess <span class="fu">=</span> mod ((mod u32_max range) <span class="fu">+</span> <span class="dv">1</span>) range
<span class="ot">	rand_limit ::</span> <span class="dt">Word32</span>
	rand_limit <span class="fu">=</span> u32_max <span class="fu">-</span> rand_excess
	find_within_range rng&#39; <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&gt;</span> rand_limit
		<span class="kw">then</span> find_within_range rng&#39;&#39;
		<span class="kw">else</span> (mod x range, rng&#39;&#39;)
		<span class="kw">where</span>
		(x, rng&#39;&#39;) <span class="fu">=</span> pcg32_random_r rng&#39;

<span class="ot">init_array ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> ([<span class="dt">Word32</span>], <span class="dt">Word32</span>, <span class="dt">PCG32</span>)
init_array keys_size has_key rng0 <span class="fu">=</span> (keys, key, rng3)
	<span class="kw">where</span>
	(keys&#39;, rng1) <span class="fu">=</span> genKeysList [] <span class="dv">0</span> <span class="dv">0</span> rng0
	<span class="co">-- Need to reverse the list, because Haskell (like all Lispy languages?)</span>
	<span class="co">-- builds a list backwards when using the cons (:) operator.</span>
	keys <span class="fu">=</span> reverse keys&#39;
<span class="ot">	genKeysList ::</span> [<span class="dt">Word32</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> ([<span class="dt">Word32</span>], <span class="dt">PCG32</span>)
	genKeysList arr i j0 rng <span class="fu">=</span> <span class="kw">if</span> i <span class="fu">&lt;</span> keys_size
		<span class="kw">then</span> genKeysList ((i&#39; <span class="fu">+</span> j2&#39;)<span class="fu">:</span>arr) (i <span class="fu">+</span> <span class="dv">1</span>) j2 rng&#39;
		<span class="kw">else</span> (arr, rng)
		<span class="kw">where</span>
		i&#39; <span class="fu">=</span> fromIntegral i
		j2&#39; <span class="fu">=</span> fromIntegral j2
		(j1, rng&#39;) <span class="fu">=</span> uniform32 <span class="dv">2</span> rng
		j2 <span class="fu">=</span> j0 <span class="fu">+</span> fromIntegral j1
	(key, rng3) <span class="fu">=</span> <span class="kw">if</span> has_key
		<span class="kw">then</span>
			<span class="kw">let</span>
				(idx, rng2) <span class="fu">=</span> uniform32 (fromIntegral keys_total) rng1
			<span class="kw">in</span>
			(keys<span class="fu">!!</span>(fromIntegral idx), rng2)
		<span class="kw">else</span> (keys<span class="fu">!!</span>(keys_total <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">1</span>, rng1)

<span class="co">-- We use min&#39; and max&#39; because the non-apostrophe versions name-clash with</span>
<span class="co">-- Prelude&#39;s own functions. We could hide Prelude&#39;s imports, but that seems too</span>
<span class="co">-- roundabout.</span>
<span class="ot">binary_search ::</span> [<span class="dt">Word32</span>] <span class="ot">-&gt;</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
binary_search keys key min&#39; max&#39;
	<span class="fu">|</span> list_size <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
	<span class="fu">|</span> key <span class="fu">&lt;</span> keys<span class="fu">!!</span>mid <span class="fu">=</span> binary_search keys key min&#39; (mid <span class="fu">-</span> <span class="dv">1</span>)
	<span class="fu">|</span> key <span class="fu">&gt;</span> keys<span class="fu">!!</span>mid <span class="fu">=</span> binary_search keys key (mid <span class="fu">+</span> <span class="dv">1</span>) max&#39;
	<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> mid
	<span class="kw">where</span>
	list_size <span class="fu">=</span> (max&#39; <span class="fu">-</span> min&#39;) <span class="fu">+</span> <span class="dv">1</span>
	mid <span class="fu">=</span> (div list_size <span class="dv">2</span>) <span class="fu">+</span> min&#39;

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
	<span class="kw">let</span>
		rng0 <span class="fu">=</span> <span class="dt">PCG32</span>
			{ state <span class="fu">=</span> <span class="bn">0x1234567890abcdef</span>
			, inc <span class="fu">=</span> <span class="bn">0x1234567890abcdef</span>
			}
	args <span class="ot">&lt;-</span> getArgs
	when (args <span class="fu">==</span> [<span class="st">&quot;rng&quot;</span>]) <span class="fu">$</span> <span class="kw">do</span>
		putStrLn <span class="st">&quot;Running RNG self-test&quot;</span>
		<span class="kw">let</span>
			(num0, rng1) <span class="fu">=</span> pcg32_random_r rng0
		putStrLn <span class="fu">$</span> show num0
		rng2 <span class="ot">&lt;-</span> foldM warmupRng rng1 [<span class="dv">0</span><span class="fu">..</span><span class="dv">999999</span><span class="ot">::</span><span class="dt">Int</span>]
		<span class="kw">let</span>
			(num1, rng3) <span class="fu">=</span> pcg32_random_r rng2
		putStrLn <span class="fu">$</span> show num1
		rng4 <span class="ot">&lt;-</span> foldM testUniform32 rng3 [<span class="dv">0</span><span class="fu">..</span><span class="dv">99</span><span class="ot">::</span><span class="dt">Int</span>]
		_ <span class="ot">&lt;-</span> foldM testArray rng4 [<span class="dv">0</span><span class="fu">..</span><span class="dv">9</span><span class="ot">::</span><span class="dt">Int</span>]
		putStrLn <span class="st">&quot;Done.&quot;</span>
		putStrLn <span class="st">&quot;END HASKELL VERSION&quot;</span>
		exitSuccess
	_ <span class="ot">&lt;-</span> foldM testBinarySearch rng0 [<span class="dv">0</span><span class="fu">..</span><span class="dv">19</span><span class="ot">::</span><span class="dt">Int</span>]
	putStrLn <span class="st">&quot;END HASKELL VERSION&quot;</span>
	<span class="kw">where</span>
	warmupRng rng _ <span class="fu">=</span> return <span class="fu">.</span> snd <span class="fu">$</span> pcg32_random_r rng
	testUniform32 rng _ <span class="fu">=</span> <span class="kw">do</span>
		putStrLn <span class="fu">$</span> show num
		return rng&#39;
		<span class="kw">where</span>
		(num, rng&#39;) <span class="fu">=</span> uniform32 (div u32_max <span class="dv">2</span> <span class="fu">+</span> div u32_max <span class="dv">3</span>) rng
	testArray rng0 i <span class="fu">=</span> <span class="kw">do</span>
		putStrLn <span class="fu">$</span> <span class="st">&quot;last number in array &quot;</span>
			<span class="fu">++</span> show i
			<span class="fu">++</span> <span class="st">&quot; for key &quot;</span>
			<span class="fu">++</span> show key
			<span class="fu">++</span> <span class="st">&quot;: &quot;</span>
			<span class="fu">++</span> show (keys<span class="fu">!!</span>(keys_total <span class="fu">-</span> <span class="dv">1</span>))
		return rng2
		<span class="kw">where</span>
		(res, rng1) <span class="fu">=</span> uniform32 <span class="dv">2</span> rng0
		has_key <span class="fu">=</span> res <span class="fu">==</span> <span class="dv">1</span>
		(keys, key, rng2) <span class="fu">=</span> init_array keys_total has_key rng1
	testBinarySearch rng0 i <span class="fu">=</span> <span class="kw">do</span>
		printf <span class="st">&quot;%02d - &quot;</span> (i <span class="fu">+</span> <span class="dv">1</span>)
		<span class="kw">case</span> foundMid <span class="kw">of</span>
			<span class="dt">Just</span> mid <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;key `&quot;</span>
				<span class="fu">++</span> show key
				<span class="fu">++</span> <span class="st">&quot;&#39; found at keys[&quot;</span>
				<span class="fu">++</span> show mid
				<span class="fu">++</span> <span class="st">&quot;].&quot;</span>
			<span class="dt">Nothing</span> <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;key `&quot;</span>
				<span class="fu">++</span> show key
				<span class="fu">++</span> <span class="st">&quot;&#39; not found.&quot;</span>
		return rng2
		<span class="kw">where</span>
		(res, rng1) <span class="fu">=</span> uniform32 <span class="dv">2</span> rng0
		has_key <span class="fu">=</span> res <span class="fu">==</span> <span class="dv">1</span>
		(keys, key, rng2) <span class="fu">=</span> init_array keys_total has_key rng1
		min&#39; <span class="fu">=</span> <span class="dv">0</span>
		max&#39; <span class="fu">=</span> keys_total <span class="fu">-</span> <span class="dv">1</span>
		foundMid <span class="fu">=</span> binary_search keys key min&#39; max&#39;</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/binary-search.hs"  mimetype=text/plain > binary-search.hs </a>
</div>
</div>
<p>It pained me not to make use of Haskell’s much faster, efficient <code>Array</code> data structure instead of plain lists (that are constructed with the square brackets <code>[]</code>). And, I have to admit that it is written in a strange style; I’ve preserved the names of the variables from C and Ruby where I could, even though mixing snake_case with camelCase results in utter ugliness. I also restrained myself from using the <code>State</code> monad for keeping track of <code>PCG32</code>’s state. For you non-Haskellers, that means that I manually passed around RNG state (as you can see with <code>rng0</code>, <code>rng1</code>, <code>rng2</code>, etc.) as arguments and return values, because I did not want to place another barrier against quickly grasping the code. Do you really want monad transformers in a “naive” implementation?<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></p>
<p>The most immediate effect to me when writing the Haskell version was just how stateful the <code>uniform32()</code> and <code>init_array()</code> functions were. The C/Ruby brethren perform lots of variable mutation in those parts, and are consequently difficult to understand from a <em>pure</em> (type system) perspective. All of the silent type promotions in C were blatantly exposed by the Glasgow Haskell Compiler (GHC), making it necessary for me to include all of those explicit <code>fromIntegral</code> type promotions myself in <code>pcg32_random_r</code> and <code>init_array</code>.</p>
<p>But even with all of these explicit conversions and the un-idiomatic Haskell style (excluding coding style), I find the Haskell version much easier to understand. Just compare how clean <code>binary_search</code> looks in Haskell versus the other ones! And the fact that you can basically define nested functions/methods with the <code>where</code> clause makes hole-driven development a piece of cake.</p>
<h2 id="conclusion-and-hopes">Conclusion and Hopes</h2>
<p>I hope you’ve enjoyed looking at the various implementations of binary search. Binary search is certainly something you can write on your own, although getting the surrounding technicalities correct can be a chore — but isn’t that always the case when trying to obvserve the behavior of an algorithm in practice? You can look at the cute 10 or 15-line pseudocode on Wikipedia all day, but how can you be sure that it works? This focus on <strong>real world examples</strong> has been a driving principle behind all of my blog posts, and I hope it has helped you understand the algorithm better.</p>
<p>Binary search is something you can apply in real life, too. For me, I came into contact with it again when I learned about <code>git bisect</code>. I personally try to use binary search myself when I code; for example, if a large block of code does not work, I delete large chunks out, making the deletions ever finer, until I get to the source of the problem. You can think of these examples as binary search, where the key is the (as yet unknown) bad commit or line of code you have to fix. You can be your own algorithm! Isn’t that cool?</p>
<p>Thanks for reading, and happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It’s like in the children’s <a href="http://en.wikipedia.org/wiki/Chinese_whispers">“Telephone”</a> game, where the error of one person gets magnified at every step, until the end when the message gets so garbled up it becomes comical.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>“Hole-driven-development”, as I like to call it, is a top-down approach to development. You first define the larger pieces, and continuously define the smaller sub-pieces, until you reach atomic pieces (those pieces which cannot be further sub-divided). You might have noticed that this style of writing code has an eerie parallel to the whole (no pun intended!) discussion about binary subdivision, and so forth.</p>
<p>As an aside, in the Haskell community, <em>hole-driven Haskell</em> takes the same approach, but first you define the behaviors of the functions through its type signatures, and leave the implementation details undefined. This way, you can use the compiler’s type system to help you define what you want as you go; this is certainly a step up from <em>unassisted</em> hole-driven development that we are doing with the pseudocode here.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The condition <code>first_index &gt; last_index</code> might not make sense. This was the pseudocode on Wikipedia at the time I wrote this, and it didn’t make sense to me at first. But think of it this way: binary search involves division of the list into halves, repeatedly. So <code>first_index</code> and <code>last_index</code> get closer and closer to each other. The point is that the distance between these two markers will close, shrinking the list into smaller and smaller subparts. We can’t simply check if these two points meet, by writing <code>first_index == last_index</code>, because of the base case of a 1-element list. Such a list will have <code>first_index</code> as 0, and the <code>last_index</code> as also 0 — because there is only 1 index! In this case, the condition <code>first_index == last_index</code> to check for an empty list is inadequate.</p>
<p>If you look at how we call <code>binary_search()</code> again in lines 15 and 17, you will notice that the new definitions of <code>first_index</code> and <code>last_index</code> depend on <code>middle_index</code>, and it’s this interplay with <code>middle_index</code> that forces <code>last_index</code> to eventually become smaller than <code>first_index</code>. If you work out the algorithm through some small cases, you will see this happen eventually.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Linear search does have the advantage that, on a sorted list, it can take advantage of branch prediction. This is because the <code>if/else</code> test will <em>always go in one direction</em>, until when we get a match or when the element considered is greater than the search key. But in the long run as you increase the search space, binary search will beat linear search hands down.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>However, be mindful to the fact that binary search relies on the input list being sorted. Sorting a list itself is a fundamental problem in computer science, and there are numerous sorting algorithms as well as data structures that make such sorting more amenable. In the real world, I think 90% of your time is going to be spent sorting the list first, by which time the speed benefits of binary search probably won’t hold much influence. If the search space is always small, you could easily get away with linear search — why bother adding complexity where you don’t need it?<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>You could trivially add on a proper command-line argument handling mechanism. In particular, <code>KEYS_TOTAL</code> is dying to be decoupled from the program’s internals — but I leave that as an exercise to you. (Hint: use a command-line option parsing library!)<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>MELISSA E. O’NEILL (2009). The Genuine Sieve of Eratosthenes. Journal of Functional Programming, 19, pp 95-106. doi:10.1017/S0956796808007004. <a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">Online draft version</a>.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>What if I had indeed made use of the <code>State</code> monad, you ask? Well, first I wouldn’t need to pass in, or get back, the RNG state variables. I would just run the RNG-state-changing functions <em>inside</em> the <code>State</code> monad (actually, probably the <code>StateT</code> monad transformer as we’re in the <code>IO</code> monad anyway), to <code>get</code>/<code>put</code> the RNG states to read/write those values.<a href="#fnref8">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>The Parking Lot Problem: A Successor to FizzBuzz?</title>
    <link href="http://listx.github.io/post/2014-09-22-parking-lot-problem.html" />
    <id>http://listx.github.io/post/2014-09-22-parking-lot-problem.html</id>
    <published>2014-09-22T00:00:00Z</published>
    <updated>2014-09-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2014-09-22</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-09-22-parking-lot-problem.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/ruby.html">ruby</a>, <a href="/tag/haskell.html">haskell</a>
</div>

<p>In one of my side projects, I encountered a pair of interesting problems, the first of which which I call the <em>Parking Lot</em> problem, and the sister problem the <em>Parking Load</em> problem. They are but toy problems, but to anyone outside of the programming field, they sound quite complicated!</p>
<p>I’ve provided “Expected Output” sections for you to try out your own solutions against, so don’t be too aggressive with the scrollbar if you want to quiz yourself!</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>Imagine an infinite parking lot, where each parking space is given a natural number, starting with 0, 1, 2, 3, … to infinity. The entire lot is a single row of spaces — so that space <code>0</code> is the one closest to the entrance. There are a finite number of cars randomly parked in the lot, as people come and go as they wish. A new car has just arrived outside the lot, and the driver asks you, <em>“Where is the closest open parking space?”</em></p>
<p>The only information you have is the <em>taken</em> spaces list (<code>T</code>), which lists all the occupied parking spaces. This list is sometimes sorted — sometimes, it is not!</p>
<h2 id="expected-output">Expected Output</h2>
<p>Here is a set of expected inputs and outputs for our problem:</p>
<pre><code>Input -&gt; Output
[] -&gt; 0
[0] -&gt; 1
[0, 1] -&gt; 2
[1] -&gt; 0
[1,2,3] -&gt; 0
[0,1,2,3] -&gt; 4
[0,1,2,3,1000] -&gt; 4</code></pre>
<p>. You may notice that the input list is sorted (for readability), but recall that <code>T</code> <em>may or may not</em> be sorted! Try your own solution against these expected outputs!</p>
<h2 id="some-preliminary-observations">Some Preliminary Observations</h2>
<p>The most important thing here is <code>T</code>. If <code>T</code> is empty, then our parking lot is empty, so the answer is obviously <code>0</code>. In all other cases, we have to figure out the lowest number that is <em>absent</em> from <code>T</code>. Essentially, we can reduce the problem as follows:</p>
Find the lowest number not present in the set of integers <code>T</code>, where the lowest possible number is <code>0</code>.
<p>I used the metaphor of the parking spaces because it is more memorable, and more importantly, more familiar to the general public.</p>
<h2 id="mathematical-approach">Mathematical Approach</h2>
<p>Conceptually, the problem is very simple. Consider the infinite set <code>N</code>, which includes all natural numbers, starting from <code>0</code>. Then obviously, we can start with <code>N</code> itself, and remove every number in <code>N</code> that is also present in <code>T</code>. Then, when we are done (<code>T</code> is empty), we can look at <code>N</code> and retrieve the lowest number.</p>
<h3 id="sorting">Sorting</h3>
<p>Intuitively, we are really only interested in the first consecutive group of cars parked next to each other. Essentially, what you do is walk along from the very first parking space, <code>0</code>, and see if it is occupied. If it is occupied, you move on to the next space — if it is not occupied, you can stop because you found your answer!</p>
<p>There is no way to solve the problem without first sorting <code>T</code>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> You can solve the problem without sorting only in the edge case where <code>T</code>’s lowest number is greater than <code>0</code> — i.e., if the car most closely parked to the entrance is not on <code>0</code>, then you do not need to bother sorting <code>T</code>, because the answer is simply <code>0</code>. And, finding the lowest number in a given set is always a <span class="math">\(O(n)\)</span> operation because you need to loop through the entire set just once, keeping track of the lowest number found.</p>
<p>In the more common case (as seen in real life), the parking space closest to the driver (the most desirable parking space) is already taken; and what’s more, the group of spaces closest to the driver is already taken. In this case, we have to proceed from space <code>0</code>, and incrementally observe every subsequent space, until we arrive at an empty parking space. The insight here is that we are treating the multitude of consecutively parked cars as one giant car parked across multiple spaces, and are just trying to find the total number of spaces this car occupies.</p>
<h2 id="ruby">Ruby</h2>
<p>I think it is time for some actual code. While I could explain how the Ruby version works, I feel that I have already expounded upon the problem enough above, so that the code here should make intuitive sense.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/parking-space.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">def</span> get_parking_space(t)
	t_sorted = t.sort

	i = <span class="dv">0</span>
	<span class="kw">while</span> i &lt; t_sorted.size
		<span class="kw">if</span> i &lt; t_sorted[i]
			<span class="kw">break</span>
		<span class="kw">end</span>
		i += <span class="dv">1</span>
	<span class="kw">end</span>

	<span class="kw">return</span> i
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/parking-space.rb"  mimetype=text/plain > parking-space.rb </a>
</div>
</div>
<h2 id="haskell">Haskell</h2>
<p>The Haskell version is a direct translation of the Ruby version, as an iterative approach works just fine. The only drawback is that we use <code>Int</code> instead of the arbitrarily large <code>Integer</code> type for succinctness (we can use <code>Integer</code>, but some built-in functions like <code>sort</code> only work on <code>Int</code>).</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/parking-space.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="ot">getParkingSpace ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
getParkingSpace ts
	<span class="fu">|</span> null ts <span class="fu">=</span> <span class="dv">0</span>
	<span class="fu">|</span> otherwise <span class="fu">=</span> loop <span class="dv">0</span> <span class="fu">$</span> sort ts
	<span class="kw">where</span>
	loop i xs
		<span class="fu">|</span> i <span class="fu">==</span> length xs <span class="fu">=</span> i
		<span class="fu">|</span> i <span class="fu">&lt;</span> xs <span class="fu">!!</span> i <span class="fu">=</span> i
		<span class="fu">|</span> otherwise <span class="fu">=</span> loop (i <span class="fu">+</span> <span class="dv">1</span>) xs</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/parking-space.hs"  mimetype=text/plain > parking-space.hs </a>
</div>
</div>
<h3 id="functional-solution">Functional solution</h3>
<p>Michele Alzetta kindly sent me another solution, which has a much stronger “Haskell” flavor. I’ve made some slight adjustments; here it is:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/parking-space2.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="ot">getParkingSpace&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
getParkingSpace&#39; ts <span class="fu">=</span> fromMaybe
	(length ts)
	(elemIndex <span class="dt">False</span> <span class="fu">.</span> zipWith (<span class="fu">==</span>) [<span class="dv">0</span><span class="fu">..</span>] <span class="fu">$</span> sort ts)</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/parking-space2.hs"  mimetype=text/plain > parking-space2.hs </a>
</div>
</div>
<p>. The advantage of this version is that it only evaluates <code>length ts</code> (the input list) as a last resort, thanks to <code>fromMaybe</code>. It also uses standard Prelude functions like <code>elemIndex</code> and <code>zipWith</code> for easier understanding. Thanks Michele!</p>
<h2 id="low-level-interlude">Low-Level Interlude</h2>
<p>Did you realize that the basic concept here is the same as finding the least significant bit (LSB)? I.e., if the parking lot is one giant computer word, and a <code>1</code> bit represents an available parking space, then we are simply trying to find the LSB (the index of the bit being the same thing as the parking space number). This is such a common scenario, that there are native hardware instructions for this on most all CPUs. The canonical name for this operation is <a href="http://en.wikipedia.org/wiki/Find_first_set"><em>find first set</em></a> or <em>find first one</em>.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> In Linux, you can do <code>man ffs</code> to learn about how to use it in your C program.</p>
<p>Of course, the parking lot in our problem is of infinite size, which makes the size of <code>T</code> arbitrarily large; alas, we cannot use <code>ffs</code> here.</p>
<h1 id="the-parking-load-problem">The Parking Load Problem</h1>
<p>An interesting related problem is what I call the <em>Parking Load</em> problem. The scenario is the same as in the <em>Parking Lot</em> problem, but with the following twist: if the last (most far away) parked car determines the bounds of the parking lot (i.e., it is no longer considered infinitely large), then how many parking spaces are available?</p>
<p>Interestingly, this problem is easier to solve than the first problem. This seems paradoxical — surely, finding the first available parking space is easier than counting every single available space! But it is true — this problem is indeed easier — because we can solve the problem <em>without sorting</em>.</p>
<p>If we talk in terms of our “Low-Level Interlude,” this is essentially the same as saying, “Count the number of <code>1</code> bits.” There are very clever ways of counting bits, but that is not our concern, and so I will present a naive solution in Ruby.</p>
<h2 id="expected-output-1">Expected Output</h2>
<p>Like in the previous problem, below are some expected outputs for you to test your own version against.</p>
<pre><code>Input -&gt; Output
[] -&gt; &quot;N/A&quot;
[0] -&gt; 0
[0,1] -&gt; 0
[0,1,3] -&gt; 1
[999] -&gt; 999
[1,5,999] -&gt; 997</code></pre>
<p>We return “N/A” for the empty case because this condition does not make sense under the terms of the problem, which defines the bounds of the parking lot based on the car farthest away; if there are no cars to begin with, the problem cannot be posed.</p>
<h2 id="ruby-1">Ruby</h2>
<p>Without further ado, here is the Ruby solution.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/parking-spaces.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">def</span> get_parking_spaces(t)
	<span class="kw">if</span> t.empty?
		<span class="kw">return</span> <span class="st">&quot;N/A&quot;</span>
	<span class="kw">else</span>
		<span class="kw">return</span> (t.max - t.size) + <span class="dv">1</span>
	<span class="kw">end</span>
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/parking-spaces.rb"  mimetype=text/plain > parking-spaces.rb </a>
</div>
</div>
<h2 id="haskell-1">Haskell</h2>
<p>The Haskell version is not much different.</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/parking-spaces.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="ot">getParkingSpaces ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span>
getParkingSpaces t
	<span class="fu">|</span> null t <span class="fu">=</span> <span class="dt">Left</span> <span class="st">&quot;N/A&quot;</span>
	<span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Right</span> <span class="fu">$</span> (maximum t) <span class="fu">-</span> (length t) <span class="fu">+</span> <span class="dv">1</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/parking-spaces.hs"  mimetype=text/plain > parking-spaces.hs </a>
</div>
</div>
<h2 id="a-successor-to-fizzbuzz">A Successor to FizzBuzz?</h2>
<p>For some reason, I get a strong feeling that these problems are much more interesting than <a href="http://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a>. The fact that we talk about an <em>infinitely large</em> parking lot will probably throw a lot of newbies and naive thinkers off the right track. You have to be especially careful about edge cases, such as the empty list in the second Haskell version. I believe that good coders have a keen sense of edge cases, because correct algorithms must withstand them without blowing up. Just review the Haskell solutions and notice all of the edge cases that we have to look out for!</p>
<p>You might even get some crazy answers that consider at length related nonessential tangents and Big-O notation, but fail to realize just how simple, at least conceptually, the problem becomes once you sort <code>T</code>. And, I like these problems more than FizzBuzz because there are so many interesting points about it. For example, you can ask a simple related question: if you were the keeper of this parking lot, what kind of data structure would you use to keep track of the taken parking spaces? And of course, there are very conspicuous low-level analogues that more experienced coders can relate to.</p>
<p>I hope you enjoyed reading about these problems. Maybe you can quiz your friend about it, and see how they respond!</p>
<p>Happy hacking!</p>
<h2 id="update-january-2015">Update: January 2015</h2>
<p>I applied for a job at <a href="http://periscope.io">Periscope</a>, and during the process Tom O’Neill pointed out that the Parking Lot Problem can be solved without sorting using sparse bitsets.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> The idea is pretty simple — each bit represents a parking space, and if it is set to 1, we treat it as occupied, and if it is 0, we treat it as empty. If there are 1,000,000 parking spaces, then we would need 1,000,000 bits. But this is where “sparseness” comes in; if there are a ton of 0’s — say, 50,000 of them — in one spot, we can easily encode that information in fewer bits; the traditional approach is to use run-length encoding (RLE) to do this. E.g., you could write the number “50,000”, and then enclose it in special OP-codes that you reserve to declare that the “50,000” here means something special (in our case, that these 50,000 bits are all zeroes).</p>
<p>Another approach is to use an octree (a tree that always has 8 child nodes), or “Bzets” as coined by the late <a href="http://www.cs.ucla.edu/news/news-archive/2012/2012">Robert Uzgalis</a>, who passed away in 2012. An excellent set of slides are available online if you Google them, but I’ve also uploaded them to my site <a href="http://linusarver.com/upload/grid/file/attachment/fyle/54b437416c30006ac5000000/Bzets.pdf">here</a>. Essentially, the idea is to have a tree with 3 possible values for the child nodes: <code>0 1 T</code>. A <code>0</code> means that you can stop recursing down the tree, as all child nodes, recursively are all set to <code>0</code>. A <code>1</code>, similarly, means you can stop because all child nodes are set to <code>1</code>. A <code>T</code> just means that you have to walk down to the child nodes, because if you gather up all the child nodes’ bits, they are mixed with <code>0</code>s and <code>1</code>s. You can imagine how compact some representations can become. In fact, Uzgalis calls bzets as having logarithmic compression! A <a href="https://github.com/Bovinedragon/Binary-Bzet">project on Github exists</a> that seems to be from one of the 3 UCLA student teams charged with implementing a version of bzets.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You can, for example, loop from <code>0</code> to infinity and then see if this number exists in <code>T</code> — but this is probably the worst way to solve the problem, at least from a computational perspective. E.g., if it takes <span class="math">\(O(n)\)</span> to search through <code>T</code> to see if some integer <code>i</code> exists in it, then this algorithm has <span class="math">\(O(n^2)\)</span> complexity because you need to run the search for every single integer in <code>T</code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>A closely related operation is <a href="http://en.wikipedia.org/wiki/Two&#39;s_complement">two’s complement</a> arithmetic. You can read about it from the <a href="http://en.wikipedia.org/wiki/Find_first_set">“Find first set”</a> article on Wikipedia.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>No, I did not get the job. But I did get a free lesson in interviewing over Skype. And I also had a very pleasant conversation about sparse bitsets, and this alone made the whole thing worthwhile.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>My First Contribution to Git</title>
    <link href="http://listx.github.io/post/2014-09-09-my-first-contribution-to-git.html" />
    <id>http://listx.github.io/post/2014-09-09-my-first-contribution-to-git.html</id>
    <published>2014-09-09T00:00:00Z</published>
    <updated>2014-09-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2014-09-09</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-09-09-my-first-contribution-to-git.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/git.html">git</a>
</div>

<p>I am happy to say that my <a href="http://thread.gmane.org/gmane.comp.version-control.git/254705">first</a> <a href="http://thread.gmane.org/gmane.comp.version-control.git/255050">patches</a> were <a href="https://github.com/git/git/commit/4645b014c5c82a3b75337">recently merged</a> into the master Git branch! Now, I am by no means a C or Git expert, so the patches only dealt with changes to the documentation. I did not know anyone involved with Git in real life; nor did I have any experience submitting patches to a big project like Git. So, how did I do it?</p>
<h2 id="dead-simple-fix">Dead Simple Fix</h2>
<p>It all started when I typed in <code>man git init</code> and found this line:</p>
<pre><code>The template directory used will (in order):</code></pre>
<p>. Obviously, there was a missing word “be” in that sentence. I could not believe that such a glaring error was present in such a high profile project like Git. Then again, if you think about it, you only invoke <code>git init</code> once per project (to initialize a Git repository), so the vast majority of users have but a cursory glance at the manpage — that is, if they even bother at all to consult the manpages for such a basic task.</p>
<p>Anyway, my initial reaction was “Aha! I will fix this typo and submit my first patch to Git!”. I thought fixing something so simple and obvious would surely have no trouble getting into the main branch. But then, something stirred inside me, and compelled me to look for similar errors in the manpage. Judging by the pace of things, my next patch to Git might take one, two, five years (or forever?), and the thought of becoming a one-shot, one-commit, one-word-fix contributor made my ego twitch. And besides, it felt a bit stupid to just submit a two-letter (“b” and “e”) fix. I thought to myself, “Maybe there are other low-hanging fruits to pluck?”</p>
<h2 id="real-work">Real Work</h2>
<p>So, I set a medium-term goal to myself: read the entire <code>git init</code> manpage, with a singular focus on clarity. I spotted more typographical errors, and even some confusing parts that a Git newbie would have trouble with. <code>git init</code>, after all, is a very basic, fundamental operation that all newcomers to Git would probably have questions about. It might even be the first thing that newbies might look up in the docs!</p>
<p>First things first. I cloned the <a href="https://github.com/git/git">master Git repository</a> from GitHub. I then created a new branch to record my work; in the end, I created 7 commits. I read Git’s documentation on how to submit patches, and also consulted contribution advice for the Linux Kernel project in the form of <a href="http://youtu.be/LLBrBBImJt4">Greg Kroah-Hartman’s excellent talk</a>. The Linux Kernel is where Git’s real action is (tens of thousands of contributors, all using Git!), so it made sense to check out the Kernel’s way of doing things.</p>
<p>I used <code>git rebase -i</code> countless times until I got everything sorted out. I even reordered the commits to have the <a href="https://github.com/git/git/commit/6e1ccacbedf084971f095816f4450c4b607607c5">most basic one</a> (all typographical changes) be the first one, in case they wanted to merge just a few of them and reject the rest.</p>
<p>After re-reading everything for the eighth time, I sent an email to the official mailing list with <code>git send-email</code>. I checked <code>git blame</code> for the lines I touched to CC everyone that could be directly affected by my changes. After a few days, I got a response back — from the principal maintainer of Git, Junio Hamano, no less!</p>
<h2 id="the-response">The Response?</h2>
<p>He was very polite, and true to his duty as maintainer, very thorough. You can see the discussion that took place over at the <a href="http://thread.gmane.org/gmane.comp.version-control.git/254705">mailing list archive</a>. I sent off my second version of my 7-commit patch series after a few days, and waited.</p>
<p>And waited. I waited two weeks, but alas, my new patch series was not getting any further feedback. I was concerned that my changes were simply forgotten. A nagging thought annoyed me — “What if I miss the current merge window<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>?” In mild desperation, I sent an email directly to Junio to remind him about my patches. Still no response. A couple more weeks passed, and I almost forgot about my patches…</p>
<p>Until today! I got an email from <code>tip4commit.com</code> telling me that I was given some miniscule fraction of a bitcoin for my contribution to the Git project. It felt like some strange sort of scam, but even if it was, whoever wrote that automated emailing script did their homework on the Github API because lo and behold, my patches were indeed merged into the mainline!</p>
<h2 id="conclusion">Conclusion</h2>
<p>Well, as they say, if you don’t know how to code but still want to contribute to an open source project, you should work on the documentation! I assume that I did not get any feedback after the initial code review because the maintainer, Junio, was busy with other matters. If I think about it now, he does get tons of patches and needs to do countless merges, containing countless commits, to make a new release of Git.</p>
<p>So, when contributing to open source, try working on the documentation first. Improving the documentation not only benefits all newcomers to the project, but also helps you understand the project better — a win win! And, be patient with your patches — especially if the project you are contributing to has a busy schedule.</p>
<p>Happy hacking!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This is the period of time when the maintainer of a project accepts patches for the next release.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Reverse Polish Notation (RPN) Calculator in Ruby and Haskell</title>
    <link href="http://listx.github.io/post/2014-09-05-rpn-calculator.html" />
    <id>http://listx.github.io/post/2014-09-05-rpn-calculator.html</id>
    <published>2014-09-05T00:00:00Z</published>
    <updated>2014-09-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2014-09-05</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-09-05-rpn-calculator.md" title="History">*</a>
	<br>
	<a href="/tag/programming.html">programming</a>, <a href="/tag/ruby.html">ruby</a>, <a href="/tag/haskell.html">haskell</a>
</div>

<p>A friend of mine is in DevBootCamp, an intensive coding school program designed to get students ready for real world job placement. Anyway, he was telling me how he was given an extra credit assignment: implement a RPN calculator which supports 3 functions — add, subtract, and multiply — on integer numbers. I.e., write a function <code>evaluate()</code> that when given a string such as <code>&quot;3 4 + 8 *&quot;</code> gives the result <code>56</code>. He gave me his Ruby solution; in response, I wrote my own Ruby version and decided soon thereafter to write an equivalent Haskell version, because, why not?</p>
<h2 id="ruby">Ruby</h2>
<p>First, the Ruby version:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/rpn.rb"><table class="sourceCode numberLines ruby"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="sourceCode"><pre><code class="sourceCode ruby"><span class="kw">def</span> evaluate(equation_str)
	stack = []
	equation_str.split.each <span class="kw">do</span> |term|
		<span class="kw">case</span> term
		<span class="kw">when</span> <span class="ot">/^\d+?$/</span>
			stack.push(term.to_i)
		<span class="kw">when</span> <span class="st">&quot;+&quot;</span>, <span class="st">&quot;-&quot;</span>, <span class="st">&quot;*&quot;</span>
			<span class="kw">if</span> stack.size &lt; <span class="dv">2</span>
				raise <span class="st">&quot;stack too small for operator application&quot;</span>
			<span class="kw">else</span>
				b = stack.pop
				a = stack.pop
				op = term.to_sym
				c = b.send(op, a)
				stack.push(c)
			<span class="kw">end</span>
		<span class="kw">else</span>
			raise <span class="st">&quot;invalid input `</span><span class="ot">#{</span>term<span class="ot">}</span><span class="st">&#39;&quot;</span>
		<span class="kw">end</span>
	<span class="kw">end</span>
	stack
<span class="kw">end</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/rpn.rb"  mimetype=text/plain > rpn.rb </a>
</div>
</div>
<p>Pretty straightforward, yes? The <code>terms</code> variable holds an array of numbers and operators. We use a calculator stack (aptly named, <code>stack</code>) to untangle the RPN in a stack-based way.</p>
<p>In the <code>each</code> loop, the actions depend on what <code>term</code> looks like. If <code>term</code> is a number in string form, we convert it into a real number with <code>String#to_i</code>, and push it into <code>stack</code>. If <code>term</code> is one of the 3 recognized operators, we remove 2 terms <code>a</code> and <code>b</code> from <code>stack</code> and apply the necessary operation on it with Ruby’s magic <code>Object#send</code> method, and push the new term <code>c</code> back into <code>stack</code> for further operations (if any, in later iterations of the <code>while</code> loop). Otherwise, we reject the input as an invalid term.</p>
<h2 id="haskell">Haskell</h2>
<p>Here is the Haskell version:</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/toy/rpn.hs"><table class="sourceCode numberLines haskell"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span> (isDigit)

<span class="kw">data</span> <span class="dt">Term</span>
	<span class="fu">=</span> <span class="dt">TermInt</span> <span class="dt">Integer</span>
	<span class="fu">|</span> <span class="dt">TermOp</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)

<span class="ot">evaluate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
evaluate <span class="fu">=</span> evalTerms <span class="fu">.</span> map mkTerm <span class="fu">.</span> words

<span class="ot">mkTerm ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>
mkTerm termStr <span class="fu">=</span> <span class="kw">case</span> termStr <span class="kw">of</span>
	<span class="st">&quot;+&quot;</span> <span class="ot">-&gt;</span> <span class="dt">TermOp</span> (<span class="fu">+</span>)
	<span class="st">&quot;-&quot;</span> <span class="ot">-&gt;</span> <span class="dt">TermOp</span> (<span class="fu">-</span>)
	<span class="st">&quot;*&quot;</span> <span class="ot">-&gt;</span> <span class="dt">TermOp</span> (<span class="fu">*</span>)
	_
		<span class="fu">|</span> and <span class="fu">$</span> map isDigit termStr <span class="ot">-&gt;</span> <span class="dt">TermInt</span> <span class="fu">$</span> read termStr
		<span class="fu">|</span> otherwise <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;invalid input `&quot;</span> <span class="fu">++</span> termStr <span class="fu">++</span> <span class="st">&quot;&#39;&quot;</span>

<span class="ot">evalTerms ::</span> [<span class="dt">Term</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
evalTerms <span class="fu">=</span> foldl modifyStack []
	<span class="kw">where</span>
	modifyStack stack term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
		<span class="dt">TermInt</span> n <span class="ot">-&gt;</span> n <span class="fu">:</span> stack
		<span class="dt">TermOp</span> op <span class="ot">-&gt;</span> <span class="kw">case</span> stack <span class="kw">of</span>
			(a<span class="fu">:</span>b<span class="fu">:</span>_) <span class="ot">-&gt;</span> op a b <span class="fu">:</span> drop <span class="dv">2</span> stack
			_ <span class="ot">-&gt;</span> error <span class="st">&quot;stack too small for operator application&quot;</span></code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/toy/rpn.hs"  mimetype=text/plain > rpn.hs </a>
</div>
</div>
<p>Probably the first thing to note is that we define a robust data type, <code>Term</code>, to encapsulate the values held in a given RPN string. We take advantage of Haskell’s functions-as-first-class-values ability, and define the <code>TermOp</code> constructor with it (i.e., it needs an arithmetic function <code>(Integer -&gt; Integer -&gt; Integer)</code> as an argument).</p>
<p>The next thing to notice is that the <code>evaluate</code> function is composed of smaller helper functions, <code>mkTerm</code> and <code>evalTerms</code>. <code>mkTerm</code> simply converts a <code>String</code> type into an appropriate <code>Term</code> type. <code>evalTerms</code> takes a list of <code>Term</code> values, and reduces it as much as possible by applying the <code>modifyStack</code> function over it with <code>foldl</code> (Haskell’s version of a single-pass loop).</p>
<p>When <code>modifyStack</code> encounters a <code>TermInt</code>, it pushes the number into the stack. When it encounters a <code>TermOp</code>, it applies that operator to the first 2 items in <code>stack</code>, and pushes this result back into <code>stack</code>. We use pattern matching with <code>(a:b:_)</code> to pull out the <code>a</code> and <code>b</code> values from the stack — the expression <code>(a:b:_)</code> means a value that matches either <span class="math">\([x_1, x_2]\)</span>, or <span class="math">\([x_1, x_2, ... , x_n]\)</span>, because the <code>_</code> operator matches anything, including the empty list <code>[]</code> used to finalize list creation. The <code>drop 2 stack</code> is necessary because Haskell’s types by default are immutable.</p>
<h2 id="thoughts">Thoughts</h2>
<p>I much prefer the Haskell version.</p>
<p>The separation of concerns is a big win — we can easily create helper functions like <code>mkTerm</code> and <code>evalTerms</code> because of Haskell’s purity<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Haskell embraces the use of algebraic data types (i.e., <code>Term</code> here), and perhaps this preference lends itself to the use of helper functions that convert things from one type to another. Ruby does not have types, at least in the sense of Haskell types, so to artificially create such concepts and to implement them would be difficult.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> I mean, I really want to write equivalent <code>mkTerm</code> and <code>evalTerms</code> methods in Ruby, but my beginner skills prevent me from doing it in a simple, straightforward way. I know enough about coding to abandon “solutions” that require circuitous, complex design.</p>
<p>I also like how all the functions are pure and thus easy to reason about with the type signatures. Refactoring code like this is a dream.</p>
<p>In short, algebraic data types, the clean delegation of subtasks to helper functions, and purity make the Haskell version easier to reason about and maintain in the long run.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Haskell’s <em>purity</em> is a term of art. Look it up!<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>The closest thing to Haskell types in Ruby, in my mind, are Ruby objects. Certainly, Ruby knows the difference between two objects belonging to different classes, but to do that here would make the code much longer and offer little benefit.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Find Lines with 80+ Columns in Multiple Files</title>
    <link href="http://listx.github.io/post/2014-08-11-find-files-with-80%2B-columns.html" />
    <id>http://listx.github.io/post/2014-08-11-find-files-with-80%2B-columns.html</id>
    <published>2014-08-11T00:00:00Z</published>
    <updated>2014-08-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2014-08-11</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-08-11-find-files-with-80+-columns.md" title="History">*</a>
	<br>
	<a href="/tag/linux.html">linux</a>, <a href="/tag/programming.html">programming</a>
</div>

<p>It’s nice to follow the 80-columns-per-line rule<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, but what if you have some lingering project that has yet to conform?</p>
<p>Just go to that project’s sources directory and do</p>
<div class="code-and-raw">
<div class="sourceCode" input="code/find-80-cols.sh"><table class="sourceCode numberLines bash"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash"><span class="kw">find</span> . -type f -exec sh -c <span class="st">&quot;expand -t 8 {} | grep -n </span><span class="dt">\&quot;</span><span class="st">.\{81\}</span><span class="dt">\&quot;</span><span class="st">&quot;</span> <span class="dt">\;</span> -print</code></pre></td></tr></table></div>
<div class="raw-link">
<a  class="raw"  href= "/code/find-80-cols.sh"  mimetype=text/plain > find-80-cols.sh </a>
</div>
</div>
<p>.</p>
<p>The call to <code>expand</code> is necessary because different people use different widths for tabs. That is, we are trying to find files with 80+ <em>columns</em> (as they appear to humans), not 80+ <em>characters</em> (as they appear to the computer).</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>See the <a href="https://www.kernel.org/doc/Documentation/CodingStyle">Linux Kernel Coding Style</a>, “Chapter 2: Breaking long lines and strings”.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Solving the "NVRM: API mismatch" Problem on Arch Linux</title>
    <link href="http://listx.github.io/post/2014-06-04-nvrm-api-mismatch.html" />
    <id>http://listx.github.io/post/2014-06-04-nvrm-api-mismatch.html</id>
    <published>2014-06-04T00:00:00Z</published>
    <updated>2014-06-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info center">
	<code class="date">2014-06-04</code><a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-06-04-nvrm-api-mismatch.md" title="History">*</a>
	<br>
	<a href="/tag/arch.html">arch</a>, <a href="/tag/linux.html">linux</a>, <a href="/tag/nvidia.html">nvidia</a>
</div>

<p>Sometimes when you do a system upgrade on Arch, Xorg will die on a reboot and you’ll get this kernel error (available with <code>dmesg</code>):</p>
<div class="sourceCode"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode">NVRM: API mismatch: the client has the version XXX.XX, but
NVRM: this kernel module has the version YYY.YY.  Please
NVRM: make sure that this kernel module and all NVIDIA driver
NVRM: components have the same version.</code></pre></td></tr></table></div>
<p>. This is usually the case when you upgrade your <code>linux</code> package, followed by upgrading your <code>nvidia</code> package. The problem is that the new kernel image references your older <code>nvidia</code> package (when it executed <code>mkinitcpio -p linux</code> before <code>nvidia</code> got upgraded). There are two possible solutions:</p>
<ol style="list-style-type: decimal">
<li>Simply remake your kernel image against your newly upgraded <code>nvidia</code> package. Run <code>mkinitcpio -p linux</code> again, and reboot.</li>
<li>In the alternative, downgrade to your previous set of <code>nvidia</code> drivers, located in <code>/var/cache/pacman/pkg/</code>.</li>
</ol>
<p>Hope this helps someone out there. =)</p>
]]></summary>
</entry>

</feed>
